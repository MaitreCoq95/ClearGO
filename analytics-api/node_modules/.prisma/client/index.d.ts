
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model DailyStat
 * 
 */
export type DailyStat = $Result.DefaultSelection<Prisma.$DailyStatPayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model AlertRule
 * 
 */
export type AlertRule = $Result.DefaultSelection<Prisma.$AlertRulePayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ReportTemplate
 * 
 */
export type ReportTemplate = $Result.DefaultSelection<Prisma.$ReportTemplatePayload>
/**
 * Model GeneratedReport
 * 
 */
export type GeneratedReport = $Result.DefaultSelection<Prisma.$GeneratedReportPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ManagerNote
 * 
 */
export type ManagerNote = $Result.DefaultSelection<Prisma.$ManagerNotePayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model ModulePrerequisite
 * 
 */
export type ModulePrerequisite = $Result.DefaultSelection<Prisma.$ModulePrerequisitePayload>
/**
 * Model ModuleAssignment
 * 
 */
export type ModuleAssignment = $Result.DefaultSelection<Prisma.$ModuleAssignmentPayload>
/**
 * Model ModuleProgress
 * 
 */
export type ModuleProgress = $Result.DefaultSelection<Prisma.$ModuleProgressPayload>
/**
 * Model AssessmentTemplate
 * 
 */
export type AssessmentTemplate = $Result.DefaultSelection<Prisma.$AssessmentTemplatePayload>
/**
 * Model AssessmentSession
 * 
 */
export type AssessmentSession = $Result.DefaultSelection<Prisma.$AssessmentSessionPayload>
/**
 * Model UserCertification
 * 
 */
export type UserCertification = $Result.DefaultSelection<Prisma.$UserCertificationPayload>
/**
 * Model Roadmap
 * 
 */
export type Roadmap = $Result.DefaultSelection<Prisma.$RoadmapPayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model UserAction
 * 
 */
export type UserAction = $Result.DefaultSelection<Prisma.$UserActionPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model StandardConfig
 * 
 */
export type StandardConfig = $Result.DefaultSelection<Prisma.$StandardConfigPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Events
 * const events = await prisma.event.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Events
   * const events = await prisma.event.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.dailyStat`: Exposes CRUD operations for the **DailyStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyStats
    * const dailyStats = await prisma.dailyStat.findMany()
    * ```
    */
  get dailyStat(): Prisma.DailyStatDelegate<ExtArgs>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs>;

  /**
   * `prisma.alertRule`: Exposes CRUD operations for the **AlertRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AlertRules
    * const alertRules = await prisma.alertRule.findMany()
    * ```
    */
  get alertRule(): Prisma.AlertRuleDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.reportTemplate`: Exposes CRUD operations for the **ReportTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportTemplates
    * const reportTemplates = await prisma.reportTemplate.findMany()
    * ```
    */
  get reportTemplate(): Prisma.ReportTemplateDelegate<ExtArgs>;

  /**
   * `prisma.generatedReport`: Exposes CRUD operations for the **GeneratedReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedReports
    * const generatedReports = await prisma.generatedReport.findMany()
    * ```
    */
  get generatedReport(): Prisma.GeneratedReportDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.managerNote`: Exposes CRUD operations for the **ManagerNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManagerNotes
    * const managerNotes = await prisma.managerNote.findMany()
    * ```
    */
  get managerNote(): Prisma.ManagerNoteDelegate<ExtArgs>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs>;

  /**
   * `prisma.modulePrerequisite`: Exposes CRUD operations for the **ModulePrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModulePrerequisites
    * const modulePrerequisites = await prisma.modulePrerequisite.findMany()
    * ```
    */
  get modulePrerequisite(): Prisma.ModulePrerequisiteDelegate<ExtArgs>;

  /**
   * `prisma.moduleAssignment`: Exposes CRUD operations for the **ModuleAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleAssignments
    * const moduleAssignments = await prisma.moduleAssignment.findMany()
    * ```
    */
  get moduleAssignment(): Prisma.ModuleAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.moduleProgress`: Exposes CRUD operations for the **ModuleProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleProgresses
    * const moduleProgresses = await prisma.moduleProgress.findMany()
    * ```
    */
  get moduleProgress(): Prisma.ModuleProgressDelegate<ExtArgs>;

  /**
   * `prisma.assessmentTemplate`: Exposes CRUD operations for the **AssessmentTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentTemplates
    * const assessmentTemplates = await prisma.assessmentTemplate.findMany()
    * ```
    */
  get assessmentTemplate(): Prisma.AssessmentTemplateDelegate<ExtArgs>;

  /**
   * `prisma.assessmentSession`: Exposes CRUD operations for the **AssessmentSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssessmentSessions
    * const assessmentSessions = await prisma.assessmentSession.findMany()
    * ```
    */
  get assessmentSession(): Prisma.AssessmentSessionDelegate<ExtArgs>;

  /**
   * `prisma.userCertification`: Exposes CRUD operations for the **UserCertification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCertifications
    * const userCertifications = await prisma.userCertification.findMany()
    * ```
    */
  get userCertification(): Prisma.UserCertificationDelegate<ExtArgs>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **Roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.RoadmapDelegate<ExtArgs>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs>;

  /**
   * `prisma.userAction`: Exposes CRUD operations for the **UserAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActions
    * const userActions = await prisma.userAction.findMany()
    * ```
    */
  get userAction(): Prisma.UserActionDelegate<ExtArgs>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs>;

  /**
   * `prisma.standardConfig`: Exposes CRUD operations for the **StandardConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StandardConfigs
    * const standardConfigs = await prisma.standardConfig.findMany()
    * ```
    */
  get standardConfig(): Prisma.StandardConfigDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Event: 'Event',
    DailyStat: 'DailyStat',
    UserProgress: 'UserProgress',
    AlertRule: 'AlertRule',
    Alert: 'Alert',
    Notification: 'Notification',
    ReportTemplate: 'ReportTemplate',
    GeneratedReport: 'GeneratedReport',
    Organization: 'Organization',
    Department: 'Department',
    User: 'User',
    ManagerNote: 'ManagerNote',
    Module: 'Module',
    ModulePrerequisite: 'ModulePrerequisite',
    ModuleAssignment: 'ModuleAssignment',
    ModuleProgress: 'ModuleProgress',
    AssessmentTemplate: 'AssessmentTemplate',
    AssessmentSession: 'AssessmentSession',
    UserCertification: 'UserCertification',
    Roadmap: 'Roadmap',
    Action: 'Action',
    UserAction: 'UserAction',
    Template: 'Template',
    StandardConfig: 'StandardConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "event" | "dailyStat" | "userProgress" | "alertRule" | "alert" | "notification" | "reportTemplate" | "generatedReport" | "organization" | "department" | "user" | "managerNote" | "module" | "modulePrerequisite" | "moduleAssignment" | "moduleProgress" | "assessmentTemplate" | "assessmentSession" | "userCertification" | "roadmap" | "action" | "userAction" | "template" | "standardConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      DailyStat: {
        payload: Prisma.$DailyStatPayload<ExtArgs>
        fields: Prisma.DailyStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          findFirst: {
            args: Prisma.DailyStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          findMany: {
            args: Prisma.DailyStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>[]
          }
          create: {
            args: Prisma.DailyStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          createMany: {
            args: Prisma.DailyStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>[]
          }
          delete: {
            args: Prisma.DailyStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          update: {
            args: Prisma.DailyStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          deleteMany: {
            args: Prisma.DailyStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyStatPayload>
          }
          aggregate: {
            args: Prisma.DailyStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyStat>
          }
          groupBy: {
            args: Prisma.DailyStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyStatCountArgs<ExtArgs>
            result: $Utils.Optional<DailyStatCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      AlertRule: {
        payload: Prisma.$AlertRulePayload<ExtArgs>
        fields: Prisma.AlertRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          findFirst: {
            args: Prisma.AlertRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          findMany: {
            args: Prisma.AlertRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>[]
          }
          create: {
            args: Prisma.AlertRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          createMany: {
            args: Prisma.AlertRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>[]
          }
          delete: {
            args: Prisma.AlertRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          update: {
            args: Prisma.AlertRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          deleteMany: {
            args: Prisma.AlertRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertRulePayload>
          }
          aggregate: {
            args: Prisma.AlertRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertRule>
          }
          groupBy: {
            args: Prisma.AlertRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertRuleCountArgs<ExtArgs>
            result: $Utils.Optional<AlertRuleCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ReportTemplate: {
        payload: Prisma.$ReportTemplatePayload<ExtArgs>
        fields: Prisma.ReportTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findFirst: {
            args: Prisma.ReportTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findMany: {
            args: Prisma.ReportTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          create: {
            args: Prisma.ReportTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          createMany: {
            args: Prisma.ReportTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          delete: {
            args: Prisma.ReportTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          update: {
            args: Prisma.ReportTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ReportTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          aggregate: {
            args: Prisma.ReportTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportTemplate>
          }
          groupBy: {
            args: Prisma.ReportTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateCountAggregateOutputType> | number
          }
        }
      }
      GeneratedReport: {
        payload: Prisma.$GeneratedReportPayload<ExtArgs>
        fields: Prisma.GeneratedReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>
          }
          findFirst: {
            args: Prisma.GeneratedReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>
          }
          findMany: {
            args: Prisma.GeneratedReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>[]
          }
          create: {
            args: Prisma.GeneratedReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>
          }
          createMany: {
            args: Prisma.GeneratedReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>[]
          }
          delete: {
            args: Prisma.GeneratedReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>
          }
          update: {
            args: Prisma.GeneratedReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>
          }
          deleteMany: {
            args: Prisma.GeneratedReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GeneratedReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedReportPayload>
          }
          aggregate: {
            args: Prisma.GeneratedReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedReport>
          }
          groupBy: {
            args: Prisma.GeneratedReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedReportCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedReportCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ManagerNote: {
        payload: Prisma.$ManagerNotePayload<ExtArgs>
        fields: Prisma.ManagerNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>
          }
          findFirst: {
            args: Prisma.ManagerNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>
          }
          findMany: {
            args: Prisma.ManagerNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>[]
          }
          create: {
            args: Prisma.ManagerNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>
          }
          createMany: {
            args: Prisma.ManagerNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ManagerNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>[]
          }
          delete: {
            args: Prisma.ManagerNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>
          }
          update: {
            args: Prisma.ManagerNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>
          }
          deleteMany: {
            args: Prisma.ManagerNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManagerNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerNotePayload>
          }
          aggregate: {
            args: Prisma.ManagerNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManagerNote>
          }
          groupBy: {
            args: Prisma.ManagerNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerNoteCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      ModulePrerequisite: {
        payload: Prisma.$ModulePrerequisitePayload<ExtArgs>
        fields: Prisma.ModulePrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModulePrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModulePrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>
          }
          findFirst: {
            args: Prisma.ModulePrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModulePrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>
          }
          findMany: {
            args: Prisma.ModulePrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>[]
          }
          create: {
            args: Prisma.ModulePrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>
          }
          createMany: {
            args: Prisma.ModulePrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModulePrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>[]
          }
          delete: {
            args: Prisma.ModulePrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>
          }
          update: {
            args: Prisma.ModulePrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.ModulePrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModulePrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModulePrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePrerequisitePayload>
          }
          aggregate: {
            args: Prisma.ModulePrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModulePrerequisite>
          }
          groupBy: {
            args: Prisma.ModulePrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModulePrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModulePrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<ModulePrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      ModuleAssignment: {
        payload: Prisma.$ModuleAssignmentPayload<ExtArgs>
        fields: Prisma.ModuleAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ModuleAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          findMany: {
            args: Prisma.ModuleAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>[]
          }
          create: {
            args: Prisma.ModuleAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          createMany: {
            args: Prisma.ModuleAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ModuleAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          update: {
            args: Prisma.ModuleAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ModuleAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ModuleAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleAssignment>
          }
          groupBy: {
            args: Prisma.ModuleAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ModuleProgress: {
        payload: Prisma.$ModuleProgressPayload<ExtArgs>
        fields: Prisma.ModuleProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          findFirst: {
            args: Prisma.ModuleProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          findMany: {
            args: Prisma.ModuleProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>[]
          }
          create: {
            args: Prisma.ModuleProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          createMany: {
            args: Prisma.ModuleProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>[]
          }
          delete: {
            args: Prisma.ModuleProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          update: {
            args: Prisma.ModuleProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          deleteMany: {
            args: Prisma.ModuleProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleProgressPayload>
          }
          aggregate: {
            args: Prisma.ModuleProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleProgress>
          }
          groupBy: {
            args: Prisma.ModuleProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleProgressCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleProgressCountAggregateOutputType> | number
          }
        }
      }
      AssessmentTemplate: {
        payload: Prisma.$AssessmentTemplatePayload<ExtArgs>
        fields: Prisma.AssessmentTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>
          }
          findFirst: {
            args: Prisma.AssessmentTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>
          }
          findMany: {
            args: Prisma.AssessmentTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>[]
          }
          create: {
            args: Prisma.AssessmentTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>
          }
          createMany: {
            args: Prisma.AssessmentTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>[]
          }
          delete: {
            args: Prisma.AssessmentTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>
          }
          update: {
            args: Prisma.AssessmentTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>
          }
          deleteMany: {
            args: Prisma.AssessmentTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentTemplatePayload>
          }
          aggregate: {
            args: Prisma.AssessmentTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentTemplate>
          }
          groupBy: {
            args: Prisma.AssessmentTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentTemplateCountAggregateOutputType> | number
          }
        }
      }
      AssessmentSession: {
        payload: Prisma.$AssessmentSessionPayload<ExtArgs>
        fields: Prisma.AssessmentSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssessmentSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssessmentSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>
          }
          findFirst: {
            args: Prisma.AssessmentSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssessmentSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>
          }
          findMany: {
            args: Prisma.AssessmentSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>[]
          }
          create: {
            args: Prisma.AssessmentSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>
          }
          createMany: {
            args: Prisma.AssessmentSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssessmentSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>[]
          }
          delete: {
            args: Prisma.AssessmentSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>
          }
          update: {
            args: Prisma.AssessmentSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>
          }
          deleteMany: {
            args: Prisma.AssessmentSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssessmentSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssessmentSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssessmentSessionPayload>
          }
          aggregate: {
            args: Prisma.AssessmentSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessmentSession>
          }
          groupBy: {
            args: Prisma.AssessmentSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssessmentSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentSessionCountAggregateOutputType> | number
          }
        }
      }
      UserCertification: {
        payload: Prisma.$UserCertificationPayload<ExtArgs>
        fields: Prisma.UserCertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCertificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCertificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>
          }
          findFirst: {
            args: Prisma.UserCertificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCertificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>
          }
          findMany: {
            args: Prisma.UserCertificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>[]
          }
          create: {
            args: Prisma.UserCertificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>
          }
          createMany: {
            args: Prisma.UserCertificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCertificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>[]
          }
          delete: {
            args: Prisma.UserCertificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>
          }
          update: {
            args: Prisma.UserCertificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>
          }
          deleteMany: {
            args: Prisma.UserCertificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCertificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCertificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCertificationPayload>
          }
          aggregate: {
            args: Prisma.UserCertificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCertification>
          }
          groupBy: {
            args: Prisma.UserCertificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCertificationCountArgs<ExtArgs>
            result: $Utils.Optional<UserCertificationCountAggregateOutputType> | number
          }
        }
      }
      Roadmap: {
        payload: Prisma.$RoadmapPayload<ExtArgs>
        fields: Prisma.RoadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findFirst: {
            args: Prisma.RoadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findMany: {
            args: Prisma.RoadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          create: {
            args: Prisma.RoadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          createMany: {
            args: Prisma.RoadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          delete: {
            args: Prisma.RoadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          update: {
            args: Prisma.RoadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.RoadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      UserAction: {
        payload: Prisma.$UserActionPayload<ExtArgs>
        fields: Prisma.UserActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>
          }
          findFirst: {
            args: Prisma.UserActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>
          }
          findMany: {
            args: Prisma.UserActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>[]
          }
          create: {
            args: Prisma.UserActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>
          }
          createMany: {
            args: Prisma.UserActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>[]
          }
          delete: {
            args: Prisma.UserActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>
          }
          update: {
            args: Prisma.UserActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>
          }
          deleteMany: {
            args: Prisma.UserActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserActionPayload>
          }
          aggregate: {
            args: Prisma.UserActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAction>
          }
          groupBy: {
            args: Prisma.UserActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserActionCountArgs<ExtArgs>
            result: $Utils.Optional<UserActionCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      StandardConfig: {
        payload: Prisma.$StandardConfigPayload<ExtArgs>
        fields: Prisma.StandardConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StandardConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StandardConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>
          }
          findFirst: {
            args: Prisma.StandardConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StandardConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>
          }
          findMany: {
            args: Prisma.StandardConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>[]
          }
          create: {
            args: Prisma.StandardConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>
          }
          createMany: {
            args: Prisma.StandardConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StandardConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>[]
          }
          delete: {
            args: Prisma.StandardConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>
          }
          update: {
            args: Prisma.StandardConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>
          }
          deleteMany: {
            args: Prisma.StandardConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StandardConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StandardConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StandardConfigPayload>
          }
          aggregate: {
            args: Prisma.StandardConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardConfig>
          }
          groupBy: {
            args: Prisma.StandardConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StandardConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StandardConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AlertRuleCountOutputType
   */

  export type AlertRuleCountOutputType = {
    alerts: number
  }

  export type AlertRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | AlertRuleCountOutputTypeCountAlertsArgs
  }

  // Custom InputTypes
  /**
   * AlertRuleCountOutputType without action
   */
  export type AlertRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRuleCountOutputType
     */
    select?: AlertRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertRuleCountOutputType without action
   */
  export type AlertRuleCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }


  /**
   * Count Type AlertCountOutputType
   */

  export type AlertCountOutputType = {
    notifications: number
  }

  export type AlertCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | AlertCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertCountOutputType
     */
    select?: AlertCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlertCountOutputType without action
   */
  export type AlertCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ReportTemplateCountOutputType
   */

  export type ReportTemplateCountOutputType = {
    reports: number
  }

  export type ReportTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ReportTemplateCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplateCountOutputType
     */
    select?: ReportTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedReportWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    departments: number
    users: number
    modules: number
    assessmentTemplates: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | OrganizationCountOutputTypeCountDepartmentsArgs
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    modules?: boolean | OrganizationCountOutputTypeCountModulesArgs
    assessmentTemplates?: boolean | OrganizationCountOutputTypeCountAssessmentTemplatesArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAssessmentTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentTemplateWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    members: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | DepartmentCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    managerNotes: number
    notesWritten: number
    managedDepartments: number
    assignmentsReceived: number
    assignmentsMade: number
    moduleProgress: number
    assessmentSessions: number
    certifications: number
    roadmaps: number
    userActions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    managerNotes?: boolean | UserCountOutputTypeCountManagerNotesArgs
    notesWritten?: boolean | UserCountOutputTypeCountNotesWrittenArgs
    managedDepartments?: boolean | UserCountOutputTypeCountManagedDepartmentsArgs
    assignmentsReceived?: boolean | UserCountOutputTypeCountAssignmentsReceivedArgs
    assignmentsMade?: boolean | UserCountOutputTypeCountAssignmentsMadeArgs
    moduleProgress?: boolean | UserCountOutputTypeCountModuleProgressArgs
    assessmentSessions?: boolean | UserCountOutputTypeCountAssessmentSessionsArgs
    certifications?: boolean | UserCountOutputTypeCountCertificationsArgs
    roadmaps?: boolean | UserCountOutputTypeCountRoadmapsArgs
    userActions?: boolean | UserCountOutputTypeCountUserActionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagerNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesWrittenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerNoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignmentsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssessmentSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCertificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActionWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    prerequisites: number
    unlocksModules: number
    assignments: number
    progress: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisites?: boolean | ModuleCountOutputTypeCountPrerequisitesArgs
    unlocksModules?: boolean | ModuleCountOutputTypeCountUnlocksModulesArgs
    assignments?: boolean | ModuleCountOutputTypeCountAssignmentsArgs
    progress?: boolean | ModuleCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePrerequisiteWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountUnlocksModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePrerequisiteWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleProgressWhereInput
  }


  /**
   * Count Type AssessmentTemplateCountOutputType
   */

  export type AssessmentTemplateCountOutputType = {
    sessions: number
  }

  export type AssessmentTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AssessmentTemplateCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * AssessmentTemplateCountOutputType without action
   */
  export type AssessmentTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplateCountOutputType
     */
    select?: AssessmentTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssessmentTemplateCountOutputType without action
   */
  export type AssessmentTemplateCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentSessionWhereInput
  }


  /**
   * Count Type RoadmapCountOutputType
   */

  export type RoadmapCountOutputType = {
    userActions: number
  }

  export type RoadmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userActions?: boolean | RoadmapCountOutputTypeCountUserActionsArgs
  }

  // Custom InputTypes
  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapCountOutputType
     */
    select?: RoadmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountUserActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActionWhereInput
  }


  /**
   * Count Type ActionCountOutputType
   */

  export type ActionCountOutputType = {
    userActions: number
  }

  export type ActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userActions?: boolean | ActionCountOutputTypeCountUserActionsArgs
  }

  // Custom InputTypes
  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionCountOutputType
     */
    select?: ActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeCountUserActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    eventType: string | null
    page: string | null
    referrer: string | null
    userAgent: string | null
    ip: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    eventType: string | null
    page: string | null
    referrer: string | null
    userAgent: string | null
    ip: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    eventType: number
    eventData: number
    page: number
    referrer: number
    userAgent: number
    ip: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    eventType?: true
    page?: true
    referrer?: true
    userAgent?: true
    ip?: true
    timestamp?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    eventType?: true
    page?: true
    referrer?: true
    userAgent?: true
    ip?: true
    timestamp?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    eventType?: true
    eventData?: true
    page?: true
    referrer?: true
    userAgent?: true
    ip?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    userId: string | null
    sessionId: string
    eventType: string
    eventData: JsonValue | null
    page: string | null
    referrer: string | null
    userAgent: string | null
    ip: string | null
    timestamp: Date
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventType?: boolean
    eventData?: boolean
    page?: boolean
    referrer?: boolean
    userAgent?: boolean
    ip?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventType?: boolean
    eventData?: boolean
    page?: boolean
    referrer?: boolean
    userAgent?: boolean
    ip?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    eventType?: boolean
    eventData?: boolean
    page?: boolean
    referrer?: boolean
    userAgent?: boolean
    ip?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }


  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      sessionId: string
      eventType: string
      eventData: Prisma.JsonValue | null
      page: string | null
      referrer: string | null
      userAgent: string | null
      ip: string | null
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly userId: FieldRef<"Event", 'String'>
    readonly sessionId: FieldRef<"Event", 'String'>
    readonly eventType: FieldRef<"Event", 'String'>
    readonly eventData: FieldRef<"Event", 'Json'>
    readonly page: FieldRef<"Event", 'String'>
    readonly referrer: FieldRef<"Event", 'String'>
    readonly userAgent: FieldRef<"Event", 'String'>
    readonly ip: FieldRef<"Event", 'String'>
    readonly timestamp: FieldRef<"Event", 'DateTime'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
  }


  /**
   * Model DailyStat
   */

  export type AggregateDailyStat = {
    _count: DailyStatCountAggregateOutputType | null
    _avg: DailyStatAvgAggregateOutputType | null
    _sum: DailyStatSumAggregateOutputType | null
    _min: DailyStatMinAggregateOutputType | null
    _max: DailyStatMaxAggregateOutputType | null
  }

  export type DailyStatAvgAggregateOutputType = {
    totalEvents: number | null
    uniqueUsers: number | null
    uniqueSessions: number | null
    pageViews: number | null
    quizStarted: number | null
    quizCompleted: number | null
    modulesViewed: number | null
    lessonsCompleted: number | null
    avgSessionDuration: number | null
  }

  export type DailyStatSumAggregateOutputType = {
    totalEvents: number | null
    uniqueUsers: number | null
    uniqueSessions: number | null
    pageViews: number | null
    quizStarted: number | null
    quizCompleted: number | null
    modulesViewed: number | null
    lessonsCompleted: number | null
    avgSessionDuration: number | null
  }

  export type DailyStatMinAggregateOutputType = {
    id: string | null
    date: Date | null
    totalEvents: number | null
    uniqueUsers: number | null
    uniqueSessions: number | null
    pageViews: number | null
    quizStarted: number | null
    quizCompleted: number | null
    modulesViewed: number | null
    lessonsCompleted: number | null
    avgSessionDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyStatMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    totalEvents: number | null
    uniqueUsers: number | null
    uniqueSessions: number | null
    pageViews: number | null
    quizStarted: number | null
    quizCompleted: number | null
    modulesViewed: number | null
    lessonsCompleted: number | null
    avgSessionDuration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyStatCountAggregateOutputType = {
    id: number
    date: number
    totalEvents: number
    uniqueUsers: number
    uniqueSessions: number
    pageViews: number
    quizStarted: number
    quizCompleted: number
    modulesViewed: number
    lessonsCompleted: number
    avgSessionDuration: number
    eventsByType: number
    topPages: number
    topModules: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyStatAvgAggregateInputType = {
    totalEvents?: true
    uniqueUsers?: true
    uniqueSessions?: true
    pageViews?: true
    quizStarted?: true
    quizCompleted?: true
    modulesViewed?: true
    lessonsCompleted?: true
    avgSessionDuration?: true
  }

  export type DailyStatSumAggregateInputType = {
    totalEvents?: true
    uniqueUsers?: true
    uniqueSessions?: true
    pageViews?: true
    quizStarted?: true
    quizCompleted?: true
    modulesViewed?: true
    lessonsCompleted?: true
    avgSessionDuration?: true
  }

  export type DailyStatMinAggregateInputType = {
    id?: true
    date?: true
    totalEvents?: true
    uniqueUsers?: true
    uniqueSessions?: true
    pageViews?: true
    quizStarted?: true
    quizCompleted?: true
    modulesViewed?: true
    lessonsCompleted?: true
    avgSessionDuration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyStatMaxAggregateInputType = {
    id?: true
    date?: true
    totalEvents?: true
    uniqueUsers?: true
    uniqueSessions?: true
    pageViews?: true
    quizStarted?: true
    quizCompleted?: true
    modulesViewed?: true
    lessonsCompleted?: true
    avgSessionDuration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyStatCountAggregateInputType = {
    id?: true
    date?: true
    totalEvents?: true
    uniqueUsers?: true
    uniqueSessions?: true
    pageViews?: true
    quizStarted?: true
    quizCompleted?: true
    modulesViewed?: true
    lessonsCompleted?: true
    avgSessionDuration?: true
    eventsByType?: true
    topPages?: true
    topModules?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStat to aggregate.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyStats
    **/
    _count?: true | DailyStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyStatMaxAggregateInputType
  }

  export type GetDailyStatAggregateType<T extends DailyStatAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyStat[P]>
      : GetScalarType<T[P], AggregateDailyStat[P]>
  }




  export type DailyStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyStatWhereInput
    orderBy?: DailyStatOrderByWithAggregationInput | DailyStatOrderByWithAggregationInput[]
    by: DailyStatScalarFieldEnum[] | DailyStatScalarFieldEnum
    having?: DailyStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyStatCountAggregateInputType | true
    _avg?: DailyStatAvgAggregateInputType
    _sum?: DailyStatSumAggregateInputType
    _min?: DailyStatMinAggregateInputType
    _max?: DailyStatMaxAggregateInputType
  }

  export type DailyStatGroupByOutputType = {
    id: string
    date: Date
    totalEvents: number
    uniqueUsers: number
    uniqueSessions: number
    pageViews: number
    quizStarted: number
    quizCompleted: number
    modulesViewed: number
    lessonsCompleted: number
    avgSessionDuration: number
    eventsByType: JsonValue | null
    topPages: JsonValue | null
    topModules: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DailyStatCountAggregateOutputType | null
    _avg: DailyStatAvgAggregateOutputType | null
    _sum: DailyStatSumAggregateOutputType | null
    _min: DailyStatMinAggregateOutputType | null
    _max: DailyStatMaxAggregateOutputType | null
  }

  type GetDailyStatGroupByPayload<T extends DailyStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyStatGroupByOutputType[P]>
            : GetScalarType<T[P], DailyStatGroupByOutputType[P]>
        }
      >
    >


  export type DailyStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalEvents?: boolean
    uniqueUsers?: boolean
    uniqueSessions?: boolean
    pageViews?: boolean
    quizStarted?: boolean
    quizCompleted?: boolean
    modulesViewed?: boolean
    lessonsCompleted?: boolean
    avgSessionDuration?: boolean
    eventsByType?: boolean
    topPages?: boolean
    topModules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyStat"]>

  export type DailyStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalEvents?: boolean
    uniqueUsers?: boolean
    uniqueSessions?: boolean
    pageViews?: boolean
    quizStarted?: boolean
    quizCompleted?: boolean
    modulesViewed?: boolean
    lessonsCompleted?: boolean
    avgSessionDuration?: boolean
    eventsByType?: boolean
    topPages?: boolean
    topModules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyStat"]>

  export type DailyStatSelectScalar = {
    id?: boolean
    date?: boolean
    totalEvents?: boolean
    uniqueUsers?: boolean
    uniqueSessions?: boolean
    pageViews?: boolean
    quizStarted?: boolean
    quizCompleted?: boolean
    modulesViewed?: boolean
    lessonsCompleted?: boolean
    avgSessionDuration?: boolean
    eventsByType?: boolean
    topPages?: boolean
    topModules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DailyStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyStat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      totalEvents: number
      uniqueUsers: number
      uniqueSessions: number
      pageViews: number
      quizStarted: number
      quizCompleted: number
      modulesViewed: number
      lessonsCompleted: number
      avgSessionDuration: number
      eventsByType: Prisma.JsonValue | null
      topPages: Prisma.JsonValue | null
      topModules: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyStat"]>
    composites: {}
  }

  type DailyStatGetPayload<S extends boolean | null | undefined | DailyStatDefaultArgs> = $Result.GetResult<Prisma.$DailyStatPayload, S>

  type DailyStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyStatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyStatCountAggregateInputType | true
    }

  export interface DailyStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyStat'], meta: { name: 'DailyStat' } }
    /**
     * Find zero or one DailyStat that matches the filter.
     * @param {DailyStatFindUniqueArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyStatFindUniqueArgs>(args: SelectSubset<T, DailyStatFindUniqueArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyStat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyStatFindUniqueOrThrowArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyStatFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatFindFirstArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyStatFindFirstArgs>(args?: SelectSubset<T, DailyStatFindFirstArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatFindFirstOrThrowArgs} args - Arguments to find a DailyStat
     * @example
     * // Get one DailyStat
     * const dailyStat = await prisma.dailyStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyStatFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyStats
     * const dailyStats = await prisma.dailyStat.findMany()
     * 
     * // Get first 10 DailyStats
     * const dailyStats = await prisma.dailyStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyStatWithIdOnly = await prisma.dailyStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyStatFindManyArgs>(args?: SelectSubset<T, DailyStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyStat.
     * @param {DailyStatCreateArgs} args - Arguments to create a DailyStat.
     * @example
     * // Create one DailyStat
     * const DailyStat = await prisma.dailyStat.create({
     *   data: {
     *     // ... data to create a DailyStat
     *   }
     * })
     * 
     */
    create<T extends DailyStatCreateArgs>(args: SelectSubset<T, DailyStatCreateArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyStats.
     * @param {DailyStatCreateManyArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStat = await prisma.dailyStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyStatCreateManyArgs>(args?: SelectSubset<T, DailyStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyStats and returns the data saved in the database.
     * @param {DailyStatCreateManyAndReturnArgs} args - Arguments to create many DailyStats.
     * @example
     * // Create many DailyStats
     * const dailyStat = await prisma.dailyStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyStats and only return the `id`
     * const dailyStatWithIdOnly = await prisma.dailyStat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyStatCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyStat.
     * @param {DailyStatDeleteArgs} args - Arguments to delete one DailyStat.
     * @example
     * // Delete one DailyStat
     * const DailyStat = await prisma.dailyStat.delete({
     *   where: {
     *     // ... filter to delete one DailyStat
     *   }
     * })
     * 
     */
    delete<T extends DailyStatDeleteArgs>(args: SelectSubset<T, DailyStatDeleteArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyStat.
     * @param {DailyStatUpdateArgs} args - Arguments to update one DailyStat.
     * @example
     * // Update one DailyStat
     * const dailyStat = await prisma.dailyStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyStatUpdateArgs>(args: SelectSubset<T, DailyStatUpdateArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyStats.
     * @param {DailyStatDeleteManyArgs} args - Arguments to filter DailyStats to delete.
     * @example
     * // Delete a few DailyStats
     * const { count } = await prisma.dailyStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyStatDeleteManyArgs>(args?: SelectSubset<T, DailyStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyStats
     * const dailyStat = await prisma.dailyStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyStatUpdateManyArgs>(args: SelectSubset<T, DailyStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyStat.
     * @param {DailyStatUpsertArgs} args - Arguments to update or create a DailyStat.
     * @example
     * // Update or create a DailyStat
     * const dailyStat = await prisma.dailyStat.upsert({
     *   create: {
     *     // ... data to create a DailyStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyStat we want to update
     *   }
     * })
     */
    upsert<T extends DailyStatUpsertArgs>(args: SelectSubset<T, DailyStatUpsertArgs<ExtArgs>>): Prisma__DailyStatClient<$Result.GetResult<Prisma.$DailyStatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatCountArgs} args - Arguments to filter DailyStats to count.
     * @example
     * // Count the number of DailyStats
     * const count = await prisma.dailyStat.count({
     *   where: {
     *     // ... the filter for the DailyStats we want to count
     *   }
     * })
    **/
    count<T extends DailyStatCountArgs>(
      args?: Subset<T, DailyStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyStatAggregateArgs>(args: Subset<T, DailyStatAggregateArgs>): Prisma.PrismaPromise<GetDailyStatAggregateType<T>>

    /**
     * Group by DailyStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyStatGroupByArgs['orderBy'] }
        : { orderBy?: DailyStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyStat model
   */
  readonly fields: DailyStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyStat model
   */ 
  interface DailyStatFieldRefs {
    readonly id: FieldRef<"DailyStat", 'String'>
    readonly date: FieldRef<"DailyStat", 'DateTime'>
    readonly totalEvents: FieldRef<"DailyStat", 'Int'>
    readonly uniqueUsers: FieldRef<"DailyStat", 'Int'>
    readonly uniqueSessions: FieldRef<"DailyStat", 'Int'>
    readonly pageViews: FieldRef<"DailyStat", 'Int'>
    readonly quizStarted: FieldRef<"DailyStat", 'Int'>
    readonly quizCompleted: FieldRef<"DailyStat", 'Int'>
    readonly modulesViewed: FieldRef<"DailyStat", 'Int'>
    readonly lessonsCompleted: FieldRef<"DailyStat", 'Int'>
    readonly avgSessionDuration: FieldRef<"DailyStat", 'Float'>
    readonly eventsByType: FieldRef<"DailyStat", 'Json'>
    readonly topPages: FieldRef<"DailyStat", 'Json'>
    readonly topModules: FieldRef<"DailyStat", 'Json'>
    readonly createdAt: FieldRef<"DailyStat", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyStat findUnique
   */
  export type DailyStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat findUniqueOrThrow
   */
  export type DailyStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat findFirst
   */
  export type DailyStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * DailyStat findFirstOrThrow
   */
  export type DailyStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Filter, which DailyStat to fetch.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStats.
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStats.
     */
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * DailyStat findMany
   */
  export type DailyStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Filter, which DailyStats to fetch.
     */
    where?: DailyStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStats to fetch.
     */
    orderBy?: DailyStatOrderByWithRelationInput | DailyStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyStats.
     */
    cursor?: DailyStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStats.
     */
    skip?: number
    distinct?: DailyStatScalarFieldEnum | DailyStatScalarFieldEnum[]
  }

  /**
   * DailyStat create
   */
  export type DailyStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * The data needed to create a DailyStat.
     */
    data: XOR<DailyStatCreateInput, DailyStatUncheckedCreateInput>
  }

  /**
   * DailyStat createMany
   */
  export type DailyStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatCreateManyInput | DailyStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyStat createManyAndReturn
   */
  export type DailyStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyStats.
     */
    data: DailyStatCreateManyInput | DailyStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyStat update
   */
  export type DailyStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * The data needed to update a DailyStat.
     */
    data: XOR<DailyStatUpdateInput, DailyStatUncheckedUpdateInput>
    /**
     * Choose, which DailyStat to update.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat updateMany
   */
  export type DailyStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyStats.
     */
    data: XOR<DailyStatUpdateManyMutationInput, DailyStatUncheckedUpdateManyInput>
    /**
     * Filter which DailyStats to update
     */
    where?: DailyStatWhereInput
  }

  /**
   * DailyStat upsert
   */
  export type DailyStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * The filter to search for the DailyStat to update in case it exists.
     */
    where: DailyStatWhereUniqueInput
    /**
     * In case the DailyStat found by the `where` argument doesn't exist, create a new DailyStat with this data.
     */
    create: XOR<DailyStatCreateInput, DailyStatUncheckedCreateInput>
    /**
     * In case the DailyStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyStatUpdateInput, DailyStatUncheckedUpdateInput>
  }

  /**
   * DailyStat delete
   */
  export type DailyStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
    /**
     * Filter which DailyStat to delete.
     */
    where: DailyStatWhereUniqueInput
  }

  /**
   * DailyStat deleteMany
   */
  export type DailyStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStats to delete
     */
    where?: DailyStatWhereInput
  }

  /**
   * DailyStat without action
   */
  export type DailyStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStat
     */
    select?: DailyStatSelect<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    totalXp: number | null
    currentLevel: number | null
    quizzesCompleted: number | null
    totalCorrect: number | null
    totalQuestions: number | null
    avgScore: number | null
    currentStreak: number | null
    longestStreak: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    totalXp: number | null
    currentLevel: number | null
    quizzesCompleted: number | null
    totalCorrect: number | null
    totalQuestions: number | null
    avgScore: number | null
    currentStreak: number | null
    longestStreak: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalXp: number | null
    currentLevel: number | null
    quizzesCompleted: number | null
    totalCorrect: number | null
    totalQuestions: number | null
    avgScore: number | null
    currentStreak: number | null
    longestStreak: number | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalXp: number | null
    currentLevel: number | null
    quizzesCompleted: number | null
    totalCorrect: number | null
    totalQuestions: number | null
    avgScore: number | null
    currentStreak: number | null
    longestStreak: number | null
    lastActiveAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    totalXp: number
    currentLevel: number
    modulesStarted: number
    modulesCompleted: number
    quizzesCompleted: number
    totalCorrect: number
    totalQuestions: number
    avgScore: number
    currentStreak: number
    longestStreak: number
    lastActiveAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    totalXp?: true
    currentLevel?: true
    quizzesCompleted?: true
    totalCorrect?: true
    totalQuestions?: true
    avgScore?: true
    currentStreak?: true
    longestStreak?: true
  }

  export type UserProgressSumAggregateInputType = {
    totalXp?: true
    currentLevel?: true
    quizzesCompleted?: true
    totalCorrect?: true
    totalQuestions?: true
    avgScore?: true
    currentStreak?: true
    longestStreak?: true
  }

  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    totalXp?: true
    currentLevel?: true
    quizzesCompleted?: true
    totalCorrect?: true
    totalQuestions?: true
    avgScore?: true
    currentStreak?: true
    longestStreak?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    totalXp?: true
    currentLevel?: true
    quizzesCompleted?: true
    totalCorrect?: true
    totalQuestions?: true
    avgScore?: true
    currentStreak?: true
    longestStreak?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    totalXp?: true
    currentLevel?: true
    modulesStarted?: true
    modulesCompleted?: true
    quizzesCompleted?: true
    totalCorrect?: true
    totalQuestions?: true
    avgScore?: true
    currentStreak?: true
    longestStreak?: true
    lastActiveAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    totalXp: number
    currentLevel: number
    modulesStarted: string[]
    modulesCompleted: string[]
    quizzesCompleted: number
    totalCorrect: number
    totalQuestions: number
    avgScore: number
    currentStreak: number
    longestStreak: number
    lastActiveAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    currentLevel?: boolean
    modulesStarted?: boolean
    modulesCompleted?: boolean
    quizzesCompleted?: boolean
    totalCorrect?: boolean
    totalQuestions?: boolean
    avgScore?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    currentLevel?: boolean
    modulesStarted?: boolean
    modulesCompleted?: boolean
    quizzesCompleted?: boolean
    totalCorrect?: boolean
    totalQuestions?: boolean
    avgScore?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    totalXp?: boolean
    currentLevel?: boolean
    modulesStarted?: boolean
    modulesCompleted?: boolean
    quizzesCompleted?: boolean
    totalCorrect?: boolean
    totalQuestions?: boolean
    avgScore?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActiveAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalXp: number
      currentLevel: number
      modulesStarted: string[]
      modulesCompleted: string[]
      quizzesCompleted: number
      totalCorrect: number
      totalQuestions: number
      avgScore: number
      currentStreak: number
      longestStreak: number
      lastActiveAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */ 
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly totalXp: FieldRef<"UserProgress", 'Int'>
    readonly currentLevel: FieldRef<"UserProgress", 'Int'>
    readonly modulesStarted: FieldRef<"UserProgress", 'String[]'>
    readonly modulesCompleted: FieldRef<"UserProgress", 'String[]'>
    readonly quizzesCompleted: FieldRef<"UserProgress", 'Int'>
    readonly totalCorrect: FieldRef<"UserProgress", 'Int'>
    readonly totalQuestions: FieldRef<"UserProgress", 'Int'>
    readonly avgScore: FieldRef<"UserProgress", 'Float'>
    readonly currentStreak: FieldRef<"UserProgress", 'Int'>
    readonly longestStreak: FieldRef<"UserProgress", 'Int'>
    readonly lastActiveAt: FieldRef<"UserProgress", 'DateTime'>
    readonly createdAt: FieldRef<"UserProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
  }


  /**
   * Model AlertRule
   */

  export type AggregateAlertRule = {
    _count: AlertRuleCountAggregateOutputType | null
    _avg: AlertRuleAvgAggregateOutputType | null
    _sum: AlertRuleSumAggregateOutputType | null
    _min: AlertRuleMinAggregateOutputType | null
    _max: AlertRuleMaxAggregateOutputType | null
  }

  export type AlertRuleAvgAggregateOutputType = {
    threshold: number | null
    duration: number | null
    cooldownMinutes: number | null
  }

  export type AlertRuleSumAggregateOutputType = {
    threshold: number | null
    duration: number | null
    cooldownMinutes: number | null
  }

  export type AlertRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    metric: string | null
    operator: string | null
    threshold: number | null
    duration: number | null
    targetType: string | null
    targetId: string | null
    severity: string | null
    cooldownMinutes: number | null
    lastTriggeredAt: Date | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    metric: string | null
    operator: string | null
    threshold: number | null
    duration: number | null
    targetType: string | null
    targetId: string | null
    severity: string | null
    cooldownMinutes: number | null
    lastTriggeredAt: Date | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    metric: number
    operator: number
    threshold: number
    duration: number
    targetType: number
    targetId: number
    severity: number
    notifyChannels: number
    notifyRoles: number
    cooldownMinutes: number
    lastTriggeredAt: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertRuleAvgAggregateInputType = {
    threshold?: true
    duration?: true
    cooldownMinutes?: true
  }

  export type AlertRuleSumAggregateInputType = {
    threshold?: true
    duration?: true
    cooldownMinutes?: true
  }

  export type AlertRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    metric?: true
    operator?: true
    threshold?: true
    duration?: true
    targetType?: true
    targetId?: true
    severity?: true
    cooldownMinutes?: true
    lastTriggeredAt?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    metric?: true
    operator?: true
    threshold?: true
    duration?: true
    targetType?: true
    targetId?: true
    severity?: true
    cooldownMinutes?: true
    lastTriggeredAt?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    metric?: true
    operator?: true
    threshold?: true
    duration?: true
    targetType?: true
    targetId?: true
    severity?: true
    notifyChannels?: true
    notifyRoles?: true
    cooldownMinutes?: true
    lastTriggeredAt?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertRule to aggregate.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AlertRules
    **/
    _count?: true | AlertRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertRuleMaxAggregateInputType
  }

  export type GetAlertRuleAggregateType<T extends AlertRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertRule[P]>
      : GetScalarType<T[P], AggregateAlertRule[P]>
  }




  export type AlertRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertRuleWhereInput
    orderBy?: AlertRuleOrderByWithAggregationInput | AlertRuleOrderByWithAggregationInput[]
    by: AlertRuleScalarFieldEnum[] | AlertRuleScalarFieldEnum
    having?: AlertRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertRuleCountAggregateInputType | true
    _avg?: AlertRuleAvgAggregateInputType
    _sum?: AlertRuleSumAggregateInputType
    _min?: AlertRuleMinAggregateInputType
    _max?: AlertRuleMaxAggregateInputType
  }

  export type AlertRuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    metric: string
    operator: string
    threshold: number
    duration: number | null
    targetType: string
    targetId: string | null
    severity: string
    notifyChannels: string[]
    notifyRoles: string[]
    cooldownMinutes: number
    lastTriggeredAt: Date | null
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: AlertRuleCountAggregateOutputType | null
    _avg: AlertRuleAvgAggregateOutputType | null
    _sum: AlertRuleSumAggregateOutputType | null
    _min: AlertRuleMinAggregateOutputType | null
    _max: AlertRuleMaxAggregateOutputType | null
  }

  type GetAlertRuleGroupByPayload<T extends AlertRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertRuleGroupByOutputType[P]>
            : GetScalarType<T[P], AlertRuleGroupByOutputType[P]>
        }
      >
    >


  export type AlertRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    metric?: boolean
    operator?: boolean
    threshold?: boolean
    duration?: boolean
    targetType?: boolean
    targetId?: boolean
    severity?: boolean
    notifyChannels?: boolean
    notifyRoles?: boolean
    cooldownMinutes?: boolean
    lastTriggeredAt?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    alerts?: boolean | AlertRule$alertsArgs<ExtArgs>
    _count?: boolean | AlertRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertRule"]>

  export type AlertRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    metric?: boolean
    operator?: boolean
    threshold?: boolean
    duration?: boolean
    targetType?: boolean
    targetId?: boolean
    severity?: boolean
    notifyChannels?: boolean
    notifyRoles?: boolean
    cooldownMinutes?: boolean
    lastTriggeredAt?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["alertRule"]>

  export type AlertRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    metric?: boolean
    operator?: boolean
    threshold?: boolean
    duration?: boolean
    targetType?: boolean
    targetId?: boolean
    severity?: boolean
    notifyChannels?: boolean
    notifyRoles?: boolean
    cooldownMinutes?: boolean
    lastTriggeredAt?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | AlertRule$alertsArgs<ExtArgs>
    _count?: boolean | AlertRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlertRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AlertRule"
    objects: {
      alerts: Prisma.$AlertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      metric: string
      operator: string
      threshold: number
      duration: number | null
      targetType: string
      targetId: string | null
      severity: string
      notifyChannels: string[]
      notifyRoles: string[]
      cooldownMinutes: number
      lastTriggeredAt: Date | null
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alertRule"]>
    composites: {}
  }

  type AlertRuleGetPayload<S extends boolean | null | undefined | AlertRuleDefaultArgs> = $Result.GetResult<Prisma.$AlertRulePayload, S>

  type AlertRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertRuleCountAggregateInputType | true
    }

  export interface AlertRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AlertRule'], meta: { name: 'AlertRule' } }
    /**
     * Find zero or one AlertRule that matches the filter.
     * @param {AlertRuleFindUniqueArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertRuleFindUniqueArgs>(args: SelectSubset<T, AlertRuleFindUniqueArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AlertRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertRuleFindUniqueOrThrowArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AlertRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindFirstArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertRuleFindFirstArgs>(args?: SelectSubset<T, AlertRuleFindFirstArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AlertRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindFirstOrThrowArgs} args - Arguments to find a AlertRule
     * @example
     * // Get one AlertRule
     * const alertRule = await prisma.alertRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AlertRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AlertRules
     * const alertRules = await prisma.alertRule.findMany()
     * 
     * // Get first 10 AlertRules
     * const alertRules = await prisma.alertRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertRuleWithIdOnly = await prisma.alertRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertRuleFindManyArgs>(args?: SelectSubset<T, AlertRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AlertRule.
     * @param {AlertRuleCreateArgs} args - Arguments to create a AlertRule.
     * @example
     * // Create one AlertRule
     * const AlertRule = await prisma.alertRule.create({
     *   data: {
     *     // ... data to create a AlertRule
     *   }
     * })
     * 
     */
    create<T extends AlertRuleCreateArgs>(args: SelectSubset<T, AlertRuleCreateArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AlertRules.
     * @param {AlertRuleCreateManyArgs} args - Arguments to create many AlertRules.
     * @example
     * // Create many AlertRules
     * const alertRule = await prisma.alertRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertRuleCreateManyArgs>(args?: SelectSubset<T, AlertRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AlertRules and returns the data saved in the database.
     * @param {AlertRuleCreateManyAndReturnArgs} args - Arguments to create many AlertRules.
     * @example
     * // Create many AlertRules
     * const alertRule = await prisma.alertRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AlertRules and only return the `id`
     * const alertRuleWithIdOnly = await prisma.alertRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AlertRule.
     * @param {AlertRuleDeleteArgs} args - Arguments to delete one AlertRule.
     * @example
     * // Delete one AlertRule
     * const AlertRule = await prisma.alertRule.delete({
     *   where: {
     *     // ... filter to delete one AlertRule
     *   }
     * })
     * 
     */
    delete<T extends AlertRuleDeleteArgs>(args: SelectSubset<T, AlertRuleDeleteArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AlertRule.
     * @param {AlertRuleUpdateArgs} args - Arguments to update one AlertRule.
     * @example
     * // Update one AlertRule
     * const alertRule = await prisma.alertRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertRuleUpdateArgs>(args: SelectSubset<T, AlertRuleUpdateArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AlertRules.
     * @param {AlertRuleDeleteManyArgs} args - Arguments to filter AlertRules to delete.
     * @example
     * // Delete a few AlertRules
     * const { count } = await prisma.alertRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertRuleDeleteManyArgs>(args?: SelectSubset<T, AlertRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AlertRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AlertRules
     * const alertRule = await prisma.alertRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertRuleUpdateManyArgs>(args: SelectSubset<T, AlertRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AlertRule.
     * @param {AlertRuleUpsertArgs} args - Arguments to update or create a AlertRule.
     * @example
     * // Update or create a AlertRule
     * const alertRule = await prisma.alertRule.upsert({
     *   create: {
     *     // ... data to create a AlertRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AlertRule we want to update
     *   }
     * })
     */
    upsert<T extends AlertRuleUpsertArgs>(args: SelectSubset<T, AlertRuleUpsertArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AlertRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleCountArgs} args - Arguments to filter AlertRules to count.
     * @example
     * // Count the number of AlertRules
     * const count = await prisma.alertRule.count({
     *   where: {
     *     // ... the filter for the AlertRules we want to count
     *   }
     * })
    **/
    count<T extends AlertRuleCountArgs>(
      args?: Subset<T, AlertRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AlertRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertRuleAggregateArgs>(args: Subset<T, AlertRuleAggregateArgs>): Prisma.PrismaPromise<GetAlertRuleAggregateType<T>>

    /**
     * Group by AlertRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertRuleGroupByArgs['orderBy'] }
        : { orderBy?: AlertRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AlertRule model
   */
  readonly fields: AlertRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AlertRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alerts<T extends AlertRule$alertsArgs<ExtArgs> = {}>(args?: Subset<T, AlertRule$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AlertRule model
   */ 
  interface AlertRuleFieldRefs {
    readonly id: FieldRef<"AlertRule", 'String'>
    readonly name: FieldRef<"AlertRule", 'String'>
    readonly description: FieldRef<"AlertRule", 'String'>
    readonly metric: FieldRef<"AlertRule", 'String'>
    readonly operator: FieldRef<"AlertRule", 'String'>
    readonly threshold: FieldRef<"AlertRule", 'Float'>
    readonly duration: FieldRef<"AlertRule", 'Int'>
    readonly targetType: FieldRef<"AlertRule", 'String'>
    readonly targetId: FieldRef<"AlertRule", 'String'>
    readonly severity: FieldRef<"AlertRule", 'String'>
    readonly notifyChannels: FieldRef<"AlertRule", 'String[]'>
    readonly notifyRoles: FieldRef<"AlertRule", 'String[]'>
    readonly cooldownMinutes: FieldRef<"AlertRule", 'Int'>
    readonly lastTriggeredAt: FieldRef<"AlertRule", 'DateTime'>
    readonly enabled: FieldRef<"AlertRule", 'Boolean'>
    readonly createdAt: FieldRef<"AlertRule", 'DateTime'>
    readonly updatedAt: FieldRef<"AlertRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AlertRule findUnique
   */
  export type AlertRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule findUniqueOrThrow
   */
  export type AlertRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule findFirst
   */
  export type AlertRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertRules.
     */
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule findFirstOrThrow
   */
  export type AlertRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRule to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AlertRules.
     */
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule findMany
   */
  export type AlertRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter, which AlertRules to fetch.
     */
    where?: AlertRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AlertRules to fetch.
     */
    orderBy?: AlertRuleOrderByWithRelationInput | AlertRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AlertRules.
     */
    cursor?: AlertRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AlertRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AlertRules.
     */
    skip?: number
    distinct?: AlertRuleScalarFieldEnum | AlertRuleScalarFieldEnum[]
  }

  /**
   * AlertRule create
   */
  export type AlertRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a AlertRule.
     */
    data: XOR<AlertRuleCreateInput, AlertRuleUncheckedCreateInput>
  }

  /**
   * AlertRule createMany
   */
  export type AlertRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AlertRules.
     */
    data: AlertRuleCreateManyInput | AlertRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertRule createManyAndReturn
   */
  export type AlertRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AlertRules.
     */
    data: AlertRuleCreateManyInput | AlertRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AlertRule update
   */
  export type AlertRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a AlertRule.
     */
    data: XOR<AlertRuleUpdateInput, AlertRuleUncheckedUpdateInput>
    /**
     * Choose, which AlertRule to update.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule updateMany
   */
  export type AlertRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AlertRules.
     */
    data: XOR<AlertRuleUpdateManyMutationInput, AlertRuleUncheckedUpdateManyInput>
    /**
     * Filter which AlertRules to update
     */
    where?: AlertRuleWhereInput
  }

  /**
   * AlertRule upsert
   */
  export type AlertRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the AlertRule to update in case it exists.
     */
    where: AlertRuleWhereUniqueInput
    /**
     * In case the AlertRule found by the `where` argument doesn't exist, create a new AlertRule with this data.
     */
    create: XOR<AlertRuleCreateInput, AlertRuleUncheckedCreateInput>
    /**
     * In case the AlertRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertRuleUpdateInput, AlertRuleUncheckedUpdateInput>
  }

  /**
   * AlertRule delete
   */
  export type AlertRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
    /**
     * Filter which AlertRule to delete.
     */
    where: AlertRuleWhereUniqueInput
  }

  /**
   * AlertRule deleteMany
   */
  export type AlertRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AlertRules to delete
     */
    where?: AlertRuleWhereInput
  }

  /**
   * AlertRule.alerts
   */
  export type AlertRule$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * AlertRule without action
   */
  export type AlertRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlertRule
     */
    select?: AlertRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertRuleInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertAvgAggregateOutputType = {
    triggerValue: number | null
    triggerThreshold: number | null
  }

  export type AlertSumAggregateOutputType = {
    triggerValue: number | null
    triggerThreshold: number | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    ruleId: string | null
    severity: string | null
    title: string | null
    description: string | null
    affectedUserId: string | null
    affectedEntityType: string | null
    affectedEntityId: string | null
    triggerMetric: string | null
    triggerValue: number | null
    triggerThreshold: number | null
    status: string | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    ruleId: string | null
    severity: string | null
    title: string | null
    description: string | null
    affectedUserId: string | null
    affectedEntityType: string | null
    affectedEntityId: string | null
    triggerMetric: string | null
    triggerValue: number | null
    triggerThreshold: number | null
    status: string | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    ruleId: number
    severity: number
    title: number
    description: number
    affectedUserId: number
    affectedEntityType: number
    affectedEntityId: number
    triggerMetric: number
    triggerValue: number
    triggerThreshold: number
    recommendedActions: number
    status: number
    acknowledgedAt: number
    acknowledgedBy: number
    resolvedAt: number
    resolvedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertAvgAggregateInputType = {
    triggerValue?: true
    triggerThreshold?: true
  }

  export type AlertSumAggregateInputType = {
    triggerValue?: true
    triggerThreshold?: true
  }

  export type AlertMinAggregateInputType = {
    id?: true
    ruleId?: true
    severity?: true
    title?: true
    description?: true
    affectedUserId?: true
    affectedEntityType?: true
    affectedEntityId?: true
    triggerMetric?: true
    triggerValue?: true
    triggerThreshold?: true
    status?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    ruleId?: true
    severity?: true
    title?: true
    description?: true
    affectedUserId?: true
    affectedEntityType?: true
    affectedEntityId?: true
    triggerMetric?: true
    triggerValue?: true
    triggerThreshold?: true
    status?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    ruleId?: true
    severity?: true
    title?: true
    description?: true
    affectedUserId?: true
    affectedEntityType?: true
    affectedEntityId?: true
    triggerMetric?: true
    triggerValue?: true
    triggerThreshold?: true
    recommendedActions?: true
    status?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    resolvedAt?: true
    resolvedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _avg?: AlertAvgAggregateInputType
    _sum?: AlertSumAggregateInputType
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    ruleId: string
    severity: string
    title: string
    description: string | null
    affectedUserId: string | null
    affectedEntityType: string | null
    affectedEntityId: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions: string[]
    status: string
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AlertCountAggregateOutputType | null
    _avg: AlertAvgAggregateOutputType | null
    _sum: AlertSumAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    affectedUserId?: boolean
    affectedEntityType?: boolean
    affectedEntityId?: boolean
    triggerMetric?: boolean
    triggerValue?: boolean
    triggerThreshold?: boolean
    recommendedActions?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
    notifications?: boolean | Alert$notificationsArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ruleId?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    affectedUserId?: boolean
    affectedEntityType?: boolean
    affectedEntityId?: boolean
    triggerMetric?: boolean
    triggerValue?: boolean
    triggerThreshold?: boolean
    recommendedActions?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    ruleId?: boolean
    severity?: boolean
    title?: boolean
    description?: boolean
    affectedUserId?: boolean
    affectedEntityType?: boolean
    affectedEntityId?: boolean
    triggerMetric?: boolean
    triggerValue?: boolean
    triggerThreshold?: boolean
    recommendedActions?: boolean
    status?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
    notifications?: boolean | Alert$notificationsArgs<ExtArgs>
    _count?: boolean | AlertCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | AlertRuleDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      rule: Prisma.$AlertRulePayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ruleId: string
      severity: string
      title: string
      description: string | null
      affectedUserId: string | null
      affectedEntityType: string | null
      affectedEntityId: string | null
      triggerMetric: string
      triggerValue: number
      triggerThreshold: number
      recommendedActions: string[]
      status: string
      acknowledgedAt: Date | null
      acknowledgedBy: string | null
      resolvedAt: Date | null
      resolvedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule<T extends AlertRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AlertRuleDefaultArgs<ExtArgs>>): Prisma__AlertRuleClient<$Result.GetResult<Prisma.$AlertRulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    notifications<T extends Alert$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Alert$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly ruleId: FieldRef<"Alert", 'String'>
    readonly severity: FieldRef<"Alert", 'String'>
    readonly title: FieldRef<"Alert", 'String'>
    readonly description: FieldRef<"Alert", 'String'>
    readonly affectedUserId: FieldRef<"Alert", 'String'>
    readonly affectedEntityType: FieldRef<"Alert", 'String'>
    readonly affectedEntityId: FieldRef<"Alert", 'String'>
    readonly triggerMetric: FieldRef<"Alert", 'String'>
    readonly triggerValue: FieldRef<"Alert", 'Float'>
    readonly triggerThreshold: FieldRef<"Alert", 'Float'>
    readonly recommendedActions: FieldRef<"Alert", 'String[]'>
    readonly status: FieldRef<"Alert", 'String'>
    readonly acknowledgedAt: FieldRef<"Alert", 'DateTime'>
    readonly acknowledgedBy: FieldRef<"Alert", 'String'>
    readonly resolvedAt: FieldRef<"Alert", 'DateTime'>
    readonly resolvedBy: FieldRef<"Alert", 'String'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert.notifications
   */
  export type Alert$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    icon: string | null
    alertId: string | null
    read: boolean | null
    readAt: Date | null
    emailSent: boolean | null
    emailSentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    message: string | null
    link: string | null
    icon: string | null
    alertId: string | null
    read: boolean | null
    readAt: Date | null
    emailSent: boolean | null
    emailSentAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    link: number
    icon: number
    alertId: number
    read: number
    readAt: number
    emailSent: number
    emailSentAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    icon?: true
    alertId?: true
    read?: true
    readAt?: true
    emailSent?: true
    emailSentAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    icon?: true
    alertId?: true
    read?: true
    readAt?: true
    emailSent?: true
    emailSentAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    link?: true
    icon?: true
    alertId?: true
    read?: true
    readAt?: true
    emailSent?: true
    emailSentAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    message: string
    link: string | null
    icon: string | null
    alertId: string | null
    read: boolean
    readAt: Date | null
    emailSent: boolean
    emailSentAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    icon?: boolean
    alertId?: boolean
    read?: boolean
    readAt?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    createdAt?: boolean
    alert?: boolean | Notification$alertArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    icon?: boolean
    alertId?: boolean
    read?: boolean
    readAt?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    createdAt?: boolean
    alert?: boolean | Notification$alertArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    link?: boolean
    icon?: boolean
    alertId?: boolean
    read?: boolean
    readAt?: boolean
    emailSent?: boolean
    emailSentAt?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | Notification$alertArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | Notification$alertArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      alert: Prisma.$AlertPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      message: string
      link: string | null
      icon: string | null
      alertId: string | null
      read: boolean
      readAt: Date | null
      emailSent: boolean
      emailSentAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alert<T extends Notification$alertArgs<ExtArgs> = {}>(args?: Subset<T, Notification$alertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly icon: FieldRef<"Notification", 'String'>
    readonly alertId: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly emailSent: FieldRef<"Notification", 'Boolean'>
    readonly emailSentAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.alert
   */
  export type Notification$alertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ReportTemplate
   */

  export type AggregateReportTemplate = {
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  export type ReportTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    format: string | null
    scheduleEnabled: boolean | null
    scheduleCron: string | null
    isSystem: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    format: string | null
    scheduleEnabled: boolean | null
    scheduleCron: string | null
    isSystem: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    format: number
    config: number
    scheduleEnabled: number
    scheduleCron: number
    recipients: number
    isSystem: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    format?: true
    scheduleEnabled?: true
    scheduleCron?: true
    isSystem?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    format?: true
    scheduleEnabled?: true
    scheduleCron?: true
    isSystem?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    format?: true
    config?: true
    scheduleEnabled?: true
    scheduleCron?: true
    recipients?: true
    isSystem?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplate to aggregate.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportTemplates
    **/
    _count?: true | ReportTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type GetReportTemplateAggregateType<T extends ReportTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateReportTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportTemplate[P]>
      : GetScalarType<T[P], AggregateReportTemplate[P]>
  }




  export type ReportTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithAggregationInput | ReportTemplateOrderByWithAggregationInput[]
    by: ReportTemplateScalarFieldEnum[] | ReportTemplateScalarFieldEnum
    having?: ReportTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportTemplateCountAggregateInputType | true
    _min?: ReportTemplateMinAggregateInputType
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type ReportTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: string
    format: string
    config: JsonValue | null
    scheduleEnabled: boolean
    scheduleCron: string | null
    recipients: string[]
    isSystem: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  type GetReportTemplateGroupByPayload<T extends ReportTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ReportTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    format?: boolean
    config?: boolean
    scheduleEnabled?: boolean
    scheduleCron?: boolean
    recipients?: boolean
    isSystem?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reports?: boolean | ReportTemplate$reportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    format?: boolean
    config?: boolean
    scheduleEnabled?: boolean
    scheduleCron?: boolean
    recipients?: boolean
    isSystem?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    format?: boolean
    config?: boolean
    scheduleEnabled?: boolean
    scheduleCron?: boolean
    recipients?: boolean
    isSystem?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ReportTemplate$reportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReportTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportTemplate"
    objects: {
      reports: Prisma.$GeneratedReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: string
      format: string
      config: Prisma.JsonValue | null
      scheduleEnabled: boolean
      scheduleCron: string | null
      recipients: string[]
      isSystem: boolean
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportTemplate"]>
    composites: {}
  }

  type ReportTemplateGetPayload<S extends boolean | null | undefined | ReportTemplateDefaultArgs> = $Result.GetResult<Prisma.$ReportTemplatePayload, S>

  type ReportTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportTemplateCountAggregateInputType | true
    }

  export interface ReportTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportTemplate'], meta: { name: 'ReportTemplate' } }
    /**
     * Find zero or one ReportTemplate that matches the filter.
     * @param {ReportTemplateFindUniqueArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportTemplateFindUniqueArgs>(args: SelectSubset<T, ReportTemplateFindUniqueArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportTemplateFindUniqueOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportTemplateFindFirstArgs>(args?: SelectSubset<T, ReportTemplateFindFirstArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany()
     * 
     * // Get first 10 ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportTemplateFindManyArgs>(args?: SelectSubset<T, ReportTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportTemplate.
     * @param {ReportTemplateCreateArgs} args - Arguments to create a ReportTemplate.
     * @example
     * // Create one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.create({
     *   data: {
     *     // ... data to create a ReportTemplate
     *   }
     * })
     * 
     */
    create<T extends ReportTemplateCreateArgs>(args: SelectSubset<T, ReportTemplateCreateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportTemplates.
     * @param {ReportTemplateCreateManyArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportTemplateCreateManyArgs>(args?: SelectSubset<T, ReportTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportTemplates and returns the data saved in the database.
     * @param {ReportTemplateCreateManyAndReturnArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportTemplate.
     * @param {ReportTemplateDeleteArgs} args - Arguments to delete one ReportTemplate.
     * @example
     * // Delete one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.delete({
     *   where: {
     *     // ... filter to delete one ReportTemplate
     *   }
     * })
     * 
     */
    delete<T extends ReportTemplateDeleteArgs>(args: SelectSubset<T, ReportTemplateDeleteArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportTemplate.
     * @param {ReportTemplateUpdateArgs} args - Arguments to update one ReportTemplate.
     * @example
     * // Update one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportTemplateUpdateArgs>(args: SelectSubset<T, ReportTemplateUpdateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportTemplates.
     * @param {ReportTemplateDeleteManyArgs} args - Arguments to filter ReportTemplates to delete.
     * @example
     * // Delete a few ReportTemplates
     * const { count } = await prisma.reportTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportTemplateDeleteManyArgs>(args?: SelectSubset<T, ReportTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportTemplateUpdateManyArgs>(args: SelectSubset<T, ReportTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportTemplate.
     * @param {ReportTemplateUpsertArgs} args - Arguments to update or create a ReportTemplate.
     * @example
     * // Update or create a ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.upsert({
     *   create: {
     *     // ... data to create a ReportTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ReportTemplateUpsertArgs>(args: SelectSubset<T, ReportTemplateUpsertArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateCountArgs} args - Arguments to filter ReportTemplates to count.
     * @example
     * // Count the number of ReportTemplates
     * const count = await prisma.reportTemplate.count({
     *   where: {
     *     // ... the filter for the ReportTemplates we want to count
     *   }
     * })
    **/
    count<T extends ReportTemplateCountArgs>(
      args?: Subset<T, ReportTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportTemplateAggregateArgs>(args: Subset<T, ReportTemplateAggregateArgs>): Prisma.PrismaPromise<GetReportTemplateAggregateType<T>>

    /**
     * Group by ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ReportTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportTemplate model
   */
  readonly fields: ReportTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends ReportTemplate$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportTemplate model
   */ 
  interface ReportTemplateFieldRefs {
    readonly id: FieldRef<"ReportTemplate", 'String'>
    readonly name: FieldRef<"ReportTemplate", 'String'>
    readonly description: FieldRef<"ReportTemplate", 'String'>
    readonly type: FieldRef<"ReportTemplate", 'String'>
    readonly format: FieldRef<"ReportTemplate", 'String'>
    readonly config: FieldRef<"ReportTemplate", 'Json'>
    readonly scheduleEnabled: FieldRef<"ReportTemplate", 'Boolean'>
    readonly scheduleCron: FieldRef<"ReportTemplate", 'String'>
    readonly recipients: FieldRef<"ReportTemplate", 'String[]'>
    readonly isSystem: FieldRef<"ReportTemplate", 'Boolean'>
    readonly createdBy: FieldRef<"ReportTemplate", 'String'>
    readonly createdAt: FieldRef<"ReportTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportTemplate findUnique
   */
  export type ReportTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findUniqueOrThrow
   */
  export type ReportTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findFirst
   */
  export type ReportTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findFirstOrThrow
   */
  export type ReportTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findMany
   */
  export type ReportTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplates to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate create
   */
  export type ReportTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportTemplate.
     */
    data: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
  }

  /**
   * ReportTemplate createMany
   */
  export type ReportTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate createManyAndReturn
   */
  export type ReportTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate update
   */
  export type ReportTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportTemplate.
     */
    data: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
    /**
     * Choose, which ReportTemplate to update.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate updateMany
   */
  export type ReportTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
  }

  /**
   * ReportTemplate upsert
   */
  export type ReportTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportTemplate to update in case it exists.
     */
    where: ReportTemplateWhereUniqueInput
    /**
     * In case the ReportTemplate found by the `where` argument doesn't exist, create a new ReportTemplate with this data.
     */
    create: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
    /**
     * In case the ReportTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
  }

  /**
   * ReportTemplate delete
   */
  export type ReportTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter which ReportTemplate to delete.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate deleteMany
   */
  export type ReportTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplates to delete
     */
    where?: ReportTemplateWhereInput
  }

  /**
   * ReportTemplate.reports
   */
  export type ReportTemplate$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    where?: GeneratedReportWhereInput
    orderBy?: GeneratedReportOrderByWithRelationInput | GeneratedReportOrderByWithRelationInput[]
    cursor?: GeneratedReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedReportScalarFieldEnum | GeneratedReportScalarFieldEnum[]
  }

  /**
   * ReportTemplate without action
   */
  export type ReportTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedReport
   */

  export type AggregateGeneratedReport = {
    _count: GeneratedReportCountAggregateOutputType | null
    _avg: GeneratedReportAvgAggregateOutputType | null
    _sum: GeneratedReportSumAggregateOutputType | null
    _min: GeneratedReportMinAggregateOutputType | null
    _max: GeneratedReportMaxAggregateOutputType | null
  }

  export type GeneratedReportAvgAggregateOutputType = {
    fileSize: number | null
    downloadCount: number | null
  }

  export type GeneratedReportSumAggregateOutputType = {
    fileSize: number | null
    downloadCount: number | null
  }

  export type GeneratedReportMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    name: string | null
    type: string | null
    format: string | null
    periodStart: Date | null
    periodEnd: Date | null
    requestedBy: string | null
    generatedAt: Date | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    status: string | null
    errorMessage: string | null
    emailed: boolean | null
    emailedAt: Date | null
    downloadCount: number | null
    createdAt: Date | null
  }

  export type GeneratedReportMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    name: string | null
    type: string | null
    format: string | null
    periodStart: Date | null
    periodEnd: Date | null
    requestedBy: string | null
    generatedAt: Date | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    status: string | null
    errorMessage: string | null
    emailed: boolean | null
    emailedAt: Date | null
    downloadCount: number | null
    createdAt: Date | null
  }

  export type GeneratedReportCountAggregateOutputType = {
    id: number
    templateId: number
    name: number
    type: number
    format: number
    periodStart: number
    periodEnd: number
    requestedBy: number
    generatedAt: number
    filePath: number
    fileSize: number
    mimeType: number
    status: number
    errorMessage: number
    emailed: number
    emailedAt: number
    downloadCount: number
    createdAt: number
    _all: number
  }


  export type GeneratedReportAvgAggregateInputType = {
    fileSize?: true
    downloadCount?: true
  }

  export type GeneratedReportSumAggregateInputType = {
    fileSize?: true
    downloadCount?: true
  }

  export type GeneratedReportMinAggregateInputType = {
    id?: true
    templateId?: true
    name?: true
    type?: true
    format?: true
    periodStart?: true
    periodEnd?: true
    requestedBy?: true
    generatedAt?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    status?: true
    errorMessage?: true
    emailed?: true
    emailedAt?: true
    downloadCount?: true
    createdAt?: true
  }

  export type GeneratedReportMaxAggregateInputType = {
    id?: true
    templateId?: true
    name?: true
    type?: true
    format?: true
    periodStart?: true
    periodEnd?: true
    requestedBy?: true
    generatedAt?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    status?: true
    errorMessage?: true
    emailed?: true
    emailedAt?: true
    downloadCount?: true
    createdAt?: true
  }

  export type GeneratedReportCountAggregateInputType = {
    id?: true
    templateId?: true
    name?: true
    type?: true
    format?: true
    periodStart?: true
    periodEnd?: true
    requestedBy?: true
    generatedAt?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    status?: true
    errorMessage?: true
    emailed?: true
    emailedAt?: true
    downloadCount?: true
    createdAt?: true
    _all?: true
  }

  export type GeneratedReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedReport to aggregate.
     */
    where?: GeneratedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedReports to fetch.
     */
    orderBy?: GeneratedReportOrderByWithRelationInput | GeneratedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedReports
    **/
    _count?: true | GeneratedReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneratedReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneratedReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedReportMaxAggregateInputType
  }

  export type GetGeneratedReportAggregateType<T extends GeneratedReportAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedReport[P]>
      : GetScalarType<T[P], AggregateGeneratedReport[P]>
  }




  export type GeneratedReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedReportWhereInput
    orderBy?: GeneratedReportOrderByWithAggregationInput | GeneratedReportOrderByWithAggregationInput[]
    by: GeneratedReportScalarFieldEnum[] | GeneratedReportScalarFieldEnum
    having?: GeneratedReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedReportCountAggregateInputType | true
    _avg?: GeneratedReportAvgAggregateInputType
    _sum?: GeneratedReportSumAggregateInputType
    _min?: GeneratedReportMinAggregateInputType
    _max?: GeneratedReportMaxAggregateInputType
  }

  export type GeneratedReportGroupByOutputType = {
    id: string
    templateId: string | null
    name: string
    type: string
    format: string
    periodStart: Date
    periodEnd: Date
    requestedBy: string | null
    generatedAt: Date
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    status: string
    errorMessage: string | null
    emailed: boolean
    emailedAt: Date | null
    downloadCount: number
    createdAt: Date
    _count: GeneratedReportCountAggregateOutputType | null
    _avg: GeneratedReportAvgAggregateOutputType | null
    _sum: GeneratedReportSumAggregateOutputType | null
    _min: GeneratedReportMinAggregateOutputType | null
    _max: GeneratedReportMaxAggregateOutputType | null
  }

  type GetGeneratedReportGroupByPayload<T extends GeneratedReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedReportGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedReportGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    requestedBy?: boolean
    generatedAt?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    status?: boolean
    errorMessage?: boolean
    emailed?: boolean
    emailedAt?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    template?: boolean | GeneratedReport$templateArgs<ExtArgs>
  }, ExtArgs["result"]["generatedReport"]>

  export type GeneratedReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    requestedBy?: boolean
    generatedAt?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    status?: boolean
    errorMessage?: boolean
    emailed?: boolean
    emailedAt?: boolean
    downloadCount?: boolean
    createdAt?: boolean
    template?: boolean | GeneratedReport$templateArgs<ExtArgs>
  }, ExtArgs["result"]["generatedReport"]>

  export type GeneratedReportSelectScalar = {
    id?: boolean
    templateId?: boolean
    name?: boolean
    type?: boolean
    format?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    requestedBy?: boolean
    generatedAt?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    status?: boolean
    errorMessage?: boolean
    emailed?: boolean
    emailedAt?: boolean
    downloadCount?: boolean
    createdAt?: boolean
  }

  export type GeneratedReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | GeneratedReport$templateArgs<ExtArgs>
  }
  export type GeneratedReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | GeneratedReport$templateArgs<ExtArgs>
  }

  export type $GeneratedReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedReport"
    objects: {
      template: Prisma.$ReportTemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateId: string | null
      name: string
      type: string
      format: string
      periodStart: Date
      periodEnd: Date
      requestedBy: string | null
      generatedAt: Date
      filePath: string | null
      fileSize: number | null
      mimeType: string | null
      status: string
      errorMessage: string | null
      emailed: boolean
      emailedAt: Date | null
      downloadCount: number
      createdAt: Date
    }, ExtArgs["result"]["generatedReport"]>
    composites: {}
  }

  type GeneratedReportGetPayload<S extends boolean | null | undefined | GeneratedReportDefaultArgs> = $Result.GetResult<Prisma.$GeneratedReportPayload, S>

  type GeneratedReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GeneratedReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GeneratedReportCountAggregateInputType | true
    }

  export interface GeneratedReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedReport'], meta: { name: 'GeneratedReport' } }
    /**
     * Find zero or one GeneratedReport that matches the filter.
     * @param {GeneratedReportFindUniqueArgs} args - Arguments to find a GeneratedReport
     * @example
     * // Get one GeneratedReport
     * const generatedReport = await prisma.generatedReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedReportFindUniqueArgs>(args: SelectSubset<T, GeneratedReportFindUniqueArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GeneratedReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GeneratedReportFindUniqueOrThrowArgs} args - Arguments to find a GeneratedReport
     * @example
     * // Get one GeneratedReport
     * const generatedReport = await prisma.generatedReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedReportFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GeneratedReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportFindFirstArgs} args - Arguments to find a GeneratedReport
     * @example
     * // Get one GeneratedReport
     * const generatedReport = await prisma.generatedReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedReportFindFirstArgs>(args?: SelectSubset<T, GeneratedReportFindFirstArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GeneratedReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportFindFirstOrThrowArgs} args - Arguments to find a GeneratedReport
     * @example
     * // Get one GeneratedReport
     * const generatedReport = await prisma.generatedReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedReportFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GeneratedReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedReports
     * const generatedReports = await prisma.generatedReport.findMany()
     * 
     * // Get first 10 GeneratedReports
     * const generatedReports = await prisma.generatedReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedReportWithIdOnly = await prisma.generatedReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedReportFindManyArgs>(args?: SelectSubset<T, GeneratedReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GeneratedReport.
     * @param {GeneratedReportCreateArgs} args - Arguments to create a GeneratedReport.
     * @example
     * // Create one GeneratedReport
     * const GeneratedReport = await prisma.generatedReport.create({
     *   data: {
     *     // ... data to create a GeneratedReport
     *   }
     * })
     * 
     */
    create<T extends GeneratedReportCreateArgs>(args: SelectSubset<T, GeneratedReportCreateArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GeneratedReports.
     * @param {GeneratedReportCreateManyArgs} args - Arguments to create many GeneratedReports.
     * @example
     * // Create many GeneratedReports
     * const generatedReport = await prisma.generatedReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedReportCreateManyArgs>(args?: SelectSubset<T, GeneratedReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedReports and returns the data saved in the database.
     * @param {GeneratedReportCreateManyAndReturnArgs} args - Arguments to create many GeneratedReports.
     * @example
     * // Create many GeneratedReports
     * const generatedReport = await prisma.generatedReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedReports and only return the `id`
     * const generatedReportWithIdOnly = await prisma.generatedReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedReportCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GeneratedReport.
     * @param {GeneratedReportDeleteArgs} args - Arguments to delete one GeneratedReport.
     * @example
     * // Delete one GeneratedReport
     * const GeneratedReport = await prisma.generatedReport.delete({
     *   where: {
     *     // ... filter to delete one GeneratedReport
     *   }
     * })
     * 
     */
    delete<T extends GeneratedReportDeleteArgs>(args: SelectSubset<T, GeneratedReportDeleteArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GeneratedReport.
     * @param {GeneratedReportUpdateArgs} args - Arguments to update one GeneratedReport.
     * @example
     * // Update one GeneratedReport
     * const generatedReport = await prisma.generatedReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedReportUpdateArgs>(args: SelectSubset<T, GeneratedReportUpdateArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GeneratedReports.
     * @param {GeneratedReportDeleteManyArgs} args - Arguments to filter GeneratedReports to delete.
     * @example
     * // Delete a few GeneratedReports
     * const { count } = await prisma.generatedReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedReportDeleteManyArgs>(args?: SelectSubset<T, GeneratedReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedReports
     * const generatedReport = await prisma.generatedReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedReportUpdateManyArgs>(args: SelectSubset<T, GeneratedReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GeneratedReport.
     * @param {GeneratedReportUpsertArgs} args - Arguments to update or create a GeneratedReport.
     * @example
     * // Update or create a GeneratedReport
     * const generatedReport = await prisma.generatedReport.upsert({
     *   create: {
     *     // ... data to create a GeneratedReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedReport we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedReportUpsertArgs>(args: SelectSubset<T, GeneratedReportUpsertArgs<ExtArgs>>): Prisma__GeneratedReportClient<$Result.GetResult<Prisma.$GeneratedReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GeneratedReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportCountArgs} args - Arguments to filter GeneratedReports to count.
     * @example
     * // Count the number of GeneratedReports
     * const count = await prisma.generatedReport.count({
     *   where: {
     *     // ... the filter for the GeneratedReports we want to count
     *   }
     * })
    **/
    count<T extends GeneratedReportCountArgs>(
      args?: Subset<T, GeneratedReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedReportAggregateArgs>(args: Subset<T, GeneratedReportAggregateArgs>): Prisma.PrismaPromise<GetGeneratedReportAggregateType<T>>

    /**
     * Group by GeneratedReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedReportGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedReport model
   */
  readonly fields: GeneratedReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends GeneratedReport$templateArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedReport$templateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedReport model
   */ 
  interface GeneratedReportFieldRefs {
    readonly id: FieldRef<"GeneratedReport", 'String'>
    readonly templateId: FieldRef<"GeneratedReport", 'String'>
    readonly name: FieldRef<"GeneratedReport", 'String'>
    readonly type: FieldRef<"GeneratedReport", 'String'>
    readonly format: FieldRef<"GeneratedReport", 'String'>
    readonly periodStart: FieldRef<"GeneratedReport", 'DateTime'>
    readonly periodEnd: FieldRef<"GeneratedReport", 'DateTime'>
    readonly requestedBy: FieldRef<"GeneratedReport", 'String'>
    readonly generatedAt: FieldRef<"GeneratedReport", 'DateTime'>
    readonly filePath: FieldRef<"GeneratedReport", 'String'>
    readonly fileSize: FieldRef<"GeneratedReport", 'Int'>
    readonly mimeType: FieldRef<"GeneratedReport", 'String'>
    readonly status: FieldRef<"GeneratedReport", 'String'>
    readonly errorMessage: FieldRef<"GeneratedReport", 'String'>
    readonly emailed: FieldRef<"GeneratedReport", 'Boolean'>
    readonly emailedAt: FieldRef<"GeneratedReport", 'DateTime'>
    readonly downloadCount: FieldRef<"GeneratedReport", 'Int'>
    readonly createdAt: FieldRef<"GeneratedReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedReport findUnique
   */
  export type GeneratedReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedReport to fetch.
     */
    where: GeneratedReportWhereUniqueInput
  }

  /**
   * GeneratedReport findUniqueOrThrow
   */
  export type GeneratedReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedReport to fetch.
     */
    where: GeneratedReportWhereUniqueInput
  }

  /**
   * GeneratedReport findFirst
   */
  export type GeneratedReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedReport to fetch.
     */
    where?: GeneratedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedReports to fetch.
     */
    orderBy?: GeneratedReportOrderByWithRelationInput | GeneratedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedReports.
     */
    cursor?: GeneratedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedReports.
     */
    distinct?: GeneratedReportScalarFieldEnum | GeneratedReportScalarFieldEnum[]
  }

  /**
   * GeneratedReport findFirstOrThrow
   */
  export type GeneratedReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedReport to fetch.
     */
    where?: GeneratedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedReports to fetch.
     */
    orderBy?: GeneratedReportOrderByWithRelationInput | GeneratedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedReports.
     */
    cursor?: GeneratedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedReports.
     */
    distinct?: GeneratedReportScalarFieldEnum | GeneratedReportScalarFieldEnum[]
  }

  /**
   * GeneratedReport findMany
   */
  export type GeneratedReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedReports to fetch.
     */
    where?: GeneratedReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedReports to fetch.
     */
    orderBy?: GeneratedReportOrderByWithRelationInput | GeneratedReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedReports.
     */
    cursor?: GeneratedReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedReports.
     */
    skip?: number
    distinct?: GeneratedReportScalarFieldEnum | GeneratedReportScalarFieldEnum[]
  }

  /**
   * GeneratedReport create
   */
  export type GeneratedReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedReport.
     */
    data: XOR<GeneratedReportCreateInput, GeneratedReportUncheckedCreateInput>
  }

  /**
   * GeneratedReport createMany
   */
  export type GeneratedReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedReports.
     */
    data: GeneratedReportCreateManyInput | GeneratedReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedReport createManyAndReturn
   */
  export type GeneratedReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GeneratedReports.
     */
    data: GeneratedReportCreateManyInput | GeneratedReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedReport update
   */
  export type GeneratedReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedReport.
     */
    data: XOR<GeneratedReportUpdateInput, GeneratedReportUncheckedUpdateInput>
    /**
     * Choose, which GeneratedReport to update.
     */
    where: GeneratedReportWhereUniqueInput
  }

  /**
   * GeneratedReport updateMany
   */
  export type GeneratedReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedReports.
     */
    data: XOR<GeneratedReportUpdateManyMutationInput, GeneratedReportUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedReports to update
     */
    where?: GeneratedReportWhereInput
  }

  /**
   * GeneratedReport upsert
   */
  export type GeneratedReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedReport to update in case it exists.
     */
    where: GeneratedReportWhereUniqueInput
    /**
     * In case the GeneratedReport found by the `where` argument doesn't exist, create a new GeneratedReport with this data.
     */
    create: XOR<GeneratedReportCreateInput, GeneratedReportUncheckedCreateInput>
    /**
     * In case the GeneratedReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedReportUpdateInput, GeneratedReportUncheckedUpdateInput>
  }

  /**
   * GeneratedReport delete
   */
  export type GeneratedReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
    /**
     * Filter which GeneratedReport to delete.
     */
    where: GeneratedReportWhereUniqueInput
  }

  /**
   * GeneratedReport deleteMany
   */
  export type GeneratedReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedReports to delete
     */
    where?: GeneratedReportWhereInput
  }

  /**
   * GeneratedReport.template
   */
  export type GeneratedReport$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
  }

  /**
   * GeneratedReport without action
   */
  export type GeneratedReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedReport
     */
    select?: GeneratedReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedReportInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    employeeCount: number | null
    planSeats: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    employeeCount: number | null
    planSeats: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    industry: string | null
    employeeCount: number | null
    logo: string | null
    primaryColor: string | null
    secondaryColor: string | null
    timezone: string | null
    language: string | null
    plan: string | null
    planSeats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    industry: string | null
    employeeCount: number | null
    logo: string | null
    primaryColor: string | null
    secondaryColor: string | null
    timezone: string | null
    language: string | null
    plan: string | null
    planSeats: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    industry: number
    employeeCount: number
    logo: number
    primaryColor: number
    secondaryColor: number
    timezone: number
    language: number
    plan: number
    planSeats: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    employeeCount?: true
    planSeats?: true
  }

  export type OrganizationSumAggregateInputType = {
    employeeCount?: true
    planSeats?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industry?: true
    employeeCount?: true
    logo?: true
    primaryColor?: true
    secondaryColor?: true
    timezone?: true
    language?: true
    plan?: true
    planSeats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industry?: true
    employeeCount?: true
    logo?: true
    primaryColor?: true
    secondaryColor?: true
    timezone?: true
    language?: true
    plan?: true
    planSeats?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    industry?: true
    employeeCount?: true
    logo?: true
    primaryColor?: true
    secondaryColor?: true
    timezone?: true
    language?: true
    plan?: true
    planSeats?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    industry: string | null
    employeeCount: number | null
    logo: string | null
    primaryColor: string | null
    secondaryColor: string | null
    timezone: string
    language: string
    plan: string
    planSeats: number
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industry?: boolean
    employeeCount?: boolean
    logo?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    timezone?: boolean
    language?: boolean
    plan?: boolean
    planSeats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    departments?: boolean | Organization$departmentsArgs<ExtArgs>
    users?: boolean | Organization$usersArgs<ExtArgs>
    modules?: boolean | Organization$modulesArgs<ExtArgs>
    assessmentTemplates?: boolean | Organization$assessmentTemplatesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    industry?: boolean
    employeeCount?: boolean
    logo?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    timezone?: boolean
    language?: boolean
    plan?: boolean
    planSeats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    industry?: boolean
    employeeCount?: boolean
    logo?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    timezone?: boolean
    language?: boolean
    plan?: boolean
    planSeats?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | Organization$departmentsArgs<ExtArgs>
    users?: boolean | Organization$usersArgs<ExtArgs>
    modules?: boolean | Organization$modulesArgs<ExtArgs>
    assessmentTemplates?: boolean | Organization$assessmentTemplatesArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      assessmentTemplates: Prisma.$AssessmentTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      industry: string | null
      employeeCount: number | null
      logo: string | null
      primaryColor: string | null
      secondaryColor: string | null
      timezone: string
      language: string
      plan: string
      planSeats: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    departments<T extends Organization$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends Organization$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany"> | Null>
    assessmentTemplates<T extends Organization$assessmentTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$assessmentTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly industry: FieldRef<"Organization", 'String'>
    readonly employeeCount: FieldRef<"Organization", 'Int'>
    readonly logo: FieldRef<"Organization", 'String'>
    readonly primaryColor: FieldRef<"Organization", 'String'>
    readonly secondaryColor: FieldRef<"Organization", 'String'>
    readonly timezone: FieldRef<"Organization", 'String'>
    readonly language: FieldRef<"Organization", 'String'>
    readonly plan: FieldRef<"Organization", 'String'>
    readonly planSeats: FieldRef<"Organization", 'Int'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }

  /**
   * Organization.departments
   */
  export type Organization$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.modules
   */
  export type Organization$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Organization.assessmentTemplates
   */
  export type Organization$assessmentTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    where?: AssessmentTemplateWhereInput
    orderBy?: AssessmentTemplateOrderByWithRelationInput | AssessmentTemplateOrderByWithRelationInput[]
    cursor?: AssessmentTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentTemplateScalarFieldEnum | AssessmentTemplateScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    description: number
    managerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    organizationId: string
    name: string
    description: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
    members?: boolean | Department$membersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
    members?: boolean | Department$membersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      name: string
      description: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    manager<T extends Department$managerArgs<ExtArgs> = {}>(args?: Subset<T, Department$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    members<T extends Department$membersArgs<ExtArgs> = {}>(args?: Subset<T, Department$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly organizationId: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly managerId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.manager
   */
  export type Department$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Department.members
   */
  export type Department$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    organizationId: string | null
    departmentId: string | null
    role: string | null
    status: string | null
    position: string | null
    companyName: string | null
    companySize: string | null
    industrySector: string | null
    targetStandard: string | null
    subscriptionStatus: string | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    lastLoginAt: Date | null
    invitedAt: Date | null
    invitedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    organizationId: string | null
    departmentId: string | null
    role: string | null
    status: string | null
    position: string | null
    companyName: string | null
    companySize: string | null
    industrySector: string | null
    targetStandard: string | null
    subscriptionStatus: string | null
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    lastLoginAt: Date | null
    invitedAt: Date | null
    invitedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    organizationId: number
    departmentId: number
    role: number
    status: number
    position: number
    companyName: number
    companySize: number
    industrySector: number
    targetStandard: number
    subscriptionStatus: number
    subscriptionStartDate: number
    subscriptionEndDate: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    onboardingCompletedSteps: number
    lastLoginAt: number
    invitedAt: number
    invitedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    organizationId?: true
    departmentId?: true
    role?: true
    status?: true
    position?: true
    companyName?: true
    companySize?: true
    industrySector?: true
    targetStandard?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    lastLoginAt?: true
    invitedAt?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    organizationId?: true
    departmentId?: true
    role?: true
    status?: true
    position?: true
    companyName?: true
    companySize?: true
    industrySector?: true
    targetStandard?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    lastLoginAt?: true
    invitedAt?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    organizationId?: true
    departmentId?: true
    role?: true
    status?: true
    position?: true
    companyName?: true
    companySize?: true
    industrySector?: true
    targetStandard?: true
    subscriptionStatus?: true
    subscriptionStartDate?: true
    subscriptionEndDate?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    onboardingCompletedSteps?: true
    lastLoginAt?: true
    invitedAt?: true
    invitedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    avatar: string | null
    organizationId: string | null
    departmentId: string | null
    role: string
    status: string
    position: string | null
    companyName: string | null
    companySize: string | null
    industrySector: string | null
    targetStandard: string | null
    subscriptionStatus: string
    subscriptionStartDate: Date | null
    subscriptionEndDate: Date | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    onboardingCompletedSteps: string[]
    lastLoginAt: Date | null
    invitedAt: Date | null
    invitedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    organizationId?: boolean
    departmentId?: boolean
    role?: boolean
    status?: boolean
    position?: boolean
    companyName?: boolean
    companySize?: boolean
    industrySector?: boolean
    targetStandard?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    onboardingCompletedSteps?: boolean
    lastLoginAt?: boolean
    invitedAt?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    managerNotes?: boolean | User$managerNotesArgs<ExtArgs>
    notesWritten?: boolean | User$notesWrittenArgs<ExtArgs>
    managedDepartments?: boolean | User$managedDepartmentsArgs<ExtArgs>
    assignmentsReceived?: boolean | User$assignmentsReceivedArgs<ExtArgs>
    assignmentsMade?: boolean | User$assignmentsMadeArgs<ExtArgs>
    moduleProgress?: boolean | User$moduleProgressArgs<ExtArgs>
    assessmentSessions?: boolean | User$assessmentSessionsArgs<ExtArgs>
    certifications?: boolean | User$certificationsArgs<ExtArgs>
    roadmaps?: boolean | User$roadmapsArgs<ExtArgs>
    userActions?: boolean | User$userActionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    organizationId?: boolean
    departmentId?: boolean
    role?: boolean
    status?: boolean
    position?: boolean
    companyName?: boolean
    companySize?: boolean
    industrySector?: boolean
    targetStandard?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    onboardingCompletedSteps?: boolean
    lastLoginAt?: boolean
    invitedAt?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | User$organizationArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    organizationId?: boolean
    departmentId?: boolean
    role?: boolean
    status?: boolean
    position?: boolean
    companyName?: boolean
    companySize?: boolean
    industrySector?: boolean
    targetStandard?: boolean
    subscriptionStatus?: boolean
    subscriptionStartDate?: boolean
    subscriptionEndDate?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    onboardingCompletedSteps?: boolean
    lastLoginAt?: boolean
    invitedAt?: boolean
    invitedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    managerNotes?: boolean | User$managerNotesArgs<ExtArgs>
    notesWritten?: boolean | User$notesWrittenArgs<ExtArgs>
    managedDepartments?: boolean | User$managedDepartmentsArgs<ExtArgs>
    assignmentsReceived?: boolean | User$assignmentsReceivedArgs<ExtArgs>
    assignmentsMade?: boolean | User$assignmentsMadeArgs<ExtArgs>
    moduleProgress?: boolean | User$moduleProgressArgs<ExtArgs>
    assessmentSessions?: boolean | User$assessmentSessionsArgs<ExtArgs>
    certifications?: boolean | User$certificationsArgs<ExtArgs>
    roadmaps?: boolean | User$roadmapsArgs<ExtArgs>
    userActions?: boolean | User$userActionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | User$organizationArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      managerNotes: Prisma.$ManagerNotePayload<ExtArgs>[]
      notesWritten: Prisma.$ManagerNotePayload<ExtArgs>[]
      managedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      assignmentsReceived: Prisma.$ModuleAssignmentPayload<ExtArgs>[]
      assignmentsMade: Prisma.$ModuleAssignmentPayload<ExtArgs>[]
      moduleProgress: Prisma.$ModuleProgressPayload<ExtArgs>[]
      assessmentSessions: Prisma.$AssessmentSessionPayload<ExtArgs>[]
      certifications: Prisma.$UserCertificationPayload<ExtArgs>[]
      roadmaps: Prisma.$RoadmapPayload<ExtArgs>[]
      userActions: Prisma.$UserActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      avatar: string | null
      organizationId: string | null
      departmentId: string | null
      role: string
      status: string
      position: string | null
      companyName: string | null
      companySize: string | null
      industrySector: string | null
      targetStandard: string | null
      subscriptionStatus: string
      subscriptionStartDate: Date | null
      subscriptionEndDate: Date | null
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      onboardingCompletedSteps: string[]
      lastLoginAt: Date | null
      invitedAt: Date | null
      invitedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends User$organizationArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    managerNotes<T extends User$managerNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$managerNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findMany"> | Null>
    notesWritten<T extends User$notesWrittenArgs<ExtArgs> = {}>(args?: Subset<T, User$notesWrittenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findMany"> | Null>
    managedDepartments<T extends User$managedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    assignmentsReceived<T extends User$assignmentsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    assignmentsMade<T extends User$assignmentsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$assignmentsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    moduleProgress<T extends User$moduleProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$moduleProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findMany"> | Null>
    assessmentSessions<T extends User$assessmentSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$assessmentSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findMany"> | Null>
    certifications<T extends User$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "findMany"> | Null>
    roadmaps<T extends User$roadmapsArgs<ExtArgs> = {}>(args?: Subset<T, User$roadmapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany"> | Null>
    userActions<T extends User$userActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly position: FieldRef<"User", 'String'>
    readonly companyName: FieldRef<"User", 'String'>
    readonly companySize: FieldRef<"User", 'String'>
    readonly industrySector: FieldRef<"User", 'String'>
    readonly targetStandard: FieldRef<"User", 'String'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly subscriptionStartDate: FieldRef<"User", 'DateTime'>
    readonly subscriptionEndDate: FieldRef<"User", 'DateTime'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly stripeSubscriptionId: FieldRef<"User", 'String'>
    readonly onboardingCompletedSteps: FieldRef<"User", 'String[]'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly invitedAt: FieldRef<"User", 'DateTime'>
    readonly invitedBy: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.organization
   */
  export type User$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.managerNotes
   */
  export type User$managerNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    where?: ManagerNoteWhereInput
    orderBy?: ManagerNoteOrderByWithRelationInput | ManagerNoteOrderByWithRelationInput[]
    cursor?: ManagerNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManagerNoteScalarFieldEnum | ManagerNoteScalarFieldEnum[]
  }

  /**
   * User.notesWritten
   */
  export type User$notesWrittenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    where?: ManagerNoteWhereInput
    orderBy?: ManagerNoteOrderByWithRelationInput | ManagerNoteOrderByWithRelationInput[]
    cursor?: ManagerNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManagerNoteScalarFieldEnum | ManagerNoteScalarFieldEnum[]
  }

  /**
   * User.managedDepartments
   */
  export type User$managedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * User.assignmentsReceived
   */
  export type User$assignmentsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    cursor?: ModuleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * User.assignmentsMade
   */
  export type User$assignmentsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    cursor?: ModuleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * User.moduleProgress
   */
  export type User$moduleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    where?: ModuleProgressWhereInput
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    cursor?: ModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * User.assessmentSessions
   */
  export type User$assessmentSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    where?: AssessmentSessionWhereInput
    orderBy?: AssessmentSessionOrderByWithRelationInput | AssessmentSessionOrderByWithRelationInput[]
    cursor?: AssessmentSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentSessionScalarFieldEnum | AssessmentSessionScalarFieldEnum[]
  }

  /**
   * User.certifications
   */
  export type User$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    where?: UserCertificationWhereInput
    orderBy?: UserCertificationOrderByWithRelationInput | UserCertificationOrderByWithRelationInput[]
    cursor?: UserCertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCertificationScalarFieldEnum | UserCertificationScalarFieldEnum[]
  }

  /**
   * User.roadmaps
   */
  export type User$roadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    cursor?: RoadmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * User.userActions
   */
  export type User$userActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    where?: UserActionWhereInput
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    cursor?: UserActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActionScalarFieldEnum | UserActionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ManagerNote
   */

  export type AggregateManagerNote = {
    _count: ManagerNoteCountAggregateOutputType | null
    _min: ManagerNoteMinAggregateOutputType | null
    _max: ManagerNoteMaxAggregateOutputType | null
  }

  export type ManagerNoteMinAggregateOutputType = {
    id: string | null
    aboutUserId: string | null
    byUserId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerNoteMaxAggregateOutputType = {
    id: string | null
    aboutUserId: string | null
    byUserId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerNoteCountAggregateOutputType = {
    id: number
    aboutUserId: number
    byUserId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManagerNoteMinAggregateInputType = {
    id?: true
    aboutUserId?: true
    byUserId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerNoteMaxAggregateInputType = {
    id?: true
    aboutUserId?: true
    byUserId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerNoteCountAggregateInputType = {
    id?: true
    aboutUserId?: true
    byUserId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManagerNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManagerNote to aggregate.
     */
    where?: ManagerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerNotes to fetch.
     */
    orderBy?: ManagerNoteOrderByWithRelationInput | ManagerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManagerNotes
    **/
    _count?: true | ManagerNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerNoteMaxAggregateInputType
  }

  export type GetManagerNoteAggregateType<T extends ManagerNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateManagerNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManagerNote[P]>
      : GetScalarType<T[P], AggregateManagerNote[P]>
  }




  export type ManagerNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerNoteWhereInput
    orderBy?: ManagerNoteOrderByWithAggregationInput | ManagerNoteOrderByWithAggregationInput[]
    by: ManagerNoteScalarFieldEnum[] | ManagerNoteScalarFieldEnum
    having?: ManagerNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerNoteCountAggregateInputType | true
    _min?: ManagerNoteMinAggregateInputType
    _max?: ManagerNoteMaxAggregateInputType
  }

  export type ManagerNoteGroupByOutputType = {
    id: string
    aboutUserId: string
    byUserId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: ManagerNoteCountAggregateOutputType | null
    _min: ManagerNoteMinAggregateOutputType | null
    _max: ManagerNoteMaxAggregateOutputType | null
  }

  type GetManagerNoteGroupByPayload<T extends ManagerNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerNoteGroupByOutputType[P]>
        }
      >
    >


  export type ManagerNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aboutUserId?: boolean
    byUserId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aboutUser?: boolean | UserDefaultArgs<ExtArgs>
    byUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["managerNote"]>

  export type ManagerNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    aboutUserId?: boolean
    byUserId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aboutUser?: boolean | UserDefaultArgs<ExtArgs>
    byUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["managerNote"]>

  export type ManagerNoteSelectScalar = {
    id?: boolean
    aboutUserId?: boolean
    byUserId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManagerNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aboutUser?: boolean | UserDefaultArgs<ExtArgs>
    byUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ManagerNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aboutUser?: boolean | UserDefaultArgs<ExtArgs>
    byUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ManagerNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManagerNote"
    objects: {
      aboutUser: Prisma.$UserPayload<ExtArgs>
      byUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      aboutUserId: string
      byUserId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["managerNote"]>
    composites: {}
  }

  type ManagerNoteGetPayload<S extends boolean | null | undefined | ManagerNoteDefaultArgs> = $Result.GetResult<Prisma.$ManagerNotePayload, S>

  type ManagerNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ManagerNoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ManagerNoteCountAggregateInputType | true
    }

  export interface ManagerNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManagerNote'], meta: { name: 'ManagerNote' } }
    /**
     * Find zero or one ManagerNote that matches the filter.
     * @param {ManagerNoteFindUniqueArgs} args - Arguments to find a ManagerNote
     * @example
     * // Get one ManagerNote
     * const managerNote = await prisma.managerNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerNoteFindUniqueArgs>(args: SelectSubset<T, ManagerNoteFindUniqueArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ManagerNote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ManagerNoteFindUniqueOrThrowArgs} args - Arguments to find a ManagerNote
     * @example
     * // Get one ManagerNote
     * const managerNote = await prisma.managerNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ManagerNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteFindFirstArgs} args - Arguments to find a ManagerNote
     * @example
     * // Get one ManagerNote
     * const managerNote = await prisma.managerNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerNoteFindFirstArgs>(args?: SelectSubset<T, ManagerNoteFindFirstArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ManagerNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteFindFirstOrThrowArgs} args - Arguments to find a ManagerNote
     * @example
     * // Get one ManagerNote
     * const managerNote = await prisma.managerNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ManagerNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManagerNotes
     * const managerNotes = await prisma.managerNote.findMany()
     * 
     * // Get first 10 ManagerNotes
     * const managerNotes = await prisma.managerNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerNoteWithIdOnly = await prisma.managerNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerNoteFindManyArgs>(args?: SelectSubset<T, ManagerNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ManagerNote.
     * @param {ManagerNoteCreateArgs} args - Arguments to create a ManagerNote.
     * @example
     * // Create one ManagerNote
     * const ManagerNote = await prisma.managerNote.create({
     *   data: {
     *     // ... data to create a ManagerNote
     *   }
     * })
     * 
     */
    create<T extends ManagerNoteCreateArgs>(args: SelectSubset<T, ManagerNoteCreateArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ManagerNotes.
     * @param {ManagerNoteCreateManyArgs} args - Arguments to create many ManagerNotes.
     * @example
     * // Create many ManagerNotes
     * const managerNote = await prisma.managerNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerNoteCreateManyArgs>(args?: SelectSubset<T, ManagerNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ManagerNotes and returns the data saved in the database.
     * @param {ManagerNoteCreateManyAndReturnArgs} args - Arguments to create many ManagerNotes.
     * @example
     * // Create many ManagerNotes
     * const managerNote = await prisma.managerNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ManagerNotes and only return the `id`
     * const managerNoteWithIdOnly = await prisma.managerNote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ManagerNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ManagerNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ManagerNote.
     * @param {ManagerNoteDeleteArgs} args - Arguments to delete one ManagerNote.
     * @example
     * // Delete one ManagerNote
     * const ManagerNote = await prisma.managerNote.delete({
     *   where: {
     *     // ... filter to delete one ManagerNote
     *   }
     * })
     * 
     */
    delete<T extends ManagerNoteDeleteArgs>(args: SelectSubset<T, ManagerNoteDeleteArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ManagerNote.
     * @param {ManagerNoteUpdateArgs} args - Arguments to update one ManagerNote.
     * @example
     * // Update one ManagerNote
     * const managerNote = await prisma.managerNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerNoteUpdateArgs>(args: SelectSubset<T, ManagerNoteUpdateArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ManagerNotes.
     * @param {ManagerNoteDeleteManyArgs} args - Arguments to filter ManagerNotes to delete.
     * @example
     * // Delete a few ManagerNotes
     * const { count } = await prisma.managerNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerNoteDeleteManyArgs>(args?: SelectSubset<T, ManagerNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManagerNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManagerNotes
     * const managerNote = await prisma.managerNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerNoteUpdateManyArgs>(args: SelectSubset<T, ManagerNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManagerNote.
     * @param {ManagerNoteUpsertArgs} args - Arguments to update or create a ManagerNote.
     * @example
     * // Update or create a ManagerNote
     * const managerNote = await prisma.managerNote.upsert({
     *   create: {
     *     // ... data to create a ManagerNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManagerNote we want to update
     *   }
     * })
     */
    upsert<T extends ManagerNoteUpsertArgs>(args: SelectSubset<T, ManagerNoteUpsertArgs<ExtArgs>>): Prisma__ManagerNoteClient<$Result.GetResult<Prisma.$ManagerNotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ManagerNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteCountArgs} args - Arguments to filter ManagerNotes to count.
     * @example
     * // Count the number of ManagerNotes
     * const count = await prisma.managerNote.count({
     *   where: {
     *     // ... the filter for the ManagerNotes we want to count
     *   }
     * })
    **/
    count<T extends ManagerNoteCountArgs>(
      args?: Subset<T, ManagerNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManagerNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerNoteAggregateArgs>(args: Subset<T, ManagerNoteAggregateArgs>): Prisma.PrismaPromise<GetManagerNoteAggregateType<T>>

    /**
     * Group by ManagerNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerNoteGroupByArgs['orderBy'] }
        : { orderBy?: ManagerNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManagerNote model
   */
  readonly fields: ManagerNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManagerNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    aboutUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    byUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManagerNote model
   */ 
  interface ManagerNoteFieldRefs {
    readonly id: FieldRef<"ManagerNote", 'String'>
    readonly aboutUserId: FieldRef<"ManagerNote", 'String'>
    readonly byUserId: FieldRef<"ManagerNote", 'String'>
    readonly content: FieldRef<"ManagerNote", 'String'>
    readonly createdAt: FieldRef<"ManagerNote", 'DateTime'>
    readonly updatedAt: FieldRef<"ManagerNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManagerNote findUnique
   */
  export type ManagerNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * Filter, which ManagerNote to fetch.
     */
    where: ManagerNoteWhereUniqueInput
  }

  /**
   * ManagerNote findUniqueOrThrow
   */
  export type ManagerNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * Filter, which ManagerNote to fetch.
     */
    where: ManagerNoteWhereUniqueInput
  }

  /**
   * ManagerNote findFirst
   */
  export type ManagerNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * Filter, which ManagerNote to fetch.
     */
    where?: ManagerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerNotes to fetch.
     */
    orderBy?: ManagerNoteOrderByWithRelationInput | ManagerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManagerNotes.
     */
    cursor?: ManagerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManagerNotes.
     */
    distinct?: ManagerNoteScalarFieldEnum | ManagerNoteScalarFieldEnum[]
  }

  /**
   * ManagerNote findFirstOrThrow
   */
  export type ManagerNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * Filter, which ManagerNote to fetch.
     */
    where?: ManagerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerNotes to fetch.
     */
    orderBy?: ManagerNoteOrderByWithRelationInput | ManagerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManagerNotes.
     */
    cursor?: ManagerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManagerNotes.
     */
    distinct?: ManagerNoteScalarFieldEnum | ManagerNoteScalarFieldEnum[]
  }

  /**
   * ManagerNote findMany
   */
  export type ManagerNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * Filter, which ManagerNotes to fetch.
     */
    where?: ManagerNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerNotes to fetch.
     */
    orderBy?: ManagerNoteOrderByWithRelationInput | ManagerNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManagerNotes.
     */
    cursor?: ManagerNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerNotes.
     */
    skip?: number
    distinct?: ManagerNoteScalarFieldEnum | ManagerNoteScalarFieldEnum[]
  }

  /**
   * ManagerNote create
   */
  export type ManagerNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ManagerNote.
     */
    data: XOR<ManagerNoteCreateInput, ManagerNoteUncheckedCreateInput>
  }

  /**
   * ManagerNote createMany
   */
  export type ManagerNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManagerNotes.
     */
    data: ManagerNoteCreateManyInput | ManagerNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManagerNote createManyAndReturn
   */
  export type ManagerNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ManagerNotes.
     */
    data: ManagerNoteCreateManyInput | ManagerNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ManagerNote update
   */
  export type ManagerNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ManagerNote.
     */
    data: XOR<ManagerNoteUpdateInput, ManagerNoteUncheckedUpdateInput>
    /**
     * Choose, which ManagerNote to update.
     */
    where: ManagerNoteWhereUniqueInput
  }

  /**
   * ManagerNote updateMany
   */
  export type ManagerNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManagerNotes.
     */
    data: XOR<ManagerNoteUpdateManyMutationInput, ManagerNoteUncheckedUpdateManyInput>
    /**
     * Filter which ManagerNotes to update
     */
    where?: ManagerNoteWhereInput
  }

  /**
   * ManagerNote upsert
   */
  export type ManagerNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ManagerNote to update in case it exists.
     */
    where: ManagerNoteWhereUniqueInput
    /**
     * In case the ManagerNote found by the `where` argument doesn't exist, create a new ManagerNote with this data.
     */
    create: XOR<ManagerNoteCreateInput, ManagerNoteUncheckedCreateInput>
    /**
     * In case the ManagerNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerNoteUpdateInput, ManagerNoteUncheckedUpdateInput>
  }

  /**
   * ManagerNote delete
   */
  export type ManagerNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
    /**
     * Filter which ManagerNote to delete.
     */
    where: ManagerNoteWhereUniqueInput
  }

  /**
   * ManagerNote deleteMany
   */
  export type ManagerNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManagerNotes to delete
     */
    where?: ManagerNoteWhereInput
  }

  /**
   * ManagerNote without action
   */
  export type ManagerNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerNote
     */
    select?: ManagerNoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerNoteInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    estimatedDuration: number | null
    xpReward: number | null
    completionCount: number | null
    avgScore: number | null
  }

  export type ModuleSumAggregateOutputType = {
    estimatedDuration: number | null
    xpReward: number | null
    completionCount: number | null
    avgScore: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    title: string | null
    description: string | null
    coverImage: string | null
    category: string | null
    difficulty: string | null
    estimatedDuration: number | null
    xpReward: number | null
    badge: string | null
    status: string | null
    publishedAt: Date | null
    completionCount: number | null
    avgScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    title: string | null
    description: string | null
    coverImage: string | null
    category: string | null
    difficulty: string | null
    estimatedDuration: number | null
    xpReward: number | null
    badge: string | null
    status: string | null
    publishedAt: Date | null
    completionCount: number | null
    avgScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    organizationId: number
    title: number
    description: number
    coverImage: number
    category: number
    tags: number
    difficulty: number
    estimatedDuration: number
    sections: number
    xpReward: number
    badge: number
    status: number
    publishedAt: number
    completionCount: number
    avgScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    estimatedDuration?: true
    xpReward?: true
    completionCount?: true
    avgScore?: true
  }

  export type ModuleSumAggregateInputType = {
    estimatedDuration?: true
    xpReward?: true
    completionCount?: true
    avgScore?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    organizationId?: true
    title?: true
    description?: true
    coverImage?: true
    category?: true
    difficulty?: true
    estimatedDuration?: true
    xpReward?: true
    badge?: true
    status?: true
    publishedAt?: true
    completionCount?: true
    avgScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    organizationId?: true
    title?: true
    description?: true
    coverImage?: true
    category?: true
    difficulty?: true
    estimatedDuration?: true
    xpReward?: true
    badge?: true
    status?: true
    publishedAt?: true
    completionCount?: true
    avgScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    organizationId?: true
    title?: true
    description?: true
    coverImage?: true
    category?: true
    tags?: true
    difficulty?: true
    estimatedDuration?: true
    sections?: true
    xpReward?: true
    badge?: true
    status?: true
    publishedAt?: true
    completionCount?: true
    avgScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    organizationId: string | null
    title: string
    description: string | null
    coverImage: string | null
    category: string
    tags: string[]
    difficulty: string
    estimatedDuration: number
    sections: JsonValue | null
    xpReward: number
    badge: string | null
    status: string
    publishedAt: Date | null
    completionCount: number
    avgScore: number
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    title?: boolean
    description?: boolean
    coverImage?: boolean
    category?: boolean
    tags?: boolean
    difficulty?: boolean
    estimatedDuration?: boolean
    sections?: boolean
    xpReward?: boolean
    badge?: boolean
    status?: boolean
    publishedAt?: boolean
    completionCount?: boolean
    avgScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | Module$organizationArgs<ExtArgs>
    prerequisites?: boolean | Module$prerequisitesArgs<ExtArgs>
    unlocksModules?: boolean | Module$unlocksModulesArgs<ExtArgs>
    assignments?: boolean | Module$assignmentsArgs<ExtArgs>
    progress?: boolean | Module$progressArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    title?: boolean
    description?: boolean
    coverImage?: boolean
    category?: boolean
    tags?: boolean
    difficulty?: boolean
    estimatedDuration?: boolean
    sections?: boolean
    xpReward?: boolean
    badge?: boolean
    status?: boolean
    publishedAt?: boolean
    completionCount?: boolean
    avgScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | Module$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    organizationId?: boolean
    title?: boolean
    description?: boolean
    coverImage?: boolean
    category?: boolean
    tags?: boolean
    difficulty?: boolean
    estimatedDuration?: boolean
    sections?: boolean
    xpReward?: boolean
    badge?: boolean
    status?: boolean
    publishedAt?: boolean
    completionCount?: boolean
    avgScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Module$organizationArgs<ExtArgs>
    prerequisites?: boolean | Module$prerequisitesArgs<ExtArgs>
    unlocksModules?: boolean | Module$unlocksModulesArgs<ExtArgs>
    assignments?: boolean | Module$assignmentsArgs<ExtArgs>
    progress?: boolean | Module$progressArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | Module$organizationArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      prerequisites: Prisma.$ModulePrerequisitePayload<ExtArgs>[]
      unlocksModules: Prisma.$ModulePrerequisitePayload<ExtArgs>[]
      assignments: Prisma.$ModuleAssignmentPayload<ExtArgs>[]
      progress: Prisma.$ModuleProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string | null
      title: string
      description: string | null
      coverImage: string | null
      category: string
      tags: string[]
      difficulty: string
      estimatedDuration: number
      sections: Prisma.JsonValue | null
      xpReward: number
      badge: string | null
      status: string
      publishedAt: Date | null
      completionCount: number
      avgScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends Module$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Module$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prerequisites<T extends Module$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, Module$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findMany"> | Null>
    unlocksModules<T extends Module$unlocksModulesArgs<ExtArgs> = {}>(args?: Subset<T, Module$unlocksModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Module$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Module$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    progress<T extends Module$progressArgs<ExtArgs> = {}>(args?: Subset<T, Module$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly organizationId: FieldRef<"Module", 'String'>
    readonly title: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly coverImage: FieldRef<"Module", 'String'>
    readonly category: FieldRef<"Module", 'String'>
    readonly tags: FieldRef<"Module", 'String[]'>
    readonly difficulty: FieldRef<"Module", 'String'>
    readonly estimatedDuration: FieldRef<"Module", 'Int'>
    readonly sections: FieldRef<"Module", 'Json'>
    readonly xpReward: FieldRef<"Module", 'Int'>
    readonly badge: FieldRef<"Module", 'String'>
    readonly status: FieldRef<"Module", 'String'>
    readonly publishedAt: FieldRef<"Module", 'DateTime'>
    readonly completionCount: FieldRef<"Module", 'Int'>
    readonly avgScore: FieldRef<"Module", 'Float'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
  }

  /**
   * Module.organization
   */
  export type Module$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Module.prerequisites
   */
  export type Module$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    where?: ModulePrerequisiteWhereInput
    orderBy?: ModulePrerequisiteOrderByWithRelationInput | ModulePrerequisiteOrderByWithRelationInput[]
    cursor?: ModulePrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulePrerequisiteScalarFieldEnum | ModulePrerequisiteScalarFieldEnum[]
  }

  /**
   * Module.unlocksModules
   */
  export type Module$unlocksModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    where?: ModulePrerequisiteWhereInput
    orderBy?: ModulePrerequisiteOrderByWithRelationInput | ModulePrerequisiteOrderByWithRelationInput[]
    cursor?: ModulePrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulePrerequisiteScalarFieldEnum | ModulePrerequisiteScalarFieldEnum[]
  }

  /**
   * Module.assignments
   */
  export type Module$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    cursor?: ModuleAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * Module.progress
   */
  export type Module$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    where?: ModuleProgressWhereInput
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    cursor?: ModuleProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model ModulePrerequisite
   */

  export type AggregateModulePrerequisite = {
    _count: ModulePrerequisiteCountAggregateOutputType | null
    _min: ModulePrerequisiteMinAggregateOutputType | null
    _max: ModulePrerequisiteMaxAggregateOutputType | null
  }

  export type ModulePrerequisiteMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    prerequisiteId: string | null
  }

  export type ModulePrerequisiteMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    prerequisiteId: string | null
  }

  export type ModulePrerequisiteCountAggregateOutputType = {
    id: number
    moduleId: number
    prerequisiteId: number
    _all: number
  }


  export type ModulePrerequisiteMinAggregateInputType = {
    id?: true
    moduleId?: true
    prerequisiteId?: true
  }

  export type ModulePrerequisiteMaxAggregateInputType = {
    id?: true
    moduleId?: true
    prerequisiteId?: true
  }

  export type ModulePrerequisiteCountAggregateInputType = {
    id?: true
    moduleId?: true
    prerequisiteId?: true
    _all?: true
  }

  export type ModulePrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePrerequisite to aggregate.
     */
    where?: ModulePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrerequisites to fetch.
     */
    orderBy?: ModulePrerequisiteOrderByWithRelationInput | ModulePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModulePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModulePrerequisites
    **/
    _count?: true | ModulePrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModulePrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModulePrerequisiteMaxAggregateInputType
  }

  export type GetModulePrerequisiteAggregateType<T extends ModulePrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateModulePrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModulePrerequisite[P]>
      : GetScalarType<T[P], AggregateModulePrerequisite[P]>
  }




  export type ModulePrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModulePrerequisiteWhereInput
    orderBy?: ModulePrerequisiteOrderByWithAggregationInput | ModulePrerequisiteOrderByWithAggregationInput[]
    by: ModulePrerequisiteScalarFieldEnum[] | ModulePrerequisiteScalarFieldEnum
    having?: ModulePrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModulePrerequisiteCountAggregateInputType | true
    _min?: ModulePrerequisiteMinAggregateInputType
    _max?: ModulePrerequisiteMaxAggregateInputType
  }

  export type ModulePrerequisiteGroupByOutputType = {
    id: string
    moduleId: string
    prerequisiteId: string
    _count: ModulePrerequisiteCountAggregateOutputType | null
    _min: ModulePrerequisiteMinAggregateOutputType | null
    _max: ModulePrerequisiteMaxAggregateOutputType | null
  }

  type GetModulePrerequisiteGroupByPayload<T extends ModulePrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModulePrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModulePrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModulePrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], ModulePrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type ModulePrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    prerequisiteId?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    prerequisite?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePrerequisite"]>

  export type ModulePrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    prerequisiteId?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    prerequisite?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modulePrerequisite"]>

  export type ModulePrerequisiteSelectScalar = {
    id?: boolean
    moduleId?: boolean
    prerequisiteId?: boolean
  }

  export type ModulePrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    prerequisite?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ModulePrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    prerequisite?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $ModulePrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModulePrerequisite"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      prerequisite: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      prerequisiteId: string
    }, ExtArgs["result"]["modulePrerequisite"]>
    composites: {}
  }

  type ModulePrerequisiteGetPayload<S extends boolean | null | undefined | ModulePrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$ModulePrerequisitePayload, S>

  type ModulePrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModulePrerequisiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModulePrerequisiteCountAggregateInputType | true
    }

  export interface ModulePrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModulePrerequisite'], meta: { name: 'ModulePrerequisite' } }
    /**
     * Find zero or one ModulePrerequisite that matches the filter.
     * @param {ModulePrerequisiteFindUniqueArgs} args - Arguments to find a ModulePrerequisite
     * @example
     * // Get one ModulePrerequisite
     * const modulePrerequisite = await prisma.modulePrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModulePrerequisiteFindUniqueArgs>(args: SelectSubset<T, ModulePrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModulePrerequisite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModulePrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a ModulePrerequisite
     * @example
     * // Get one ModulePrerequisite
     * const modulePrerequisite = await prisma.modulePrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModulePrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, ModulePrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModulePrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteFindFirstArgs} args - Arguments to find a ModulePrerequisite
     * @example
     * // Get one ModulePrerequisite
     * const modulePrerequisite = await prisma.modulePrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModulePrerequisiteFindFirstArgs>(args?: SelectSubset<T, ModulePrerequisiteFindFirstArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModulePrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteFindFirstOrThrowArgs} args - Arguments to find a ModulePrerequisite
     * @example
     * // Get one ModulePrerequisite
     * const modulePrerequisite = await prisma.modulePrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModulePrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, ModulePrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModulePrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModulePrerequisites
     * const modulePrerequisites = await prisma.modulePrerequisite.findMany()
     * 
     * // Get first 10 ModulePrerequisites
     * const modulePrerequisites = await prisma.modulePrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modulePrerequisiteWithIdOnly = await prisma.modulePrerequisite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModulePrerequisiteFindManyArgs>(args?: SelectSubset<T, ModulePrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModulePrerequisite.
     * @param {ModulePrerequisiteCreateArgs} args - Arguments to create a ModulePrerequisite.
     * @example
     * // Create one ModulePrerequisite
     * const ModulePrerequisite = await prisma.modulePrerequisite.create({
     *   data: {
     *     // ... data to create a ModulePrerequisite
     *   }
     * })
     * 
     */
    create<T extends ModulePrerequisiteCreateArgs>(args: SelectSubset<T, ModulePrerequisiteCreateArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModulePrerequisites.
     * @param {ModulePrerequisiteCreateManyArgs} args - Arguments to create many ModulePrerequisites.
     * @example
     * // Create many ModulePrerequisites
     * const modulePrerequisite = await prisma.modulePrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModulePrerequisiteCreateManyArgs>(args?: SelectSubset<T, ModulePrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModulePrerequisites and returns the data saved in the database.
     * @param {ModulePrerequisiteCreateManyAndReturnArgs} args - Arguments to create many ModulePrerequisites.
     * @example
     * // Create many ModulePrerequisites
     * const modulePrerequisite = await prisma.modulePrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModulePrerequisites and only return the `id`
     * const modulePrerequisiteWithIdOnly = await prisma.modulePrerequisite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModulePrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, ModulePrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModulePrerequisite.
     * @param {ModulePrerequisiteDeleteArgs} args - Arguments to delete one ModulePrerequisite.
     * @example
     * // Delete one ModulePrerequisite
     * const ModulePrerequisite = await prisma.modulePrerequisite.delete({
     *   where: {
     *     // ... filter to delete one ModulePrerequisite
     *   }
     * })
     * 
     */
    delete<T extends ModulePrerequisiteDeleteArgs>(args: SelectSubset<T, ModulePrerequisiteDeleteArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModulePrerequisite.
     * @param {ModulePrerequisiteUpdateArgs} args - Arguments to update one ModulePrerequisite.
     * @example
     * // Update one ModulePrerequisite
     * const modulePrerequisite = await prisma.modulePrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModulePrerequisiteUpdateArgs>(args: SelectSubset<T, ModulePrerequisiteUpdateArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModulePrerequisites.
     * @param {ModulePrerequisiteDeleteManyArgs} args - Arguments to filter ModulePrerequisites to delete.
     * @example
     * // Delete a few ModulePrerequisites
     * const { count } = await prisma.modulePrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModulePrerequisiteDeleteManyArgs>(args?: SelectSubset<T, ModulePrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModulePrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModulePrerequisites
     * const modulePrerequisite = await prisma.modulePrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModulePrerequisiteUpdateManyArgs>(args: SelectSubset<T, ModulePrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModulePrerequisite.
     * @param {ModulePrerequisiteUpsertArgs} args - Arguments to update or create a ModulePrerequisite.
     * @example
     * // Update or create a ModulePrerequisite
     * const modulePrerequisite = await prisma.modulePrerequisite.upsert({
     *   create: {
     *     // ... data to create a ModulePrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModulePrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends ModulePrerequisiteUpsertArgs>(args: SelectSubset<T, ModulePrerequisiteUpsertArgs<ExtArgs>>): Prisma__ModulePrerequisiteClient<$Result.GetResult<Prisma.$ModulePrerequisitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModulePrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteCountArgs} args - Arguments to filter ModulePrerequisites to count.
     * @example
     * // Count the number of ModulePrerequisites
     * const count = await prisma.modulePrerequisite.count({
     *   where: {
     *     // ... the filter for the ModulePrerequisites we want to count
     *   }
     * })
    **/
    count<T extends ModulePrerequisiteCountArgs>(
      args?: Subset<T, ModulePrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModulePrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModulePrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModulePrerequisiteAggregateArgs>(args: Subset<T, ModulePrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetModulePrerequisiteAggregateType<T>>

    /**
     * Group by ModulePrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulePrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModulePrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModulePrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: ModulePrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModulePrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModulePrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModulePrerequisite model
   */
  readonly fields: ModulePrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModulePrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModulePrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prerequisite<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModulePrerequisite model
   */ 
  interface ModulePrerequisiteFieldRefs {
    readonly id: FieldRef<"ModulePrerequisite", 'String'>
    readonly moduleId: FieldRef<"ModulePrerequisite", 'String'>
    readonly prerequisiteId: FieldRef<"ModulePrerequisite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ModulePrerequisite findUnique
   */
  export type ModulePrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrerequisite to fetch.
     */
    where: ModulePrerequisiteWhereUniqueInput
  }

  /**
   * ModulePrerequisite findUniqueOrThrow
   */
  export type ModulePrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrerequisite to fetch.
     */
    where: ModulePrerequisiteWhereUniqueInput
  }

  /**
   * ModulePrerequisite findFirst
   */
  export type ModulePrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrerequisite to fetch.
     */
    where?: ModulePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrerequisites to fetch.
     */
    orderBy?: ModulePrerequisiteOrderByWithRelationInput | ModulePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePrerequisites.
     */
    cursor?: ModulePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePrerequisites.
     */
    distinct?: ModulePrerequisiteScalarFieldEnum | ModulePrerequisiteScalarFieldEnum[]
  }

  /**
   * ModulePrerequisite findFirstOrThrow
   */
  export type ModulePrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrerequisite to fetch.
     */
    where?: ModulePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrerequisites to fetch.
     */
    orderBy?: ModulePrerequisiteOrderByWithRelationInput | ModulePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModulePrerequisites.
     */
    cursor?: ModulePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModulePrerequisites.
     */
    distinct?: ModulePrerequisiteScalarFieldEnum | ModulePrerequisiteScalarFieldEnum[]
  }

  /**
   * ModulePrerequisite findMany
   */
  export type ModulePrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ModulePrerequisites to fetch.
     */
    where?: ModulePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModulePrerequisites to fetch.
     */
    orderBy?: ModulePrerequisiteOrderByWithRelationInput | ModulePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModulePrerequisites.
     */
    cursor?: ModulePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModulePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModulePrerequisites.
     */
    skip?: number
    distinct?: ModulePrerequisiteScalarFieldEnum | ModulePrerequisiteScalarFieldEnum[]
  }

  /**
   * ModulePrerequisite create
   */
  export type ModulePrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a ModulePrerequisite.
     */
    data: XOR<ModulePrerequisiteCreateInput, ModulePrerequisiteUncheckedCreateInput>
  }

  /**
   * ModulePrerequisite createMany
   */
  export type ModulePrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModulePrerequisites.
     */
    data: ModulePrerequisiteCreateManyInput | ModulePrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModulePrerequisite createManyAndReturn
   */
  export type ModulePrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModulePrerequisites.
     */
    data: ModulePrerequisiteCreateManyInput | ModulePrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModulePrerequisite update
   */
  export type ModulePrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a ModulePrerequisite.
     */
    data: XOR<ModulePrerequisiteUpdateInput, ModulePrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which ModulePrerequisite to update.
     */
    where: ModulePrerequisiteWhereUniqueInput
  }

  /**
   * ModulePrerequisite updateMany
   */
  export type ModulePrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModulePrerequisites.
     */
    data: XOR<ModulePrerequisiteUpdateManyMutationInput, ModulePrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which ModulePrerequisites to update
     */
    where?: ModulePrerequisiteWhereInput
  }

  /**
   * ModulePrerequisite upsert
   */
  export type ModulePrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the ModulePrerequisite to update in case it exists.
     */
    where: ModulePrerequisiteWhereUniqueInput
    /**
     * In case the ModulePrerequisite found by the `where` argument doesn't exist, create a new ModulePrerequisite with this data.
     */
    create: XOR<ModulePrerequisiteCreateInput, ModulePrerequisiteUncheckedCreateInput>
    /**
     * In case the ModulePrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModulePrerequisiteUpdateInput, ModulePrerequisiteUncheckedUpdateInput>
  }

  /**
   * ModulePrerequisite delete
   */
  export type ModulePrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which ModulePrerequisite to delete.
     */
    where: ModulePrerequisiteWhereUniqueInput
  }

  /**
   * ModulePrerequisite deleteMany
   */
  export type ModulePrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModulePrerequisites to delete
     */
    where?: ModulePrerequisiteWhereInput
  }

  /**
   * ModulePrerequisite without action
   */
  export type ModulePrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModulePrerequisite
     */
    select?: ModulePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModulePrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model ModuleAssignment
   */

  export type AggregateModuleAssignment = {
    _count: ModuleAssignmentCountAggregateOutputType | null
    _min: ModuleAssignmentMinAggregateOutputType | null
    _max: ModuleAssignmentMaxAggregateOutputType | null
  }

  export type ModuleAssignmentMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    assignedToId: string | null
    assignedById: string | null
    priority: string | null
    deadline: Date | null
    message: string | null
    status: string | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ModuleAssignmentMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    assignedToId: string | null
    assignedById: string | null
    priority: string | null
    deadline: Date | null
    message: string | null
    status: string | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ModuleAssignmentCountAggregateOutputType = {
    id: number
    moduleId: number
    assignedToId: number
    assignedById: number
    priority: number
    deadline: number
    message: number
    status: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type ModuleAssignmentMinAggregateInputType = {
    id?: true
    moduleId?: true
    assignedToId?: true
    assignedById?: true
    priority?: true
    deadline?: true
    message?: true
    status?: true
    completedAt?: true
    createdAt?: true
  }

  export type ModuleAssignmentMaxAggregateInputType = {
    id?: true
    moduleId?: true
    assignedToId?: true
    assignedById?: true
    priority?: true
    deadline?: true
    message?: true
    status?: true
    completedAt?: true
    createdAt?: true
  }

  export type ModuleAssignmentCountAggregateInputType = {
    id?: true
    moduleId?: true
    assignedToId?: true
    assignedById?: true
    priority?: true
    deadline?: true
    message?: true
    status?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ModuleAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleAssignment to aggregate.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleAssignments
    **/
    _count?: true | ModuleAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleAssignmentMaxAggregateInputType
  }

  export type GetModuleAssignmentAggregateType<T extends ModuleAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleAssignment[P]>
      : GetScalarType<T[P], AggregateModuleAssignment[P]>
  }




  export type ModuleAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleAssignmentWhereInput
    orderBy?: ModuleAssignmentOrderByWithAggregationInput | ModuleAssignmentOrderByWithAggregationInput[]
    by: ModuleAssignmentScalarFieldEnum[] | ModuleAssignmentScalarFieldEnum
    having?: ModuleAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleAssignmentCountAggregateInputType | true
    _min?: ModuleAssignmentMinAggregateInputType
    _max?: ModuleAssignmentMaxAggregateInputType
  }

  export type ModuleAssignmentGroupByOutputType = {
    id: string
    moduleId: string
    assignedToId: string
    assignedById: string
    priority: string
    deadline: Date | null
    message: string | null
    status: string
    completedAt: Date | null
    createdAt: Date
    _count: ModuleAssignmentCountAggregateOutputType | null
    _min: ModuleAssignmentMinAggregateOutputType | null
    _max: ModuleAssignmentMaxAggregateOutputType | null
  }

  type GetModuleAssignmentGroupByPayload<T extends ModuleAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ModuleAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    assignedToId?: boolean
    assignedById?: boolean
    priority?: boolean
    deadline?: boolean
    message?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleAssignment"]>

  export type ModuleAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    assignedToId?: boolean
    assignedById?: boolean
    priority?: boolean
    deadline?: boolean
    message?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleAssignment"]>

  export type ModuleAssignmentSelectScalar = {
    id?: boolean
    moduleId?: boolean
    assignedToId?: boolean
    assignedById?: boolean
    priority?: boolean
    deadline?: boolean
    message?: boolean
    status?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type ModuleAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ModuleAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ModuleAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleAssignment"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs>
      assignedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      assignedToId: string
      assignedById: string
      priority: string
      deadline: Date | null
      message: string | null
      status: string
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["moduleAssignment"]>
    composites: {}
  }

  type ModuleAssignmentGetPayload<S extends boolean | null | undefined | ModuleAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ModuleAssignmentPayload, S>

  type ModuleAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleAssignmentCountAggregateInputType | true
    }

  export interface ModuleAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleAssignment'], meta: { name: 'ModuleAssignment' } }
    /**
     * Find zero or one ModuleAssignment that matches the filter.
     * @param {ModuleAssignmentFindUniqueArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleAssignmentFindUniqueArgs>(args: SelectSubset<T, ModuleAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModuleAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModuleAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentFindFirstArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleAssignmentFindFirstArgs>(args?: SelectSubset<T, ModuleAssignmentFindFirstArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModuleAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentFindFirstOrThrowArgs} args - Arguments to find a ModuleAssignment
     * @example
     * // Get one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModuleAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleAssignments
     * const moduleAssignments = await prisma.moduleAssignment.findMany()
     * 
     * // Get first 10 ModuleAssignments
     * const moduleAssignments = await prisma.moduleAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleAssignmentWithIdOnly = await prisma.moduleAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleAssignmentFindManyArgs>(args?: SelectSubset<T, ModuleAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModuleAssignment.
     * @param {ModuleAssignmentCreateArgs} args - Arguments to create a ModuleAssignment.
     * @example
     * // Create one ModuleAssignment
     * const ModuleAssignment = await prisma.moduleAssignment.create({
     *   data: {
     *     // ... data to create a ModuleAssignment
     *   }
     * })
     * 
     */
    create<T extends ModuleAssignmentCreateArgs>(args: SelectSubset<T, ModuleAssignmentCreateArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModuleAssignments.
     * @param {ModuleAssignmentCreateManyArgs} args - Arguments to create many ModuleAssignments.
     * @example
     * // Create many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleAssignmentCreateManyArgs>(args?: SelectSubset<T, ModuleAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleAssignments and returns the data saved in the database.
     * @param {ModuleAssignmentCreateManyAndReturnArgs} args - Arguments to create many ModuleAssignments.
     * @example
     * // Create many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleAssignments and only return the `id`
     * const moduleAssignmentWithIdOnly = await prisma.moduleAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModuleAssignment.
     * @param {ModuleAssignmentDeleteArgs} args - Arguments to delete one ModuleAssignment.
     * @example
     * // Delete one ModuleAssignment
     * const ModuleAssignment = await prisma.moduleAssignment.delete({
     *   where: {
     *     // ... filter to delete one ModuleAssignment
     *   }
     * })
     * 
     */
    delete<T extends ModuleAssignmentDeleteArgs>(args: SelectSubset<T, ModuleAssignmentDeleteArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModuleAssignment.
     * @param {ModuleAssignmentUpdateArgs} args - Arguments to update one ModuleAssignment.
     * @example
     * // Update one ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleAssignmentUpdateArgs>(args: SelectSubset<T, ModuleAssignmentUpdateArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModuleAssignments.
     * @param {ModuleAssignmentDeleteManyArgs} args - Arguments to filter ModuleAssignments to delete.
     * @example
     * // Delete a few ModuleAssignments
     * const { count } = await prisma.moduleAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleAssignmentDeleteManyArgs>(args?: SelectSubset<T, ModuleAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleAssignments
     * const moduleAssignment = await prisma.moduleAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleAssignmentUpdateManyArgs>(args: SelectSubset<T, ModuleAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuleAssignment.
     * @param {ModuleAssignmentUpsertArgs} args - Arguments to update or create a ModuleAssignment.
     * @example
     * // Update or create a ModuleAssignment
     * const moduleAssignment = await prisma.moduleAssignment.upsert({
     *   create: {
     *     // ... data to create a ModuleAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ModuleAssignmentUpsertArgs>(args: SelectSubset<T, ModuleAssignmentUpsertArgs<ExtArgs>>): Prisma__ModuleAssignmentClient<$Result.GetResult<Prisma.$ModuleAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModuleAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentCountArgs} args - Arguments to filter ModuleAssignments to count.
     * @example
     * // Count the number of ModuleAssignments
     * const count = await prisma.moduleAssignment.count({
     *   where: {
     *     // ... the filter for the ModuleAssignments we want to count
     *   }
     * })
    **/
    count<T extends ModuleAssignmentCountArgs>(
      args?: Subset<T, ModuleAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAssignmentAggregateArgs>(args: Subset<T, ModuleAssignmentAggregateArgs>): Prisma.PrismaPromise<GetModuleAssignmentAggregateType<T>>

    /**
     * Group by ModuleAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ModuleAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleAssignment model
   */
  readonly fields: ModuleAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleAssignment model
   */ 
  interface ModuleAssignmentFieldRefs {
    readonly id: FieldRef<"ModuleAssignment", 'String'>
    readonly moduleId: FieldRef<"ModuleAssignment", 'String'>
    readonly assignedToId: FieldRef<"ModuleAssignment", 'String'>
    readonly assignedById: FieldRef<"ModuleAssignment", 'String'>
    readonly priority: FieldRef<"ModuleAssignment", 'String'>
    readonly deadline: FieldRef<"ModuleAssignment", 'DateTime'>
    readonly message: FieldRef<"ModuleAssignment", 'String'>
    readonly status: FieldRef<"ModuleAssignment", 'String'>
    readonly completedAt: FieldRef<"ModuleAssignment", 'DateTime'>
    readonly createdAt: FieldRef<"ModuleAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModuleAssignment findUnique
   */
  export type ModuleAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment findUniqueOrThrow
   */
  export type ModuleAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment findFirst
   */
  export type ModuleAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleAssignments.
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleAssignments.
     */
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * ModuleAssignment findFirstOrThrow
   */
  export type ModuleAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignment to fetch.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleAssignments.
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleAssignments.
     */
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * ModuleAssignment findMany
   */
  export type ModuleAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ModuleAssignments to fetch.
     */
    where?: ModuleAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleAssignments to fetch.
     */
    orderBy?: ModuleAssignmentOrderByWithRelationInput | ModuleAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleAssignments.
     */
    cursor?: ModuleAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleAssignments.
     */
    skip?: number
    distinct?: ModuleAssignmentScalarFieldEnum | ModuleAssignmentScalarFieldEnum[]
  }

  /**
   * ModuleAssignment create
   */
  export type ModuleAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleAssignment.
     */
    data: XOR<ModuleAssignmentCreateInput, ModuleAssignmentUncheckedCreateInput>
  }

  /**
   * ModuleAssignment createMany
   */
  export type ModuleAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleAssignments.
     */
    data: ModuleAssignmentCreateManyInput | ModuleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleAssignment createManyAndReturn
   */
  export type ModuleAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModuleAssignments.
     */
    data: ModuleAssignmentCreateManyInput | ModuleAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleAssignment update
   */
  export type ModuleAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleAssignment.
     */
    data: XOR<ModuleAssignmentUpdateInput, ModuleAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ModuleAssignment to update.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment updateMany
   */
  export type ModuleAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleAssignments.
     */
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ModuleAssignments to update
     */
    where?: ModuleAssignmentWhereInput
  }

  /**
   * ModuleAssignment upsert
   */
  export type ModuleAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleAssignment to update in case it exists.
     */
    where: ModuleAssignmentWhereUniqueInput
    /**
     * In case the ModuleAssignment found by the `where` argument doesn't exist, create a new ModuleAssignment with this data.
     */
    create: XOR<ModuleAssignmentCreateInput, ModuleAssignmentUncheckedCreateInput>
    /**
     * In case the ModuleAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleAssignmentUpdateInput, ModuleAssignmentUncheckedUpdateInput>
  }

  /**
   * ModuleAssignment delete
   */
  export type ModuleAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ModuleAssignment to delete.
     */
    where: ModuleAssignmentWhereUniqueInput
  }

  /**
   * ModuleAssignment deleteMany
   */
  export type ModuleAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleAssignments to delete
     */
    where?: ModuleAssignmentWhereInput
  }

  /**
   * ModuleAssignment without action
   */
  export type ModuleAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleAssignment
     */
    select?: ModuleAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ModuleProgress
   */

  export type AggregateModuleProgress = {
    _count: ModuleProgressCountAggregateOutputType | null
    _avg: ModuleProgressAvgAggregateOutputType | null
    _sum: ModuleProgressSumAggregateOutputType | null
    _min: ModuleProgressMinAggregateOutputType | null
    _max: ModuleProgressMaxAggregateOutputType | null
  }

  export type ModuleProgressAvgAggregateOutputType = {
    progressPercent: number | null
    timeSpentSeconds: number | null
    quizScore: number | null
    quizAttempts: number | null
  }

  export type ModuleProgressSumAggregateOutputType = {
    progressPercent: number | null
    timeSpentSeconds: number | null
    quizScore: number | null
    quizAttempts: number | null
  }

  export type ModuleProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    moduleId: string | null
    status: string | null
    progressPercent: number | null
    timeSpentSeconds: number | null
    quizScore: number | null
    quizAttempts: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    moduleId: string | null
    status: string | null
    progressPercent: number | null
    timeSpentSeconds: number | null
    quizScore: number | null
    quizAttempts: number | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleProgressCountAggregateOutputType = {
    id: number
    userId: number
    moduleId: number
    status: number
    progressPercent: number
    completedSections: number
    timeSpentSeconds: number
    quizScore: number
    quizAttempts: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleProgressAvgAggregateInputType = {
    progressPercent?: true
    timeSpentSeconds?: true
    quizScore?: true
    quizAttempts?: true
  }

  export type ModuleProgressSumAggregateInputType = {
    progressPercent?: true
    timeSpentSeconds?: true
    quizScore?: true
    quizAttempts?: true
  }

  export type ModuleProgressMinAggregateInputType = {
    id?: true
    userId?: true
    moduleId?: true
    status?: true
    progressPercent?: true
    timeSpentSeconds?: true
    quizScore?: true
    quizAttempts?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    moduleId?: true
    status?: true
    progressPercent?: true
    timeSpentSeconds?: true
    quizScore?: true
    quizAttempts?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleProgressCountAggregateInputType = {
    id?: true
    userId?: true
    moduleId?: true
    status?: true
    progressPercent?: true
    completedSections?: true
    timeSpentSeconds?: true
    quizScore?: true
    quizAttempts?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleProgress to aggregate.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleProgresses
    **/
    _count?: true | ModuleProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleProgressMaxAggregateInputType
  }

  export type GetModuleProgressAggregateType<T extends ModuleProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleProgress[P]>
      : GetScalarType<T[P], AggregateModuleProgress[P]>
  }




  export type ModuleProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleProgressWhereInput
    orderBy?: ModuleProgressOrderByWithAggregationInput | ModuleProgressOrderByWithAggregationInput[]
    by: ModuleProgressScalarFieldEnum[] | ModuleProgressScalarFieldEnum
    having?: ModuleProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleProgressCountAggregateInputType | true
    _avg?: ModuleProgressAvgAggregateInputType
    _sum?: ModuleProgressSumAggregateInputType
    _min?: ModuleProgressMinAggregateInputType
    _max?: ModuleProgressMaxAggregateInputType
  }

  export type ModuleProgressGroupByOutputType = {
    id: string
    userId: string
    moduleId: string
    status: string
    progressPercent: number
    completedSections: string[]
    timeSpentSeconds: number
    quizScore: number | null
    quizAttempts: number
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ModuleProgressCountAggregateOutputType | null
    _avg: ModuleProgressAvgAggregateOutputType | null
    _sum: ModuleProgressSumAggregateOutputType | null
    _min: ModuleProgressMinAggregateOutputType | null
    _max: ModuleProgressMaxAggregateOutputType | null
  }

  type GetModuleProgressGroupByPayload<T extends ModuleProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleProgressGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleProgressGroupByOutputType[P]>
        }
      >
    >


  export type ModuleProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    moduleId?: boolean
    status?: boolean
    progressPercent?: boolean
    completedSections?: boolean
    timeSpentSeconds?: boolean
    quizScore?: boolean
    quizAttempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleProgress"]>

  export type ModuleProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    moduleId?: boolean
    status?: boolean
    progressPercent?: boolean
    completedSections?: boolean
    timeSpentSeconds?: boolean
    quizScore?: boolean
    quizAttempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleProgress"]>

  export type ModuleProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    moduleId?: boolean
    status?: boolean
    progressPercent?: boolean
    completedSections?: boolean
    timeSpentSeconds?: boolean
    quizScore?: boolean
    quizAttempts?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ModuleProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $ModuleProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      moduleId: string
      status: string
      progressPercent: number
      completedSections: string[]
      timeSpentSeconds: number
      quizScore: number | null
      quizAttempts: number
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moduleProgress"]>
    composites: {}
  }

  type ModuleProgressGetPayload<S extends boolean | null | undefined | ModuleProgressDefaultArgs> = $Result.GetResult<Prisma.$ModuleProgressPayload, S>

  type ModuleProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleProgressCountAggregateInputType | true
    }

  export interface ModuleProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleProgress'], meta: { name: 'ModuleProgress' } }
    /**
     * Find zero or one ModuleProgress that matches the filter.
     * @param {ModuleProgressFindUniqueArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleProgressFindUniqueArgs>(args: SelectSubset<T, ModuleProgressFindUniqueArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ModuleProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleProgressFindUniqueOrThrowArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ModuleProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressFindFirstArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleProgressFindFirstArgs>(args?: SelectSubset<T, ModuleProgressFindFirstArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ModuleProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressFindFirstOrThrowArgs} args - Arguments to find a ModuleProgress
     * @example
     * // Get one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ModuleProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleProgresses
     * const moduleProgresses = await prisma.moduleProgress.findMany()
     * 
     * // Get first 10 ModuleProgresses
     * const moduleProgresses = await prisma.moduleProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleProgressWithIdOnly = await prisma.moduleProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleProgressFindManyArgs>(args?: SelectSubset<T, ModuleProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ModuleProgress.
     * @param {ModuleProgressCreateArgs} args - Arguments to create a ModuleProgress.
     * @example
     * // Create one ModuleProgress
     * const ModuleProgress = await prisma.moduleProgress.create({
     *   data: {
     *     // ... data to create a ModuleProgress
     *   }
     * })
     * 
     */
    create<T extends ModuleProgressCreateArgs>(args: SelectSubset<T, ModuleProgressCreateArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ModuleProgresses.
     * @param {ModuleProgressCreateManyArgs} args - Arguments to create many ModuleProgresses.
     * @example
     * // Create many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleProgressCreateManyArgs>(args?: SelectSubset<T, ModuleProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleProgresses and returns the data saved in the database.
     * @param {ModuleProgressCreateManyAndReturnArgs} args - Arguments to create many ModuleProgresses.
     * @example
     * // Create many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleProgresses and only return the `id`
     * const moduleProgressWithIdOnly = await prisma.moduleProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ModuleProgress.
     * @param {ModuleProgressDeleteArgs} args - Arguments to delete one ModuleProgress.
     * @example
     * // Delete one ModuleProgress
     * const ModuleProgress = await prisma.moduleProgress.delete({
     *   where: {
     *     // ... filter to delete one ModuleProgress
     *   }
     * })
     * 
     */
    delete<T extends ModuleProgressDeleteArgs>(args: SelectSubset<T, ModuleProgressDeleteArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ModuleProgress.
     * @param {ModuleProgressUpdateArgs} args - Arguments to update one ModuleProgress.
     * @example
     * // Update one ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleProgressUpdateArgs>(args: SelectSubset<T, ModuleProgressUpdateArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ModuleProgresses.
     * @param {ModuleProgressDeleteManyArgs} args - Arguments to filter ModuleProgresses to delete.
     * @example
     * // Delete a few ModuleProgresses
     * const { count } = await prisma.moduleProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleProgressDeleteManyArgs>(args?: SelectSubset<T, ModuleProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleProgresses
     * const moduleProgress = await prisma.moduleProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleProgressUpdateManyArgs>(args: SelectSubset<T, ModuleProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuleProgress.
     * @param {ModuleProgressUpsertArgs} args - Arguments to update or create a ModuleProgress.
     * @example
     * // Update or create a ModuleProgress
     * const moduleProgress = await prisma.moduleProgress.upsert({
     *   create: {
     *     // ... data to create a ModuleProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleProgress we want to update
     *   }
     * })
     */
    upsert<T extends ModuleProgressUpsertArgs>(args: SelectSubset<T, ModuleProgressUpsertArgs<ExtArgs>>): Prisma__ModuleProgressClient<$Result.GetResult<Prisma.$ModuleProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ModuleProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressCountArgs} args - Arguments to filter ModuleProgresses to count.
     * @example
     * // Count the number of ModuleProgresses
     * const count = await prisma.moduleProgress.count({
     *   where: {
     *     // ... the filter for the ModuleProgresses we want to count
     *   }
     * })
    **/
    count<T extends ModuleProgressCountArgs>(
      args?: Subset<T, ModuleProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleProgressAggregateArgs>(args: Subset<T, ModuleProgressAggregateArgs>): Prisma.PrismaPromise<GetModuleProgressAggregateType<T>>

    /**
     * Group by ModuleProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleProgressGroupByArgs['orderBy'] }
        : { orderBy?: ModuleProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleProgress model
   */
  readonly fields: ModuleProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleProgress model
   */ 
  interface ModuleProgressFieldRefs {
    readonly id: FieldRef<"ModuleProgress", 'String'>
    readonly userId: FieldRef<"ModuleProgress", 'String'>
    readonly moduleId: FieldRef<"ModuleProgress", 'String'>
    readonly status: FieldRef<"ModuleProgress", 'String'>
    readonly progressPercent: FieldRef<"ModuleProgress", 'Int'>
    readonly completedSections: FieldRef<"ModuleProgress", 'String[]'>
    readonly timeSpentSeconds: FieldRef<"ModuleProgress", 'Int'>
    readonly quizScore: FieldRef<"ModuleProgress", 'Float'>
    readonly quizAttempts: FieldRef<"ModuleProgress", 'Int'>
    readonly startedAt: FieldRef<"ModuleProgress", 'DateTime'>
    readonly completedAt: FieldRef<"ModuleProgress", 'DateTime'>
    readonly createdAt: FieldRef<"ModuleProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"ModuleProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModuleProgress findUnique
   */
  export type ModuleProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress findUniqueOrThrow
   */
  export type ModuleProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress findFirst
   */
  export type ModuleProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleProgresses.
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleProgresses.
     */
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * ModuleProgress findFirstOrThrow
   */
  export type ModuleProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgress to fetch.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleProgresses.
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleProgresses.
     */
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * ModuleProgress findMany
   */
  export type ModuleProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter, which ModuleProgresses to fetch.
     */
    where?: ModuleProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleProgresses to fetch.
     */
    orderBy?: ModuleProgressOrderByWithRelationInput | ModuleProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleProgresses.
     */
    cursor?: ModuleProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleProgresses.
     */
    skip?: number
    distinct?: ModuleProgressScalarFieldEnum | ModuleProgressScalarFieldEnum[]
  }

  /**
   * ModuleProgress create
   */
  export type ModuleProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleProgress.
     */
    data: XOR<ModuleProgressCreateInput, ModuleProgressUncheckedCreateInput>
  }

  /**
   * ModuleProgress createMany
   */
  export type ModuleProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleProgresses.
     */
    data: ModuleProgressCreateManyInput | ModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleProgress createManyAndReturn
   */
  export type ModuleProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ModuleProgresses.
     */
    data: ModuleProgressCreateManyInput | ModuleProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleProgress update
   */
  export type ModuleProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleProgress.
     */
    data: XOR<ModuleProgressUpdateInput, ModuleProgressUncheckedUpdateInput>
    /**
     * Choose, which ModuleProgress to update.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress updateMany
   */
  export type ModuleProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleProgresses.
     */
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyInput>
    /**
     * Filter which ModuleProgresses to update
     */
    where?: ModuleProgressWhereInput
  }

  /**
   * ModuleProgress upsert
   */
  export type ModuleProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleProgress to update in case it exists.
     */
    where: ModuleProgressWhereUniqueInput
    /**
     * In case the ModuleProgress found by the `where` argument doesn't exist, create a new ModuleProgress with this data.
     */
    create: XOR<ModuleProgressCreateInput, ModuleProgressUncheckedCreateInput>
    /**
     * In case the ModuleProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleProgressUpdateInput, ModuleProgressUncheckedUpdateInput>
  }

  /**
   * ModuleProgress delete
   */
  export type ModuleProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
    /**
     * Filter which ModuleProgress to delete.
     */
    where: ModuleProgressWhereUniqueInput
  }

  /**
   * ModuleProgress deleteMany
   */
  export type ModuleProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleProgresses to delete
     */
    where?: ModuleProgressWhereInput
  }

  /**
   * ModuleProgress without action
   */
  export type ModuleProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleProgress
     */
    select?: ModuleProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleProgressInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentTemplate
   */

  export type AggregateAssessmentTemplate = {
    _count: AssessmentTemplateCountAggregateOutputType | null
    _avg: AssessmentTemplateAvgAggregateOutputType | null
    _sum: AssessmentTemplateSumAggregateOutputType | null
    _min: AssessmentTemplateMinAggregateOutputType | null
    _max: AssessmentTemplateMaxAggregateOutputType | null
  }

  export type AssessmentTemplateAvgAggregateOutputType = {
    estimatedDuration: number | null
  }

  export type AssessmentTemplateSumAggregateOutputType = {
    estimatedDuration: number | null
  }

  export type AssessmentTemplateMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    certification: string | null
    version: string | null
    estimatedDuration: number | null
    scoringMethod: string | null
    status: string | null
    isDemo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentTemplateMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    name: string | null
    description: string | null
    certification: string | null
    version: string | null
    estimatedDuration: number | null
    scoringMethod: string | null
    status: string | null
    isDemo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssessmentTemplateCountAggregateOutputType = {
    id: number
    organizationId: number
    name: number
    description: number
    certification: number
    version: number
    estimatedDuration: number
    sections: number
    scoringMethod: number
    maturityLevels: number
    status: number
    isDemo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssessmentTemplateAvgAggregateInputType = {
    estimatedDuration?: true
  }

  export type AssessmentTemplateSumAggregateInputType = {
    estimatedDuration?: true
  }

  export type AssessmentTemplateMinAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    certification?: true
    version?: true
    estimatedDuration?: true
    scoringMethod?: true
    status?: true
    isDemo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentTemplateMaxAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    certification?: true
    version?: true
    estimatedDuration?: true
    scoringMethod?: true
    status?: true
    isDemo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssessmentTemplateCountAggregateInputType = {
    id?: true
    organizationId?: true
    name?: true
    description?: true
    certification?: true
    version?: true
    estimatedDuration?: true
    sections?: true
    scoringMethod?: true
    maturityLevels?: true
    status?: true
    isDemo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssessmentTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentTemplate to aggregate.
     */
    where?: AssessmentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTemplates to fetch.
     */
    orderBy?: AssessmentTemplateOrderByWithRelationInput | AssessmentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentTemplates
    **/
    _count?: true | AssessmentTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentTemplateMaxAggregateInputType
  }

  export type GetAssessmentTemplateAggregateType<T extends AssessmentTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentTemplate[P]>
      : GetScalarType<T[P], AggregateAssessmentTemplate[P]>
  }




  export type AssessmentTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentTemplateWhereInput
    orderBy?: AssessmentTemplateOrderByWithAggregationInput | AssessmentTemplateOrderByWithAggregationInput[]
    by: AssessmentTemplateScalarFieldEnum[] | AssessmentTemplateScalarFieldEnum
    having?: AssessmentTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentTemplateCountAggregateInputType | true
    _avg?: AssessmentTemplateAvgAggregateInputType
    _sum?: AssessmentTemplateSumAggregateInputType
    _min?: AssessmentTemplateMinAggregateInputType
    _max?: AssessmentTemplateMaxAggregateInputType
  }

  export type AssessmentTemplateGroupByOutputType = {
    id: string
    organizationId: string | null
    name: string
    description: string | null
    certification: string
    version: string
    estimatedDuration: number
    sections: JsonValue
    scoringMethod: string
    maturityLevels: JsonValue
    status: string
    isDemo: boolean
    createdAt: Date
    updatedAt: Date
    _count: AssessmentTemplateCountAggregateOutputType | null
    _avg: AssessmentTemplateAvgAggregateOutputType | null
    _sum: AssessmentTemplateSumAggregateOutputType | null
    _min: AssessmentTemplateMinAggregateOutputType | null
    _max: AssessmentTemplateMaxAggregateOutputType | null
  }

  type GetAssessmentTemplateGroupByPayload<T extends AssessmentTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentTemplateGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    certification?: boolean
    version?: boolean
    estimatedDuration?: boolean
    sections?: boolean
    scoringMethod?: boolean
    maturityLevels?: boolean
    status?: boolean
    isDemo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | AssessmentTemplate$organizationArgs<ExtArgs>
    sessions?: boolean | AssessmentTemplate$sessionsArgs<ExtArgs>
    _count?: boolean | AssessmentTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentTemplate"]>

  export type AssessmentTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    certification?: boolean
    version?: boolean
    estimatedDuration?: boolean
    sections?: boolean
    scoringMethod?: boolean
    maturityLevels?: boolean
    status?: boolean
    isDemo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | AssessmentTemplate$organizationArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentTemplate"]>

  export type AssessmentTemplateSelectScalar = {
    id?: boolean
    organizationId?: boolean
    name?: boolean
    description?: boolean
    certification?: boolean
    version?: boolean
    estimatedDuration?: boolean
    sections?: boolean
    scoringMethod?: boolean
    maturityLevels?: boolean
    status?: boolean
    isDemo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssessmentTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | AssessmentTemplate$organizationArgs<ExtArgs>
    sessions?: boolean | AssessmentTemplate$sessionsArgs<ExtArgs>
    _count?: boolean | AssessmentTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssessmentTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | AssessmentTemplate$organizationArgs<ExtArgs>
  }

  export type $AssessmentTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentTemplate"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      sessions: Prisma.$AssessmentSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string | null
      name: string
      description: string | null
      certification: string
      version: string
      estimatedDuration: number
      sections: Prisma.JsonValue
      scoringMethod: string
      maturityLevels: Prisma.JsonValue
      status: string
      isDemo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assessmentTemplate"]>
    composites: {}
  }

  type AssessmentTemplateGetPayload<S extends boolean | null | undefined | AssessmentTemplateDefaultArgs> = $Result.GetResult<Prisma.$AssessmentTemplatePayload, S>

  type AssessmentTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentTemplateCountAggregateInputType | true
    }

  export interface AssessmentTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentTemplate'], meta: { name: 'AssessmentTemplate' } }
    /**
     * Find zero or one AssessmentTemplate that matches the filter.
     * @param {AssessmentTemplateFindUniqueArgs} args - Arguments to find a AssessmentTemplate
     * @example
     * // Get one AssessmentTemplate
     * const assessmentTemplate = await prisma.assessmentTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentTemplateFindUniqueArgs>(args: SelectSubset<T, AssessmentTemplateFindUniqueArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssessmentTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentTemplateFindUniqueOrThrowArgs} args - Arguments to find a AssessmentTemplate
     * @example
     * // Get one AssessmentTemplate
     * const assessmentTemplate = await prisma.assessmentTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssessmentTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateFindFirstArgs} args - Arguments to find a AssessmentTemplate
     * @example
     * // Get one AssessmentTemplate
     * const assessmentTemplate = await prisma.assessmentTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentTemplateFindFirstArgs>(args?: SelectSubset<T, AssessmentTemplateFindFirstArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssessmentTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateFindFirstOrThrowArgs} args - Arguments to find a AssessmentTemplate
     * @example
     * // Get one AssessmentTemplate
     * const assessmentTemplate = await prisma.assessmentTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssessmentTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentTemplates
     * const assessmentTemplates = await prisma.assessmentTemplate.findMany()
     * 
     * // Get first 10 AssessmentTemplates
     * const assessmentTemplates = await prisma.assessmentTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentTemplateWithIdOnly = await prisma.assessmentTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentTemplateFindManyArgs>(args?: SelectSubset<T, AssessmentTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssessmentTemplate.
     * @param {AssessmentTemplateCreateArgs} args - Arguments to create a AssessmentTemplate.
     * @example
     * // Create one AssessmentTemplate
     * const AssessmentTemplate = await prisma.assessmentTemplate.create({
     *   data: {
     *     // ... data to create a AssessmentTemplate
     *   }
     * })
     * 
     */
    create<T extends AssessmentTemplateCreateArgs>(args: SelectSubset<T, AssessmentTemplateCreateArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssessmentTemplates.
     * @param {AssessmentTemplateCreateManyArgs} args - Arguments to create many AssessmentTemplates.
     * @example
     * // Create many AssessmentTemplates
     * const assessmentTemplate = await prisma.assessmentTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentTemplateCreateManyArgs>(args?: SelectSubset<T, AssessmentTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssessmentTemplates and returns the data saved in the database.
     * @param {AssessmentTemplateCreateManyAndReturnArgs} args - Arguments to create many AssessmentTemplates.
     * @example
     * // Create many AssessmentTemplates
     * const assessmentTemplate = await prisma.assessmentTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssessmentTemplates and only return the `id`
     * const assessmentTemplateWithIdOnly = await prisma.assessmentTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssessmentTemplate.
     * @param {AssessmentTemplateDeleteArgs} args - Arguments to delete one AssessmentTemplate.
     * @example
     * // Delete one AssessmentTemplate
     * const AssessmentTemplate = await prisma.assessmentTemplate.delete({
     *   where: {
     *     // ... filter to delete one AssessmentTemplate
     *   }
     * })
     * 
     */
    delete<T extends AssessmentTemplateDeleteArgs>(args: SelectSubset<T, AssessmentTemplateDeleteArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssessmentTemplate.
     * @param {AssessmentTemplateUpdateArgs} args - Arguments to update one AssessmentTemplate.
     * @example
     * // Update one AssessmentTemplate
     * const assessmentTemplate = await prisma.assessmentTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentTemplateUpdateArgs>(args: SelectSubset<T, AssessmentTemplateUpdateArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssessmentTemplates.
     * @param {AssessmentTemplateDeleteManyArgs} args - Arguments to filter AssessmentTemplates to delete.
     * @example
     * // Delete a few AssessmentTemplates
     * const { count } = await prisma.assessmentTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentTemplateDeleteManyArgs>(args?: SelectSubset<T, AssessmentTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentTemplates
     * const assessmentTemplate = await prisma.assessmentTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentTemplateUpdateManyArgs>(args: SelectSubset<T, AssessmentTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssessmentTemplate.
     * @param {AssessmentTemplateUpsertArgs} args - Arguments to update or create a AssessmentTemplate.
     * @example
     * // Update or create a AssessmentTemplate
     * const assessmentTemplate = await prisma.assessmentTemplate.upsert({
     *   create: {
     *     // ... data to create a AssessmentTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentTemplate we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentTemplateUpsertArgs>(args: SelectSubset<T, AssessmentTemplateUpsertArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssessmentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateCountArgs} args - Arguments to filter AssessmentTemplates to count.
     * @example
     * // Count the number of AssessmentTemplates
     * const count = await prisma.assessmentTemplate.count({
     *   where: {
     *     // ... the filter for the AssessmentTemplates we want to count
     *   }
     * })
    **/
    count<T extends AssessmentTemplateCountArgs>(
      args?: Subset<T, AssessmentTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentTemplateAggregateArgs>(args: Subset<T, AssessmentTemplateAggregateArgs>): Prisma.PrismaPromise<GetAssessmentTemplateAggregateType<T>>

    /**
     * Group by AssessmentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentTemplateGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentTemplate model
   */
  readonly fields: AssessmentTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends AssessmentTemplate$organizationArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentTemplate$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends AssessmentTemplate$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentTemplate$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentTemplate model
   */ 
  interface AssessmentTemplateFieldRefs {
    readonly id: FieldRef<"AssessmentTemplate", 'String'>
    readonly organizationId: FieldRef<"AssessmentTemplate", 'String'>
    readonly name: FieldRef<"AssessmentTemplate", 'String'>
    readonly description: FieldRef<"AssessmentTemplate", 'String'>
    readonly certification: FieldRef<"AssessmentTemplate", 'String'>
    readonly version: FieldRef<"AssessmentTemplate", 'String'>
    readonly estimatedDuration: FieldRef<"AssessmentTemplate", 'Int'>
    readonly sections: FieldRef<"AssessmentTemplate", 'Json'>
    readonly scoringMethod: FieldRef<"AssessmentTemplate", 'String'>
    readonly maturityLevels: FieldRef<"AssessmentTemplate", 'Json'>
    readonly status: FieldRef<"AssessmentTemplate", 'String'>
    readonly isDemo: FieldRef<"AssessmentTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"AssessmentTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"AssessmentTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentTemplate findUnique
   */
  export type AssessmentTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTemplate to fetch.
     */
    where: AssessmentTemplateWhereUniqueInput
  }

  /**
   * AssessmentTemplate findUniqueOrThrow
   */
  export type AssessmentTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTemplate to fetch.
     */
    where: AssessmentTemplateWhereUniqueInput
  }

  /**
   * AssessmentTemplate findFirst
   */
  export type AssessmentTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTemplate to fetch.
     */
    where?: AssessmentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTemplates to fetch.
     */
    orderBy?: AssessmentTemplateOrderByWithRelationInput | AssessmentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentTemplates.
     */
    cursor?: AssessmentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentTemplates.
     */
    distinct?: AssessmentTemplateScalarFieldEnum | AssessmentTemplateScalarFieldEnum[]
  }

  /**
   * AssessmentTemplate findFirstOrThrow
   */
  export type AssessmentTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTemplate to fetch.
     */
    where?: AssessmentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTemplates to fetch.
     */
    orderBy?: AssessmentTemplateOrderByWithRelationInput | AssessmentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentTemplates.
     */
    cursor?: AssessmentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentTemplates.
     */
    distinct?: AssessmentTemplateScalarFieldEnum | AssessmentTemplateScalarFieldEnum[]
  }

  /**
   * AssessmentTemplate findMany
   */
  export type AssessmentTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentTemplates to fetch.
     */
    where?: AssessmentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentTemplates to fetch.
     */
    orderBy?: AssessmentTemplateOrderByWithRelationInput | AssessmentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentTemplates.
     */
    cursor?: AssessmentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentTemplates.
     */
    skip?: number
    distinct?: AssessmentTemplateScalarFieldEnum | AssessmentTemplateScalarFieldEnum[]
  }

  /**
   * AssessmentTemplate create
   */
  export type AssessmentTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentTemplate.
     */
    data: XOR<AssessmentTemplateCreateInput, AssessmentTemplateUncheckedCreateInput>
  }

  /**
   * AssessmentTemplate createMany
   */
  export type AssessmentTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentTemplates.
     */
    data: AssessmentTemplateCreateManyInput | AssessmentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentTemplate createManyAndReturn
   */
  export type AssessmentTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssessmentTemplates.
     */
    data: AssessmentTemplateCreateManyInput | AssessmentTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentTemplate update
   */
  export type AssessmentTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentTemplate.
     */
    data: XOR<AssessmentTemplateUpdateInput, AssessmentTemplateUncheckedUpdateInput>
    /**
     * Choose, which AssessmentTemplate to update.
     */
    where: AssessmentTemplateWhereUniqueInput
  }

  /**
   * AssessmentTemplate updateMany
   */
  export type AssessmentTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentTemplates.
     */
    data: XOR<AssessmentTemplateUpdateManyMutationInput, AssessmentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentTemplates to update
     */
    where?: AssessmentTemplateWhereInput
  }

  /**
   * AssessmentTemplate upsert
   */
  export type AssessmentTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentTemplate to update in case it exists.
     */
    where: AssessmentTemplateWhereUniqueInput
    /**
     * In case the AssessmentTemplate found by the `where` argument doesn't exist, create a new AssessmentTemplate with this data.
     */
    create: XOR<AssessmentTemplateCreateInput, AssessmentTemplateUncheckedCreateInput>
    /**
     * In case the AssessmentTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentTemplateUpdateInput, AssessmentTemplateUncheckedUpdateInput>
  }

  /**
   * AssessmentTemplate delete
   */
  export type AssessmentTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
    /**
     * Filter which AssessmentTemplate to delete.
     */
    where: AssessmentTemplateWhereUniqueInput
  }

  /**
   * AssessmentTemplate deleteMany
   */
  export type AssessmentTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentTemplates to delete
     */
    where?: AssessmentTemplateWhereInput
  }

  /**
   * AssessmentTemplate.organization
   */
  export type AssessmentTemplate$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * AssessmentTemplate.sessions
   */
  export type AssessmentTemplate$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    where?: AssessmentSessionWhereInput
    orderBy?: AssessmentSessionOrderByWithRelationInput | AssessmentSessionOrderByWithRelationInput[]
    cursor?: AssessmentSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentSessionScalarFieldEnum | AssessmentSessionScalarFieldEnum[]
  }

  /**
   * AssessmentTemplate without action
   */
  export type AssessmentTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentTemplate
     */
    select?: AssessmentTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentTemplateInclude<ExtArgs> | null
  }


  /**
   * Model AssessmentSession
   */

  export type AggregateAssessmentSession = {
    _count: AssessmentSessionCountAggregateOutputType | null
    _avg: AssessmentSessionAvgAggregateOutputType | null
    _sum: AssessmentSessionSumAggregateOutputType | null
    _min: AssessmentSessionMinAggregateOutputType | null
    _max: AssessmentSessionMaxAggregateOutputType | null
  }

  export type AssessmentSessionAvgAggregateOutputType = {
    overallScore: number | null
  }

  export type AssessmentSessionSumAggregateOutputType = {
    overallScore: number | null
  }

  export type AssessmentSessionMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    userId: string | null
    email: string | null
    companyName: string | null
    industry: string | null
    employeeCount: string | null
    overallScore: number | null
    maturityLevel: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    convertedToSignup: boolean | null
    pdfDownloaded: boolean | null
    createdAt: Date | null
  }

  export type AssessmentSessionMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    userId: string | null
    email: string | null
    companyName: string | null
    industry: string | null
    employeeCount: string | null
    overallScore: number | null
    maturityLevel: string | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    convertedToSignup: boolean | null
    pdfDownloaded: boolean | null
    createdAt: Date | null
  }

  export type AssessmentSessionCountAggregateOutputType = {
    id: number
    templateId: number
    userId: number
    email: number
    companyName: number
    industry: number
    employeeCount: number
    answers: number
    sectionScores: number
    overallScore: number
    maturityLevel: number
    gapAnalysis: number
    recommendations: number
    status: number
    startedAt: number
    completedAt: number
    convertedToSignup: number
    pdfDownloaded: number
    createdAt: number
    _all: number
  }


  export type AssessmentSessionAvgAggregateInputType = {
    overallScore?: true
  }

  export type AssessmentSessionSumAggregateInputType = {
    overallScore?: true
  }

  export type AssessmentSessionMinAggregateInputType = {
    id?: true
    templateId?: true
    userId?: true
    email?: true
    companyName?: true
    industry?: true
    employeeCount?: true
    overallScore?: true
    maturityLevel?: true
    status?: true
    startedAt?: true
    completedAt?: true
    convertedToSignup?: true
    pdfDownloaded?: true
    createdAt?: true
  }

  export type AssessmentSessionMaxAggregateInputType = {
    id?: true
    templateId?: true
    userId?: true
    email?: true
    companyName?: true
    industry?: true
    employeeCount?: true
    overallScore?: true
    maturityLevel?: true
    status?: true
    startedAt?: true
    completedAt?: true
    convertedToSignup?: true
    pdfDownloaded?: true
    createdAt?: true
  }

  export type AssessmentSessionCountAggregateInputType = {
    id?: true
    templateId?: true
    userId?: true
    email?: true
    companyName?: true
    industry?: true
    employeeCount?: true
    answers?: true
    sectionScores?: true
    overallScore?: true
    maturityLevel?: true
    gapAnalysis?: true
    recommendations?: true
    status?: true
    startedAt?: true
    completedAt?: true
    convertedToSignup?: true
    pdfDownloaded?: true
    createdAt?: true
    _all?: true
  }

  export type AssessmentSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentSession to aggregate.
     */
    where?: AssessmentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentSessions to fetch.
     */
    orderBy?: AssessmentSessionOrderByWithRelationInput | AssessmentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssessmentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssessmentSessions
    **/
    _count?: true | AssessmentSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentSessionMaxAggregateInputType
  }

  export type GetAssessmentSessionAggregateType<T extends AssessmentSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessmentSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessmentSession[P]>
      : GetScalarType<T[P], AggregateAssessmentSession[P]>
  }




  export type AssessmentSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssessmentSessionWhereInput
    orderBy?: AssessmentSessionOrderByWithAggregationInput | AssessmentSessionOrderByWithAggregationInput[]
    by: AssessmentSessionScalarFieldEnum[] | AssessmentSessionScalarFieldEnum
    having?: AssessmentSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentSessionCountAggregateInputType | true
    _avg?: AssessmentSessionAvgAggregateInputType
    _sum?: AssessmentSessionSumAggregateInputType
    _min?: AssessmentSessionMinAggregateInputType
    _max?: AssessmentSessionMaxAggregateInputType
  }

  export type AssessmentSessionGroupByOutputType = {
    id: string
    templateId: string
    userId: string | null
    email: string | null
    companyName: string | null
    industry: string | null
    employeeCount: string | null
    answers: JsonValue | null
    sectionScores: JsonValue | null
    overallScore: number | null
    maturityLevel: string | null
    gapAnalysis: JsonValue | null
    recommendations: JsonValue | null
    status: string
    startedAt: Date
    completedAt: Date | null
    convertedToSignup: boolean
    pdfDownloaded: boolean
    createdAt: Date
    _count: AssessmentSessionCountAggregateOutputType | null
    _avg: AssessmentSessionAvgAggregateOutputType | null
    _sum: AssessmentSessionSumAggregateOutputType | null
    _min: AssessmentSessionMinAggregateOutputType | null
    _max: AssessmentSessionMaxAggregateOutputType | null
  }

  type GetAssessmentSessionGroupByPayload<T extends AssessmentSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentSessionGroupByOutputType[P]>
        }
      >
    >


  export type AssessmentSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    userId?: boolean
    email?: boolean
    companyName?: boolean
    industry?: boolean
    employeeCount?: boolean
    answers?: boolean
    sectionScores?: boolean
    overallScore?: boolean
    maturityLevel?: boolean
    gapAnalysis?: boolean
    recommendations?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: boolean
    template?: boolean | AssessmentTemplateDefaultArgs<ExtArgs>
    user?: boolean | AssessmentSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentSession"]>

  export type AssessmentSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    userId?: boolean
    email?: boolean
    companyName?: boolean
    industry?: boolean
    employeeCount?: boolean
    answers?: boolean
    sectionScores?: boolean
    overallScore?: boolean
    maturityLevel?: boolean
    gapAnalysis?: boolean
    recommendations?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: boolean
    template?: boolean | AssessmentTemplateDefaultArgs<ExtArgs>
    user?: boolean | AssessmentSession$userArgs<ExtArgs>
  }, ExtArgs["result"]["assessmentSession"]>

  export type AssessmentSessionSelectScalar = {
    id?: boolean
    templateId?: boolean
    userId?: boolean
    email?: boolean
    companyName?: boolean
    industry?: boolean
    employeeCount?: boolean
    answers?: boolean
    sectionScores?: boolean
    overallScore?: boolean
    maturityLevel?: boolean
    gapAnalysis?: boolean
    recommendations?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: boolean
  }

  export type AssessmentSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | AssessmentTemplateDefaultArgs<ExtArgs>
    user?: boolean | AssessmentSession$userArgs<ExtArgs>
  }
  export type AssessmentSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | AssessmentTemplateDefaultArgs<ExtArgs>
    user?: boolean | AssessmentSession$userArgs<ExtArgs>
  }

  export type $AssessmentSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssessmentSession"
    objects: {
      template: Prisma.$AssessmentTemplatePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateId: string
      userId: string | null
      email: string | null
      companyName: string | null
      industry: string | null
      employeeCount: string | null
      answers: Prisma.JsonValue | null
      sectionScores: Prisma.JsonValue | null
      overallScore: number | null
      maturityLevel: string | null
      gapAnalysis: Prisma.JsonValue | null
      recommendations: Prisma.JsonValue | null
      status: string
      startedAt: Date
      completedAt: Date | null
      convertedToSignup: boolean
      pdfDownloaded: boolean
      createdAt: Date
    }, ExtArgs["result"]["assessmentSession"]>
    composites: {}
  }

  type AssessmentSessionGetPayload<S extends boolean | null | undefined | AssessmentSessionDefaultArgs> = $Result.GetResult<Prisma.$AssessmentSessionPayload, S>

  type AssessmentSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssessmentSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssessmentSessionCountAggregateInputType | true
    }

  export interface AssessmentSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssessmentSession'], meta: { name: 'AssessmentSession' } }
    /**
     * Find zero or one AssessmentSession that matches the filter.
     * @param {AssessmentSessionFindUniqueArgs} args - Arguments to find a AssessmentSession
     * @example
     * // Get one AssessmentSession
     * const assessmentSession = await prisma.assessmentSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssessmentSessionFindUniqueArgs>(args: SelectSubset<T, AssessmentSessionFindUniqueArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssessmentSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssessmentSessionFindUniqueOrThrowArgs} args - Arguments to find a AssessmentSession
     * @example
     * // Get one AssessmentSession
     * const assessmentSession = await prisma.assessmentSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssessmentSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssessmentSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssessmentSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionFindFirstArgs} args - Arguments to find a AssessmentSession
     * @example
     * // Get one AssessmentSession
     * const assessmentSession = await prisma.assessmentSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssessmentSessionFindFirstArgs>(args?: SelectSubset<T, AssessmentSessionFindFirstArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssessmentSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionFindFirstOrThrowArgs} args - Arguments to find a AssessmentSession
     * @example
     * // Get one AssessmentSession
     * const assessmentSession = await prisma.assessmentSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssessmentSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssessmentSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssessmentSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssessmentSessions
     * const assessmentSessions = await prisma.assessmentSession.findMany()
     * 
     * // Get first 10 AssessmentSessions
     * const assessmentSessions = await prisma.assessmentSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentSessionWithIdOnly = await prisma.assessmentSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssessmentSessionFindManyArgs>(args?: SelectSubset<T, AssessmentSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssessmentSession.
     * @param {AssessmentSessionCreateArgs} args - Arguments to create a AssessmentSession.
     * @example
     * // Create one AssessmentSession
     * const AssessmentSession = await prisma.assessmentSession.create({
     *   data: {
     *     // ... data to create a AssessmentSession
     *   }
     * })
     * 
     */
    create<T extends AssessmentSessionCreateArgs>(args: SelectSubset<T, AssessmentSessionCreateArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssessmentSessions.
     * @param {AssessmentSessionCreateManyArgs} args - Arguments to create many AssessmentSessions.
     * @example
     * // Create many AssessmentSessions
     * const assessmentSession = await prisma.assessmentSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssessmentSessionCreateManyArgs>(args?: SelectSubset<T, AssessmentSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssessmentSessions and returns the data saved in the database.
     * @param {AssessmentSessionCreateManyAndReturnArgs} args - Arguments to create many AssessmentSessions.
     * @example
     * // Create many AssessmentSessions
     * const assessmentSession = await prisma.assessmentSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssessmentSessions and only return the `id`
     * const assessmentSessionWithIdOnly = await prisma.assessmentSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssessmentSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssessmentSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssessmentSession.
     * @param {AssessmentSessionDeleteArgs} args - Arguments to delete one AssessmentSession.
     * @example
     * // Delete one AssessmentSession
     * const AssessmentSession = await prisma.assessmentSession.delete({
     *   where: {
     *     // ... filter to delete one AssessmentSession
     *   }
     * })
     * 
     */
    delete<T extends AssessmentSessionDeleteArgs>(args: SelectSubset<T, AssessmentSessionDeleteArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssessmentSession.
     * @param {AssessmentSessionUpdateArgs} args - Arguments to update one AssessmentSession.
     * @example
     * // Update one AssessmentSession
     * const assessmentSession = await prisma.assessmentSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssessmentSessionUpdateArgs>(args: SelectSubset<T, AssessmentSessionUpdateArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssessmentSessions.
     * @param {AssessmentSessionDeleteManyArgs} args - Arguments to filter AssessmentSessions to delete.
     * @example
     * // Delete a few AssessmentSessions
     * const { count } = await prisma.assessmentSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssessmentSessionDeleteManyArgs>(args?: SelectSubset<T, AssessmentSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssessmentSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssessmentSessions
     * const assessmentSession = await prisma.assessmentSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssessmentSessionUpdateManyArgs>(args: SelectSubset<T, AssessmentSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssessmentSession.
     * @param {AssessmentSessionUpsertArgs} args - Arguments to update or create a AssessmentSession.
     * @example
     * // Update or create a AssessmentSession
     * const assessmentSession = await prisma.assessmentSession.upsert({
     *   create: {
     *     // ... data to create a AssessmentSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssessmentSession we want to update
     *   }
     * })
     */
    upsert<T extends AssessmentSessionUpsertArgs>(args: SelectSubset<T, AssessmentSessionUpsertArgs<ExtArgs>>): Prisma__AssessmentSessionClient<$Result.GetResult<Prisma.$AssessmentSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssessmentSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionCountArgs} args - Arguments to filter AssessmentSessions to count.
     * @example
     * // Count the number of AssessmentSessions
     * const count = await prisma.assessmentSession.count({
     *   where: {
     *     // ... the filter for the AssessmentSessions we want to count
     *   }
     * })
    **/
    count<T extends AssessmentSessionCountArgs>(
      args?: Subset<T, AssessmentSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssessmentSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentSessionAggregateArgs>(args: Subset<T, AssessmentSessionAggregateArgs>): Prisma.PrismaPromise<GetAssessmentSessionAggregateType<T>>

    /**
     * Group by AssessmentSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssessmentSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssessmentSessionGroupByArgs['orderBy'] }
        : { orderBy?: AssessmentSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssessmentSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssessmentSession model
   */
  readonly fields: AssessmentSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssessmentSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssessmentSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends AssessmentTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentTemplateDefaultArgs<ExtArgs>>): Prisma__AssessmentTemplateClient<$Result.GetResult<Prisma.$AssessmentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends AssessmentSession$userArgs<ExtArgs> = {}>(args?: Subset<T, AssessmentSession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssessmentSession model
   */ 
  interface AssessmentSessionFieldRefs {
    readonly id: FieldRef<"AssessmentSession", 'String'>
    readonly templateId: FieldRef<"AssessmentSession", 'String'>
    readonly userId: FieldRef<"AssessmentSession", 'String'>
    readonly email: FieldRef<"AssessmentSession", 'String'>
    readonly companyName: FieldRef<"AssessmentSession", 'String'>
    readonly industry: FieldRef<"AssessmentSession", 'String'>
    readonly employeeCount: FieldRef<"AssessmentSession", 'String'>
    readonly answers: FieldRef<"AssessmentSession", 'Json'>
    readonly sectionScores: FieldRef<"AssessmentSession", 'Json'>
    readonly overallScore: FieldRef<"AssessmentSession", 'Float'>
    readonly maturityLevel: FieldRef<"AssessmentSession", 'String'>
    readonly gapAnalysis: FieldRef<"AssessmentSession", 'Json'>
    readonly recommendations: FieldRef<"AssessmentSession", 'Json'>
    readonly status: FieldRef<"AssessmentSession", 'String'>
    readonly startedAt: FieldRef<"AssessmentSession", 'DateTime'>
    readonly completedAt: FieldRef<"AssessmentSession", 'DateTime'>
    readonly convertedToSignup: FieldRef<"AssessmentSession", 'Boolean'>
    readonly pdfDownloaded: FieldRef<"AssessmentSession", 'Boolean'>
    readonly createdAt: FieldRef<"AssessmentSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssessmentSession findUnique
   */
  export type AssessmentSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentSession to fetch.
     */
    where: AssessmentSessionWhereUniqueInput
  }

  /**
   * AssessmentSession findUniqueOrThrow
   */
  export type AssessmentSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentSession to fetch.
     */
    where: AssessmentSessionWhereUniqueInput
  }

  /**
   * AssessmentSession findFirst
   */
  export type AssessmentSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentSession to fetch.
     */
    where?: AssessmentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentSessions to fetch.
     */
    orderBy?: AssessmentSessionOrderByWithRelationInput | AssessmentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentSessions.
     */
    cursor?: AssessmentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentSessions.
     */
    distinct?: AssessmentSessionScalarFieldEnum | AssessmentSessionScalarFieldEnum[]
  }

  /**
   * AssessmentSession findFirstOrThrow
   */
  export type AssessmentSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentSession to fetch.
     */
    where?: AssessmentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentSessions to fetch.
     */
    orderBy?: AssessmentSessionOrderByWithRelationInput | AssessmentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssessmentSessions.
     */
    cursor?: AssessmentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssessmentSessions.
     */
    distinct?: AssessmentSessionScalarFieldEnum | AssessmentSessionScalarFieldEnum[]
  }

  /**
   * AssessmentSession findMany
   */
  export type AssessmentSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * Filter, which AssessmentSessions to fetch.
     */
    where?: AssessmentSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssessmentSessions to fetch.
     */
    orderBy?: AssessmentSessionOrderByWithRelationInput | AssessmentSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssessmentSessions.
     */
    cursor?: AssessmentSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssessmentSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssessmentSessions.
     */
    skip?: number
    distinct?: AssessmentSessionScalarFieldEnum | AssessmentSessionScalarFieldEnum[]
  }

  /**
   * AssessmentSession create
   */
  export type AssessmentSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssessmentSession.
     */
    data: XOR<AssessmentSessionCreateInput, AssessmentSessionUncheckedCreateInput>
  }

  /**
   * AssessmentSession createMany
   */
  export type AssessmentSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssessmentSessions.
     */
    data: AssessmentSessionCreateManyInput | AssessmentSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssessmentSession createManyAndReturn
   */
  export type AssessmentSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssessmentSessions.
     */
    data: AssessmentSessionCreateManyInput | AssessmentSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssessmentSession update
   */
  export type AssessmentSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssessmentSession.
     */
    data: XOR<AssessmentSessionUpdateInput, AssessmentSessionUncheckedUpdateInput>
    /**
     * Choose, which AssessmentSession to update.
     */
    where: AssessmentSessionWhereUniqueInput
  }

  /**
   * AssessmentSession updateMany
   */
  export type AssessmentSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssessmentSessions.
     */
    data: XOR<AssessmentSessionUpdateManyMutationInput, AssessmentSessionUncheckedUpdateManyInput>
    /**
     * Filter which AssessmentSessions to update
     */
    where?: AssessmentSessionWhereInput
  }

  /**
   * AssessmentSession upsert
   */
  export type AssessmentSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssessmentSession to update in case it exists.
     */
    where: AssessmentSessionWhereUniqueInput
    /**
     * In case the AssessmentSession found by the `where` argument doesn't exist, create a new AssessmentSession with this data.
     */
    create: XOR<AssessmentSessionCreateInput, AssessmentSessionUncheckedCreateInput>
    /**
     * In case the AssessmentSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssessmentSessionUpdateInput, AssessmentSessionUncheckedUpdateInput>
  }

  /**
   * AssessmentSession delete
   */
  export type AssessmentSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
    /**
     * Filter which AssessmentSession to delete.
     */
    where: AssessmentSessionWhereUniqueInput
  }

  /**
   * AssessmentSession deleteMany
   */
  export type AssessmentSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssessmentSessions to delete
     */
    where?: AssessmentSessionWhereInput
  }

  /**
   * AssessmentSession.user
   */
  export type AssessmentSession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AssessmentSession without action
   */
  export type AssessmentSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssessmentSession
     */
    select?: AssessmentSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssessmentSessionInclude<ExtArgs> | null
  }


  /**
   * Model UserCertification
   */

  export type AggregateUserCertification = {
    _count: UserCertificationCountAggregateOutputType | null
    _min: UserCertificationMinAggregateOutputType | null
    _max: UserCertificationMaxAggregateOutputType | null
  }

  export type UserCertificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    certification: string | null
    level: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    status: string | null
    certificateUrl: string | null
    verificationCode: string | null
    createdAt: Date | null
  }

  export type UserCertificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    certification: string | null
    level: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    status: string | null
    certificateUrl: string | null
    verificationCode: string | null
    createdAt: Date | null
  }

  export type UserCertificationCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    certification: number
    level: number
    issuedAt: number
    expiresAt: number
    status: number
    certificateUrl: number
    verificationCode: number
    createdAt: number
    _all: number
  }


  export type UserCertificationMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    certification?: true
    level?: true
    issuedAt?: true
    expiresAt?: true
    status?: true
    certificateUrl?: true
    verificationCode?: true
    createdAt?: true
  }

  export type UserCertificationMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    certification?: true
    level?: true
    issuedAt?: true
    expiresAt?: true
    status?: true
    certificateUrl?: true
    verificationCode?: true
    createdAt?: true
  }

  export type UserCertificationCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    certification?: true
    level?: true
    issuedAt?: true
    expiresAt?: true
    status?: true
    certificateUrl?: true
    verificationCode?: true
    createdAt?: true
    _all?: true
  }

  export type UserCertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCertification to aggregate.
     */
    where?: UserCertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCertifications to fetch.
     */
    orderBy?: UserCertificationOrderByWithRelationInput | UserCertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCertifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCertifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCertifications
    **/
    _count?: true | UserCertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCertificationMaxAggregateInputType
  }

  export type GetUserCertificationAggregateType<T extends UserCertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCertification[P]>
      : GetScalarType<T[P], AggregateUserCertification[P]>
  }




  export type UserCertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCertificationWhereInput
    orderBy?: UserCertificationOrderByWithAggregationInput | UserCertificationOrderByWithAggregationInput[]
    by: UserCertificationScalarFieldEnum[] | UserCertificationScalarFieldEnum
    having?: UserCertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCertificationCountAggregateInputType | true
    _min?: UserCertificationMinAggregateInputType
    _max?: UserCertificationMaxAggregateInputType
  }

  export type UserCertificationGroupByOutputType = {
    id: string
    userId: string
    name: string
    certification: string
    level: string | null
    issuedAt: Date
    expiresAt: Date | null
    status: string
    certificateUrl: string | null
    verificationCode: string | null
    createdAt: Date
    _count: UserCertificationCountAggregateOutputType | null
    _min: UserCertificationMinAggregateOutputType | null
    _max: UserCertificationMaxAggregateOutputType | null
  }

  type GetUserCertificationGroupByPayload<T extends UserCertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCertificationGroupByOutputType[P]>
            : GetScalarType<T[P], UserCertificationGroupByOutputType[P]>
        }
      >
    >


  export type UserCertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    certification?: boolean
    level?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    status?: boolean
    certificateUrl?: boolean
    verificationCode?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCertification"]>

  export type UserCertificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    certification?: boolean
    level?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    status?: boolean
    certificateUrl?: boolean
    verificationCode?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCertification"]>

  export type UserCertificationSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    certification?: boolean
    level?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    status?: boolean
    certificateUrl?: boolean
    verificationCode?: boolean
    createdAt?: boolean
  }

  export type UserCertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserCertificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserCertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCertification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      certification: string
      level: string | null
      issuedAt: Date
      expiresAt: Date | null
      status: string
      certificateUrl: string | null
      verificationCode: string | null
      createdAt: Date
    }, ExtArgs["result"]["userCertification"]>
    composites: {}
  }

  type UserCertificationGetPayload<S extends boolean | null | undefined | UserCertificationDefaultArgs> = $Result.GetResult<Prisma.$UserCertificationPayload, S>

  type UserCertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserCertificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCertificationCountAggregateInputType | true
    }

  export interface UserCertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCertification'], meta: { name: 'UserCertification' } }
    /**
     * Find zero or one UserCertification that matches the filter.
     * @param {UserCertificationFindUniqueArgs} args - Arguments to find a UserCertification
     * @example
     * // Get one UserCertification
     * const userCertification = await prisma.userCertification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCertificationFindUniqueArgs>(args: SelectSubset<T, UserCertificationFindUniqueArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserCertification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserCertificationFindUniqueOrThrowArgs} args - Arguments to find a UserCertification
     * @example
     * // Get one UserCertification
     * const userCertification = await prisma.userCertification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCertificationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCertificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserCertification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationFindFirstArgs} args - Arguments to find a UserCertification
     * @example
     * // Get one UserCertification
     * const userCertification = await prisma.userCertification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCertificationFindFirstArgs>(args?: SelectSubset<T, UserCertificationFindFirstArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserCertification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationFindFirstOrThrowArgs} args - Arguments to find a UserCertification
     * @example
     * // Get one UserCertification
     * const userCertification = await prisma.userCertification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCertificationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCertificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserCertifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCertifications
     * const userCertifications = await prisma.userCertification.findMany()
     * 
     * // Get first 10 UserCertifications
     * const userCertifications = await prisma.userCertification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userCertificationWithIdOnly = await prisma.userCertification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserCertificationFindManyArgs>(args?: SelectSubset<T, UserCertificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserCertification.
     * @param {UserCertificationCreateArgs} args - Arguments to create a UserCertification.
     * @example
     * // Create one UserCertification
     * const UserCertification = await prisma.userCertification.create({
     *   data: {
     *     // ... data to create a UserCertification
     *   }
     * })
     * 
     */
    create<T extends UserCertificationCreateArgs>(args: SelectSubset<T, UserCertificationCreateArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserCertifications.
     * @param {UserCertificationCreateManyArgs} args - Arguments to create many UserCertifications.
     * @example
     * // Create many UserCertifications
     * const userCertification = await prisma.userCertification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCertificationCreateManyArgs>(args?: SelectSubset<T, UserCertificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCertifications and returns the data saved in the database.
     * @param {UserCertificationCreateManyAndReturnArgs} args - Arguments to create many UserCertifications.
     * @example
     * // Create many UserCertifications
     * const userCertification = await prisma.userCertification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCertifications and only return the `id`
     * const userCertificationWithIdOnly = await prisma.userCertification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCertificationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCertificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserCertification.
     * @param {UserCertificationDeleteArgs} args - Arguments to delete one UserCertification.
     * @example
     * // Delete one UserCertification
     * const UserCertification = await prisma.userCertification.delete({
     *   where: {
     *     // ... filter to delete one UserCertification
     *   }
     * })
     * 
     */
    delete<T extends UserCertificationDeleteArgs>(args: SelectSubset<T, UserCertificationDeleteArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserCertification.
     * @param {UserCertificationUpdateArgs} args - Arguments to update one UserCertification.
     * @example
     * // Update one UserCertification
     * const userCertification = await prisma.userCertification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCertificationUpdateArgs>(args: SelectSubset<T, UserCertificationUpdateArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserCertifications.
     * @param {UserCertificationDeleteManyArgs} args - Arguments to filter UserCertifications to delete.
     * @example
     * // Delete a few UserCertifications
     * const { count } = await prisma.userCertification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCertificationDeleteManyArgs>(args?: SelectSubset<T, UserCertificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCertifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCertifications
     * const userCertification = await prisma.userCertification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCertificationUpdateManyArgs>(args: SelectSubset<T, UserCertificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCertification.
     * @param {UserCertificationUpsertArgs} args - Arguments to update or create a UserCertification.
     * @example
     * // Update or create a UserCertification
     * const userCertification = await prisma.userCertification.upsert({
     *   create: {
     *     // ... data to create a UserCertification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCertification we want to update
     *   }
     * })
     */
    upsert<T extends UserCertificationUpsertArgs>(args: SelectSubset<T, UserCertificationUpsertArgs<ExtArgs>>): Prisma__UserCertificationClient<$Result.GetResult<Prisma.$UserCertificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserCertifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationCountArgs} args - Arguments to filter UserCertifications to count.
     * @example
     * // Count the number of UserCertifications
     * const count = await prisma.userCertification.count({
     *   where: {
     *     // ... the filter for the UserCertifications we want to count
     *   }
     * })
    **/
    count<T extends UserCertificationCountArgs>(
      args?: Subset<T, UserCertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCertification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCertificationAggregateArgs>(args: Subset<T, UserCertificationAggregateArgs>): Prisma.PrismaPromise<GetUserCertificationAggregateType<T>>

    /**
     * Group by UserCertification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCertificationGroupByArgs['orderBy'] }
        : { orderBy?: UserCertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCertification model
   */
  readonly fields: UserCertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCertification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCertification model
   */ 
  interface UserCertificationFieldRefs {
    readonly id: FieldRef<"UserCertification", 'String'>
    readonly userId: FieldRef<"UserCertification", 'String'>
    readonly name: FieldRef<"UserCertification", 'String'>
    readonly certification: FieldRef<"UserCertification", 'String'>
    readonly level: FieldRef<"UserCertification", 'String'>
    readonly issuedAt: FieldRef<"UserCertification", 'DateTime'>
    readonly expiresAt: FieldRef<"UserCertification", 'DateTime'>
    readonly status: FieldRef<"UserCertification", 'String'>
    readonly certificateUrl: FieldRef<"UserCertification", 'String'>
    readonly verificationCode: FieldRef<"UserCertification", 'String'>
    readonly createdAt: FieldRef<"UserCertification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserCertification findUnique
   */
  export type UserCertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * Filter, which UserCertification to fetch.
     */
    where: UserCertificationWhereUniqueInput
  }

  /**
   * UserCertification findUniqueOrThrow
   */
  export type UserCertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * Filter, which UserCertification to fetch.
     */
    where: UserCertificationWhereUniqueInput
  }

  /**
   * UserCertification findFirst
   */
  export type UserCertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * Filter, which UserCertification to fetch.
     */
    where?: UserCertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCertifications to fetch.
     */
    orderBy?: UserCertificationOrderByWithRelationInput | UserCertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCertifications.
     */
    cursor?: UserCertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCertifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCertifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCertifications.
     */
    distinct?: UserCertificationScalarFieldEnum | UserCertificationScalarFieldEnum[]
  }

  /**
   * UserCertification findFirstOrThrow
   */
  export type UserCertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * Filter, which UserCertification to fetch.
     */
    where?: UserCertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCertifications to fetch.
     */
    orderBy?: UserCertificationOrderByWithRelationInput | UserCertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCertifications.
     */
    cursor?: UserCertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCertifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCertifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCertifications.
     */
    distinct?: UserCertificationScalarFieldEnum | UserCertificationScalarFieldEnum[]
  }

  /**
   * UserCertification findMany
   */
  export type UserCertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * Filter, which UserCertifications to fetch.
     */
    where?: UserCertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCertifications to fetch.
     */
    orderBy?: UserCertificationOrderByWithRelationInput | UserCertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCertifications.
     */
    cursor?: UserCertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCertifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCertifications.
     */
    skip?: number
    distinct?: UserCertificationScalarFieldEnum | UserCertificationScalarFieldEnum[]
  }

  /**
   * UserCertification create
   */
  export type UserCertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCertification.
     */
    data: XOR<UserCertificationCreateInput, UserCertificationUncheckedCreateInput>
  }

  /**
   * UserCertification createMany
   */
  export type UserCertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCertifications.
     */
    data: UserCertificationCreateManyInput | UserCertificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCertification createManyAndReturn
   */
  export type UserCertificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserCertifications.
     */
    data: UserCertificationCreateManyInput | UserCertificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCertification update
   */
  export type UserCertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCertification.
     */
    data: XOR<UserCertificationUpdateInput, UserCertificationUncheckedUpdateInput>
    /**
     * Choose, which UserCertification to update.
     */
    where: UserCertificationWhereUniqueInput
  }

  /**
   * UserCertification updateMany
   */
  export type UserCertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCertifications.
     */
    data: XOR<UserCertificationUpdateManyMutationInput, UserCertificationUncheckedUpdateManyInput>
    /**
     * Filter which UserCertifications to update
     */
    where?: UserCertificationWhereInput
  }

  /**
   * UserCertification upsert
   */
  export type UserCertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCertification to update in case it exists.
     */
    where: UserCertificationWhereUniqueInput
    /**
     * In case the UserCertification found by the `where` argument doesn't exist, create a new UserCertification with this data.
     */
    create: XOR<UserCertificationCreateInput, UserCertificationUncheckedCreateInput>
    /**
     * In case the UserCertification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCertificationUpdateInput, UserCertificationUncheckedUpdateInput>
  }

  /**
   * UserCertification delete
   */
  export type UserCertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
    /**
     * Filter which UserCertification to delete.
     */
    where: UserCertificationWhereUniqueInput
  }

  /**
   * UserCertification deleteMany
   */
  export type UserCertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCertifications to delete
     */
    where?: UserCertificationWhereInput
  }

  /**
   * UserCertification without action
   */
  export type UserCertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCertification
     */
    select?: UserCertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCertificationInclude<ExtArgs> | null
  }


  /**
   * Model Roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _avg: RoadmapAvgAggregateOutputType | null
    _sum: RoadmapSumAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapAvgAggregateOutputType = {
    totalSprints: number | null
    currentSprint: number | null
    sprintDurationWeeks: number | null
    completionPercentage: number | null
  }

  export type RoadmapSumAggregateOutputType = {
    totalSprints: number | null
    currentSprint: number | null
    sprintDurationWeeks: number | null
    completionPercentage: number | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assessmentSessionId: string | null
    standardType: string | null
    totalSprints: number | null
    currentSprint: number | null
    sprintDurationWeeks: number | null
    completionPercentage: number | null
    estimatedCompletionDate: Date | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assessmentSessionId: string | null
    standardType: string | null
    totalSprints: number | null
    currentSprint: number | null
    sprintDurationWeeks: number | null
    completionPercentage: number | null
    estimatedCompletionDate: Date | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    userId: number
    assessmentSessionId: number
    standardType: number
    totalSprints: number
    currentSprint: number
    sprintDurationWeeks: number
    completionPercentage: number
    estimatedCompletionDate: number
    status: number
    sprintDetails: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapAvgAggregateInputType = {
    totalSprints?: true
    currentSprint?: true
    sprintDurationWeeks?: true
    completionPercentage?: true
  }

  export type RoadmapSumAggregateInputType = {
    totalSprints?: true
    currentSprint?: true
    sprintDurationWeeks?: true
    completionPercentage?: true
  }

  export type RoadmapMinAggregateInputType = {
    id?: true
    userId?: true
    assessmentSessionId?: true
    standardType?: true
    totalSprints?: true
    currentSprint?: true
    sprintDurationWeeks?: true
    completionPercentage?: true
    estimatedCompletionDate?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    userId?: true
    assessmentSessionId?: true
    standardType?: true
    totalSprints?: true
    currentSprint?: true
    sprintDurationWeeks?: true
    completionPercentage?: true
    estimatedCompletionDate?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    userId?: true
    assessmentSessionId?: true
    standardType?: true
    totalSprints?: true
    currentSprint?: true
    sprintDurationWeeks?: true
    completionPercentage?: true
    estimatedCompletionDate?: true
    status?: true
    sprintDetails?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmap to aggregate.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type RoadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithAggregationInput | RoadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: RoadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _avg?: RoadmapAvgAggregateInputType
    _sum?: RoadmapSumAggregateInputType
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: string
    userId: string
    assessmentSessionId: string | null
    standardType: string
    totalSprints: number
    currentSprint: number
    sprintDurationWeeks: number
    completionPercentage: number
    estimatedCompletionDate: Date | null
    status: string
    sprintDetails: JsonValue | null
    startedAt: Date
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoadmapCountAggregateOutputType | null
    _avg: RoadmapAvgAggregateOutputType | null
    _sum: RoadmapSumAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends RoadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentSessionId?: boolean
    standardType?: boolean
    totalSprints?: boolean
    currentSprint?: boolean
    sprintDurationWeeks?: boolean
    completionPercentage?: boolean
    estimatedCompletionDate?: boolean
    status?: boolean
    sprintDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    userActions?: boolean | Roadmap$userActionsArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assessmentSessionId?: boolean
    standardType?: boolean
    totalSprints?: boolean
    currentSprint?: boolean
    sprintDurationWeeks?: boolean
    completionPercentage?: boolean
    estimatedCompletionDate?: boolean
    status?: boolean
    sprintDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectScalar = {
    id?: boolean
    userId?: boolean
    assessmentSessionId?: boolean
    standardType?: boolean
    totalSprints?: boolean
    currentSprint?: boolean
    sprintDurationWeeks?: boolean
    completionPercentage?: boolean
    estimatedCompletionDate?: boolean
    status?: boolean
    sprintDetails?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    userActions?: boolean | Roadmap$userActionsArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roadmap"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      userActions: Prisma.$UserActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assessmentSessionId: string | null
      standardType: string
      totalSprints: number
      currentSprint: number
      sprintDurationWeeks: number
      completionPercentage: number
      estimatedCompletionDate: Date | null
      status: string
      sprintDetails: Prisma.JsonValue | null
      startedAt: Date
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type RoadmapGetPayload<S extends boolean | null | undefined | RoadmapDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPayload, S>

  type RoadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface RoadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roadmap'], meta: { name: 'Roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {RoadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapFindUniqueArgs>(args: SelectSubset<T, RoadmapFindUniqueArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapFindFirstArgs>(args?: SelectSubset<T, RoadmapFindFirstArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapFindManyArgs>(args?: SelectSubset<T, RoadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roadmap.
     * @param {RoadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends RoadmapCreateArgs>(args: SelectSubset<T, RoadmapCreateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roadmaps.
     * @param {RoadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapCreateManyArgs>(args?: SelectSubset<T, RoadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roadmaps and returns the data saved in the database.
     * @param {RoadmapCreateManyAndReturnArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roadmap.
     * @param {RoadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends RoadmapDeleteArgs>(args: SelectSubset<T, RoadmapDeleteArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roadmap.
     * @param {RoadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapUpdateArgs>(args: SelectSubset<T, RoadmapUpdateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roadmaps.
     * @param {RoadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapDeleteManyArgs>(args?: SelectSubset<T, RoadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapUpdateManyArgs>(args: SelectSubset<T, RoadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmap.
     * @param {RoadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapUpsertArgs>(args: SelectSubset<T, RoadmapUpsertArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapCountArgs>(
      args?: Subset<T, RoadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roadmap model
   */
  readonly fields: RoadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    userActions<T extends Roadmap$userActionsArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$userActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roadmap model
   */ 
  interface RoadmapFieldRefs {
    readonly id: FieldRef<"Roadmap", 'String'>
    readonly userId: FieldRef<"Roadmap", 'String'>
    readonly assessmentSessionId: FieldRef<"Roadmap", 'String'>
    readonly standardType: FieldRef<"Roadmap", 'String'>
    readonly totalSprints: FieldRef<"Roadmap", 'Int'>
    readonly currentSprint: FieldRef<"Roadmap", 'Int'>
    readonly sprintDurationWeeks: FieldRef<"Roadmap", 'Int'>
    readonly completionPercentage: FieldRef<"Roadmap", 'Float'>
    readonly estimatedCompletionDate: FieldRef<"Roadmap", 'DateTime'>
    readonly status: FieldRef<"Roadmap", 'String'>
    readonly sprintDetails: FieldRef<"Roadmap", 'Json'>
    readonly startedAt: FieldRef<"Roadmap", 'DateTime'>
    readonly completedAt: FieldRef<"Roadmap", 'DateTime'>
    readonly createdAt: FieldRef<"Roadmap", 'DateTime'>
    readonly updatedAt: FieldRef<"Roadmap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Roadmap findUnique
   */
  export type RoadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findUniqueOrThrow
   */
  export type RoadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findFirst
   */
  export type RoadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findFirstOrThrow
   */
  export type RoadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findMany
   */
  export type RoadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmaps to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap create
   */
  export type RoadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a Roadmap.
     */
    data: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
  }

  /**
   * Roadmap createMany
   */
  export type RoadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roadmap createManyAndReturn
   */
  export type RoadmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roadmap update
   */
  export type RoadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a Roadmap.
     */
    data: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
    /**
     * Choose, which Roadmap to update.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap updateMany
   */
  export type RoadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap upsert
   */
  export type RoadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the Roadmap to update in case it exists.
     */
    where: RoadmapWhereUniqueInput
    /**
     * In case the Roadmap found by the `where` argument doesn't exist, create a new Roadmap with this data.
     */
    create: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
    /**
     * In case the Roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
  }

  /**
   * Roadmap delete
   */
  export type RoadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter which Roadmap to delete.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap deleteMany
   */
  export type RoadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmaps to delete
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap.userActions
   */
  export type Roadmap$userActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    where?: UserActionWhereInput
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    cursor?: UserActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActionScalarFieldEnum | UserActionScalarFieldEnum[]
  }

  /**
   * Roadmap without action
   */
  export type RoadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    estimatedHours: number | null
    priorityWeight: number | null
    displayOrder: number | null
  }

  export type ActionSumAggregateOutputType = {
    estimatedHours: number | null
    priorityWeight: number | null
    displayOrder: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: string | null
    standardType: string | null
    actionCode: string | null
    title: string | null
    description: string | null
    requirementRef: string | null
    chapterNumber: string | null
    estimatedHours: number | null
    priorityWeight: number | null
    category: string | null
    videoUrl: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionMaxAggregateOutputType = {
    id: string | null
    standardType: string | null
    actionCode: string | null
    title: string | null
    description: string | null
    requirementRef: string | null
    chapterNumber: string | null
    estimatedHours: number | null
    priorityWeight: number | null
    category: string | null
    videoUrl: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    standardType: number
    actionCode: number
    title: number
    description: number
    requirementRef: number
    chapterNumber: number
    estimatedHours: number
    priorityWeight: number
    category: number
    sectorVariations: number
    templateIds: number
    videoUrl: number
    dependsOnActions: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    estimatedHours?: true
    priorityWeight?: true
    displayOrder?: true
  }

  export type ActionSumAggregateInputType = {
    estimatedHours?: true
    priorityWeight?: true
    displayOrder?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    standardType?: true
    actionCode?: true
    title?: true
    description?: true
    requirementRef?: true
    chapterNumber?: true
    estimatedHours?: true
    priorityWeight?: true
    category?: true
    videoUrl?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    standardType?: true
    actionCode?: true
    title?: true
    description?: true
    requirementRef?: true
    chapterNumber?: true
    estimatedHours?: true
    priorityWeight?: true
    category?: true
    videoUrl?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    standardType?: true
    actionCode?: true
    title?: true
    description?: true
    requirementRef?: true
    chapterNumber?: true
    estimatedHours?: true
    priorityWeight?: true
    category?: true
    sectorVariations?: true
    templateIds?: true
    videoUrl?: true
    dependsOnActions?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: string
    standardType: string
    actionCode: string
    title: string
    description: string
    requirementRef: string
    chapterNumber: string | null
    estimatedHours: number
    priorityWeight: number
    category: string | null
    sectorVariations: JsonValue | null
    templateIds: string[]
    videoUrl: string | null
    dependsOnActions: string[]
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    standardType?: boolean
    actionCode?: boolean
    title?: boolean
    description?: boolean
    requirementRef?: boolean
    chapterNumber?: boolean
    estimatedHours?: boolean
    priorityWeight?: boolean
    category?: boolean
    sectorVariations?: boolean
    templateIds?: boolean
    videoUrl?: boolean
    dependsOnActions?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userActions?: boolean | Action$userActionsArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    standardType?: boolean
    actionCode?: boolean
    title?: boolean
    description?: boolean
    requirementRef?: boolean
    chapterNumber?: boolean
    estimatedHours?: boolean
    priorityWeight?: boolean
    category?: boolean
    sectorVariations?: boolean
    templateIds?: boolean
    videoUrl?: boolean
    dependsOnActions?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    id?: boolean
    standardType?: boolean
    actionCode?: boolean
    title?: boolean
    description?: boolean
    requirementRef?: boolean
    chapterNumber?: boolean
    estimatedHours?: boolean
    priorityWeight?: boolean
    category?: boolean
    sectorVariations?: boolean
    templateIds?: boolean
    videoUrl?: boolean
    dependsOnActions?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userActions?: boolean | Action$userActionsArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      userActions: Prisma.$UserActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      standardType: string
      actionCode: string
      title: string
      description: string
      requirementRef: string
      chapterNumber: string | null
      estimatedHours: number
      priorityWeight: number
      category: string | null
      sectorVariations: Prisma.JsonValue | null
      templateIds: string[]
      videoUrl: string | null
      dependsOnActions: string[]
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userActions<T extends Action$userActionsArgs<ExtArgs> = {}>(args?: Subset<T, Action$userActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */ 
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'String'>
    readonly standardType: FieldRef<"Action", 'String'>
    readonly actionCode: FieldRef<"Action", 'String'>
    readonly title: FieldRef<"Action", 'String'>
    readonly description: FieldRef<"Action", 'String'>
    readonly requirementRef: FieldRef<"Action", 'String'>
    readonly chapterNumber: FieldRef<"Action", 'String'>
    readonly estimatedHours: FieldRef<"Action", 'Int'>
    readonly priorityWeight: FieldRef<"Action", 'Int'>
    readonly category: FieldRef<"Action", 'String'>
    readonly sectorVariations: FieldRef<"Action", 'Json'>
    readonly templateIds: FieldRef<"Action", 'String[]'>
    readonly videoUrl: FieldRef<"Action", 'String'>
    readonly dependsOnActions: FieldRef<"Action", 'String[]'>
    readonly displayOrder: FieldRef<"Action", 'Int'>
    readonly createdAt: FieldRef<"Action", 'DateTime'>
    readonly updatedAt: FieldRef<"Action", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
  }

  /**
   * Action.userActions
   */
  export type Action$userActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    where?: UserActionWhereInput
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    cursor?: UserActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActionScalarFieldEnum | UserActionScalarFieldEnum[]
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model UserAction
   */

  export type AggregateUserAction = {
    _count: UserActionCountAggregateOutputType | null
    _avg: UserActionAvgAggregateOutputType | null
    _sum: UserActionSumAggregateOutputType | null
    _min: UserActionMinAggregateOutputType | null
    _max: UserActionMaxAggregateOutputType | null
  }

  export type UserActionAvgAggregateOutputType = {
    sprintNumber: number | null
  }

  export type UserActionSumAggregateOutputType = {
    sprintNumber: number | null
  }

  export type UserActionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roadmapId: string | null
    actionId: string | null
    sprintNumber: number | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    notes: string | null
    blockedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserActionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roadmapId: string | null
    actionId: string | null
    sprintNumber: number | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
    notes: string | null
    blockedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserActionCountAggregateOutputType = {
    id: number
    userId: number
    roadmapId: number
    actionId: number
    sprintNumber: number
    status: number
    startedAt: number
    completedAt: number
    notes: number
    blockedReason: number
    uploadedFiles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserActionAvgAggregateInputType = {
    sprintNumber?: true
  }

  export type UserActionSumAggregateInputType = {
    sprintNumber?: true
  }

  export type UserActionMinAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    actionId?: true
    sprintNumber?: true
    status?: true
    startedAt?: true
    completedAt?: true
    notes?: true
    blockedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserActionMaxAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    actionId?: true
    sprintNumber?: true
    status?: true
    startedAt?: true
    completedAt?: true
    notes?: true
    blockedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserActionCountAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    actionId?: true
    sprintNumber?: true
    status?: true
    startedAt?: true
    completedAt?: true
    notes?: true
    blockedReason?: true
    uploadedFiles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAction to aggregate.
     */
    where?: UserActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     */
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserActions
    **/
    _count?: true | UserActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActionMaxAggregateInputType
  }

  export type GetUserActionAggregateType<T extends UserActionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAction[P]>
      : GetScalarType<T[P], AggregateUserAction[P]>
  }




  export type UserActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserActionWhereInput
    orderBy?: UserActionOrderByWithAggregationInput | UserActionOrderByWithAggregationInput[]
    by: UserActionScalarFieldEnum[] | UserActionScalarFieldEnum
    having?: UserActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActionCountAggregateInputType | true
    _avg?: UserActionAvgAggregateInputType
    _sum?: UserActionSumAggregateInputType
    _min?: UserActionMinAggregateInputType
    _max?: UserActionMaxAggregateInputType
  }

  export type UserActionGroupByOutputType = {
    id: string
    userId: string
    roadmapId: string
    actionId: string
    sprintNumber: number
    status: string
    startedAt: Date | null
    completedAt: Date | null
    notes: string | null
    blockedReason: string | null
    uploadedFiles: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserActionCountAggregateOutputType | null
    _avg: UserActionAvgAggregateOutputType | null
    _sum: UserActionSumAggregateOutputType | null
    _min: UserActionMinAggregateOutputType | null
    _max: UserActionMaxAggregateOutputType | null
  }

  type GetUserActionGroupByPayload<T extends UserActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActionGroupByOutputType[P]>
            : GetScalarType<T[P], UserActionGroupByOutputType[P]>
        }
      >
    >


  export type UserActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    actionId?: boolean
    sprintNumber?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    blockedReason?: boolean
    uploadedFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    action?: boolean | ActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAction"]>

  export type UserActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    actionId?: boolean
    sprintNumber?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    blockedReason?: boolean
    uploadedFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    action?: boolean | ActionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAction"]>

  export type UserActionSelectScalar = {
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    actionId?: boolean
    sprintNumber?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    notes?: boolean
    blockedReason?: boolean
    uploadedFiles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    action?: boolean | ActionDefaultArgs<ExtArgs>
  }
  export type UserActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    action?: boolean | ActionDefaultArgs<ExtArgs>
  }

  export type $UserActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
      action: Prisma.$ActionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roadmapId: string
      actionId: string
      sprintNumber: number
      status: string
      startedAt: Date | null
      completedAt: Date | null
      notes: string | null
      blockedReason: string | null
      uploadedFiles: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAction"]>
    composites: {}
  }

  type UserActionGetPayload<S extends boolean | null | undefined | UserActionDefaultArgs> = $Result.GetResult<Prisma.$UserActionPayload, S>

  type UserActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserActionCountAggregateInputType | true
    }

  export interface UserActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAction'], meta: { name: 'UserAction' } }
    /**
     * Find zero or one UserAction that matches the filter.
     * @param {UserActionFindUniqueArgs} args - Arguments to find a UserAction
     * @example
     * // Get one UserAction
     * const userAction = await prisma.userAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserActionFindUniqueArgs>(args: SelectSubset<T, UserActionFindUniqueArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserActionFindUniqueOrThrowArgs} args - Arguments to find a UserAction
     * @example
     * // Get one UserAction
     * const userAction = await prisma.userAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserActionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionFindFirstArgs} args - Arguments to find a UserAction
     * @example
     * // Get one UserAction
     * const userAction = await prisma.userAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserActionFindFirstArgs>(args?: SelectSubset<T, UserActionFindFirstArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionFindFirstOrThrowArgs} args - Arguments to find a UserAction
     * @example
     * // Get one UserAction
     * const userAction = await prisma.userAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserActionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActions
     * const userActions = await prisma.userAction.findMany()
     * 
     * // Get first 10 UserActions
     * const userActions = await prisma.userAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActionWithIdOnly = await prisma.userAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserActionFindManyArgs>(args?: SelectSubset<T, UserActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAction.
     * @param {UserActionCreateArgs} args - Arguments to create a UserAction.
     * @example
     * // Create one UserAction
     * const UserAction = await prisma.userAction.create({
     *   data: {
     *     // ... data to create a UserAction
     *   }
     * })
     * 
     */
    create<T extends UserActionCreateArgs>(args: SelectSubset<T, UserActionCreateArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserActions.
     * @param {UserActionCreateManyArgs} args - Arguments to create many UserActions.
     * @example
     * // Create many UserActions
     * const userAction = await prisma.userAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserActionCreateManyArgs>(args?: SelectSubset<T, UserActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActions and returns the data saved in the database.
     * @param {UserActionCreateManyAndReturnArgs} args - Arguments to create many UserActions.
     * @example
     * // Create many UserActions
     * const userAction = await prisma.userAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActions and only return the `id`
     * const userActionWithIdOnly = await prisma.userAction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserActionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAction.
     * @param {UserActionDeleteArgs} args - Arguments to delete one UserAction.
     * @example
     * // Delete one UserAction
     * const UserAction = await prisma.userAction.delete({
     *   where: {
     *     // ... filter to delete one UserAction
     *   }
     * })
     * 
     */
    delete<T extends UserActionDeleteArgs>(args: SelectSubset<T, UserActionDeleteArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAction.
     * @param {UserActionUpdateArgs} args - Arguments to update one UserAction.
     * @example
     * // Update one UserAction
     * const userAction = await prisma.userAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserActionUpdateArgs>(args: SelectSubset<T, UserActionUpdateArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserActions.
     * @param {UserActionDeleteManyArgs} args - Arguments to filter UserActions to delete.
     * @example
     * // Delete a few UserActions
     * const { count } = await prisma.userAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserActionDeleteManyArgs>(args?: SelectSubset<T, UserActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActions
     * const userAction = await prisma.userAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserActionUpdateManyArgs>(args: SelectSubset<T, UserActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAction.
     * @param {UserActionUpsertArgs} args - Arguments to update or create a UserAction.
     * @example
     * // Update or create a UserAction
     * const userAction = await prisma.userAction.upsert({
     *   create: {
     *     // ... data to create a UserAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAction we want to update
     *   }
     * })
     */
    upsert<T extends UserActionUpsertArgs>(args: SelectSubset<T, UserActionUpsertArgs<ExtArgs>>): Prisma__UserActionClient<$Result.GetResult<Prisma.$UserActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionCountArgs} args - Arguments to filter UserActions to count.
     * @example
     * // Count the number of UserActions
     * const count = await prisma.userAction.count({
     *   where: {
     *     // ... the filter for the UserActions we want to count
     *   }
     * })
    **/
    count<T extends UserActionCountArgs>(
      args?: Subset<T, UserActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActionAggregateArgs>(args: Subset<T, UserActionAggregateArgs>): Prisma.PrismaPromise<GetUserActionAggregateType<T>>

    /**
     * Group by UserAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserActionGroupByArgs['orderBy'] }
        : { orderBy?: UserActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAction model
   */
  readonly fields: UserActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    action<T extends ActionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActionDefaultArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAction model
   */ 
  interface UserActionFieldRefs {
    readonly id: FieldRef<"UserAction", 'String'>
    readonly userId: FieldRef<"UserAction", 'String'>
    readonly roadmapId: FieldRef<"UserAction", 'String'>
    readonly actionId: FieldRef<"UserAction", 'String'>
    readonly sprintNumber: FieldRef<"UserAction", 'Int'>
    readonly status: FieldRef<"UserAction", 'String'>
    readonly startedAt: FieldRef<"UserAction", 'DateTime'>
    readonly completedAt: FieldRef<"UserAction", 'DateTime'>
    readonly notes: FieldRef<"UserAction", 'String'>
    readonly blockedReason: FieldRef<"UserAction", 'String'>
    readonly uploadedFiles: FieldRef<"UserAction", 'Json'>
    readonly createdAt: FieldRef<"UserAction", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAction findUnique
   */
  export type UserActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * Filter, which UserAction to fetch.
     */
    where: UserActionWhereUniqueInput
  }

  /**
   * UserAction findUniqueOrThrow
   */
  export type UserActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * Filter, which UserAction to fetch.
     */
    where: UserActionWhereUniqueInput
  }

  /**
   * UserAction findFirst
   */
  export type UserActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * Filter, which UserAction to fetch.
     */
    where?: UserActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     */
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActions.
     */
    cursor?: UserActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActions.
     */
    distinct?: UserActionScalarFieldEnum | UserActionScalarFieldEnum[]
  }

  /**
   * UserAction findFirstOrThrow
   */
  export type UserActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * Filter, which UserAction to fetch.
     */
    where?: UserActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     */
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserActions.
     */
    cursor?: UserActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserActions.
     */
    distinct?: UserActionScalarFieldEnum | UserActionScalarFieldEnum[]
  }

  /**
   * UserAction findMany
   */
  export type UserActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * Filter, which UserActions to fetch.
     */
    where?: UserActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserActions to fetch.
     */
    orderBy?: UserActionOrderByWithRelationInput | UserActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserActions.
     */
    cursor?: UserActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserActions.
     */
    skip?: number
    distinct?: UserActionScalarFieldEnum | UserActionScalarFieldEnum[]
  }

  /**
   * UserAction create
   */
  export type UserActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAction.
     */
    data: XOR<UserActionCreateInput, UserActionUncheckedCreateInput>
  }

  /**
   * UserAction createMany
   */
  export type UserActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserActions.
     */
    data: UserActionCreateManyInput | UserActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAction createManyAndReturn
   */
  export type UserActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserActions.
     */
    data: UserActionCreateManyInput | UserActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAction update
   */
  export type UserActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAction.
     */
    data: XOR<UserActionUpdateInput, UserActionUncheckedUpdateInput>
    /**
     * Choose, which UserAction to update.
     */
    where: UserActionWhereUniqueInput
  }

  /**
   * UserAction updateMany
   */
  export type UserActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserActions.
     */
    data: XOR<UserActionUpdateManyMutationInput, UserActionUncheckedUpdateManyInput>
    /**
     * Filter which UserActions to update
     */
    where?: UserActionWhereInput
  }

  /**
   * UserAction upsert
   */
  export type UserActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAction to update in case it exists.
     */
    where: UserActionWhereUniqueInput
    /**
     * In case the UserAction found by the `where` argument doesn't exist, create a new UserAction with this data.
     */
    create: XOR<UserActionCreateInput, UserActionUncheckedCreateInput>
    /**
     * In case the UserAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserActionUpdateInput, UserActionUncheckedUpdateInput>
  }

  /**
   * UserAction delete
   */
  export type UserActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
    /**
     * Filter which UserAction to delete.
     */
    where: UserActionWhereUniqueInput
  }

  /**
   * UserAction deleteMany
   */
  export type UserActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserActions to delete
     */
    where?: UserActionWhereInput
  }

  /**
   * UserAction without action
   */
  export type UserActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAction
     */
    select?: UserActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserActionInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateAvgAggregateOutputType = {
    fileSize: number | null
    downloadCount: number | null
    displayOrder: number | null
  }

  export type TemplateSumAggregateOutputType = {
    fileSize: number | null
    downloadCount: number | null
    displayOrder: number | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    standardType: string | null
    templateCode: string | null
    title: string | null
    description: string | null
    category: string | null
    fileUrl: string | null
    fileFormat: string | null
    fileSize: number | null
    requirementRef: string | null
    downloadCount: number | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    standardType: string | null
    templateCode: string | null
    title: string | null
    description: string | null
    category: string | null
    fileUrl: string | null
    fileFormat: string | null
    fileSize: number | null
    requirementRef: string | null
    downloadCount: number | null
    displayOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    standardType: number
    templateCode: number
    title: number
    description: number
    category: number
    fileUrl: number
    fileFormat: number
    fileSize: number
    requirementRef: number
    sectorAdaptations: number
    relatedActionCodes: number
    downloadCount: number
    displayOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateAvgAggregateInputType = {
    fileSize?: true
    downloadCount?: true
    displayOrder?: true
  }

  export type TemplateSumAggregateInputType = {
    fileSize?: true
    downloadCount?: true
    displayOrder?: true
  }

  export type TemplateMinAggregateInputType = {
    id?: true
    standardType?: true
    templateCode?: true
    title?: true
    description?: true
    category?: true
    fileUrl?: true
    fileFormat?: true
    fileSize?: true
    requirementRef?: true
    downloadCount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    standardType?: true
    templateCode?: true
    title?: true
    description?: true
    category?: true
    fileUrl?: true
    fileFormat?: true
    fileSize?: true
    requirementRef?: true
    downloadCount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    standardType?: true
    templateCode?: true
    title?: true
    description?: true
    category?: true
    fileUrl?: true
    fileFormat?: true
    fileSize?: true
    requirementRef?: true
    sectorAdaptations?: true
    relatedActionCodes?: true
    downloadCount?: true
    displayOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _avg?: TemplateAvgAggregateInputType
    _sum?: TemplateSumAggregateInputType
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    standardType: string
    templateCode: string
    title: string
    description: string | null
    category: string
    fileUrl: string
    fileFormat: string
    fileSize: number | null
    requirementRef: string | null
    sectorAdaptations: JsonValue | null
    relatedActionCodes: string[]
    downloadCount: number
    displayOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    standardType?: boolean
    templateCode?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    fileUrl?: boolean
    fileFormat?: boolean
    fileSize?: boolean
    requirementRef?: boolean
    sectorAdaptations?: boolean
    relatedActionCodes?: boolean
    downloadCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    standardType?: boolean
    templateCode?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    fileUrl?: boolean
    fileFormat?: boolean
    fileSize?: boolean
    requirementRef?: boolean
    sectorAdaptations?: boolean
    relatedActionCodes?: boolean
    downloadCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    standardType?: boolean
    templateCode?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    fileUrl?: boolean
    fileFormat?: boolean
    fileSize?: boolean
    requirementRef?: boolean
    sectorAdaptations?: boolean
    relatedActionCodes?: boolean
    downloadCount?: boolean
    displayOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      standardType: string
      templateCode: string
      title: string
      description: string | null
      category: string
      fileUrl: string
      fileFormat: string
      fileSize: number | null
      requirementRef: string | null
      sectorAdaptations: Prisma.JsonValue | null
      relatedActionCodes: string[]
      downloadCount: number
      displayOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {TemplateCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly standardType: FieldRef<"Template", 'String'>
    readonly templateCode: FieldRef<"Template", 'String'>
    readonly title: FieldRef<"Template", 'String'>
    readonly description: FieldRef<"Template", 'String'>
    readonly category: FieldRef<"Template", 'String'>
    readonly fileUrl: FieldRef<"Template", 'String'>
    readonly fileFormat: FieldRef<"Template", 'String'>
    readonly fileSize: FieldRef<"Template", 'Int'>
    readonly requirementRef: FieldRef<"Template", 'String'>
    readonly sectorAdaptations: FieldRef<"Template", 'Json'>
    readonly relatedActionCodes: FieldRef<"Template", 'String[]'>
    readonly downloadCount: FieldRef<"Template", 'Int'>
    readonly displayOrder: FieldRef<"Template", 'Int'>
    readonly isActive: FieldRef<"Template", 'Boolean'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template createManyAndReturn
   */
  export type TemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
  }


  /**
   * Model StandardConfig
   */

  export type AggregateStandardConfig = {
    _count: StandardConfigCountAggregateOutputType | null
    _avg: StandardConfigAvgAggregateOutputType | null
    _sum: StandardConfigSumAggregateOutputType | null
    _min: StandardConfigMinAggregateOutputType | null
    _max: StandardConfigMaxAggregateOutputType | null
  }

  export type StandardConfigAvgAggregateOutputType = {
    estimatedMonths: number | null
    typicalPrice: number | null
  }

  export type StandardConfigSumAggregateOutputType = {
    estimatedMonths: number | null
    typicalPrice: number | null
  }

  export type StandardConfigMinAggregateOutputType = {
    id: string | null
    standardType: string | null
    name: string | null
    shortName: string | null
    description: string | null
    icon: string | null
    estimatedMonths: number | null
    typicalPrice: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardConfigMaxAggregateOutputType = {
    id: string | null
    standardType: string | null
    name: string | null
    shortName: string | null
    description: string | null
    icon: string | null
    estimatedMonths: number | null
    typicalPrice: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StandardConfigCountAggregateOutputType = {
    id: number
    standardType: number
    name: number
    shortName: number
    description: number
    icon: number
    questions: number
    chapters: number
    maturityLevels: number
    estimatedMonths: number
    typicalPrice: number
    sectorRelevance: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StandardConfigAvgAggregateInputType = {
    estimatedMonths?: true
    typicalPrice?: true
  }

  export type StandardConfigSumAggregateInputType = {
    estimatedMonths?: true
    typicalPrice?: true
  }

  export type StandardConfigMinAggregateInputType = {
    id?: true
    standardType?: true
    name?: true
    shortName?: true
    description?: true
    icon?: true
    estimatedMonths?: true
    typicalPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardConfigMaxAggregateInputType = {
    id?: true
    standardType?: true
    name?: true
    shortName?: true
    description?: true
    icon?: true
    estimatedMonths?: true
    typicalPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StandardConfigCountAggregateInputType = {
    id?: true
    standardType?: true
    name?: true
    shortName?: true
    description?: true
    icon?: true
    questions?: true
    chapters?: true
    maturityLevels?: true
    estimatedMonths?: true
    typicalPrice?: true
    sectorRelevance?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StandardConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardConfig to aggregate.
     */
    where?: StandardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardConfigs to fetch.
     */
    orderBy?: StandardConfigOrderByWithRelationInput | StandardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StandardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StandardConfigs
    **/
    _count?: true | StandardConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StandardConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StandardConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardConfigMaxAggregateInputType
  }

  export type GetStandardConfigAggregateType<T extends StandardConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardConfig[P]>
      : GetScalarType<T[P], AggregateStandardConfig[P]>
  }




  export type StandardConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StandardConfigWhereInput
    orderBy?: StandardConfigOrderByWithAggregationInput | StandardConfigOrderByWithAggregationInput[]
    by: StandardConfigScalarFieldEnum[] | StandardConfigScalarFieldEnum
    having?: StandardConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardConfigCountAggregateInputType | true
    _avg?: StandardConfigAvgAggregateInputType
    _sum?: StandardConfigSumAggregateInputType
    _min?: StandardConfigMinAggregateInputType
    _max?: StandardConfigMaxAggregateInputType
  }

  export type StandardConfigGroupByOutputType = {
    id: string
    standardType: string
    name: string
    shortName: string
    description: string | null
    icon: string | null
    questions: JsonValue
    chapters: JsonValue
    maturityLevels: JsonValue
    estimatedMonths: number
    typicalPrice: number | null
    sectorRelevance: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StandardConfigCountAggregateOutputType | null
    _avg: StandardConfigAvgAggregateOutputType | null
    _sum: StandardConfigSumAggregateOutputType | null
    _min: StandardConfigMinAggregateOutputType | null
    _max: StandardConfigMaxAggregateOutputType | null
  }

  type GetStandardConfigGroupByPayload<T extends StandardConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StandardConfigGroupByOutputType[P]>
        }
      >
    >


  export type StandardConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    standardType?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    icon?: boolean
    questions?: boolean
    chapters?: boolean
    maturityLevels?: boolean
    estimatedMonths?: boolean
    typicalPrice?: boolean
    sectorRelevance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["standardConfig"]>

  export type StandardConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    standardType?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    icon?: boolean
    questions?: boolean
    chapters?: boolean
    maturityLevels?: boolean
    estimatedMonths?: boolean
    typicalPrice?: boolean
    sectorRelevance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["standardConfig"]>

  export type StandardConfigSelectScalar = {
    id?: boolean
    standardType?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    icon?: boolean
    questions?: boolean
    chapters?: boolean
    maturityLevels?: boolean
    estimatedMonths?: boolean
    typicalPrice?: boolean
    sectorRelevance?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StandardConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StandardConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      standardType: string
      name: string
      shortName: string
      description: string | null
      icon: string | null
      questions: Prisma.JsonValue
      chapters: Prisma.JsonValue
      maturityLevels: Prisma.JsonValue
      estimatedMonths: number
      typicalPrice: number | null
      sectorRelevance: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["standardConfig"]>
    composites: {}
  }

  type StandardConfigGetPayload<S extends boolean | null | undefined | StandardConfigDefaultArgs> = $Result.GetResult<Prisma.$StandardConfigPayload, S>

  type StandardConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StandardConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StandardConfigCountAggregateInputType | true
    }

  export interface StandardConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StandardConfig'], meta: { name: 'StandardConfig' } }
    /**
     * Find zero or one StandardConfig that matches the filter.
     * @param {StandardConfigFindUniqueArgs} args - Arguments to find a StandardConfig
     * @example
     * // Get one StandardConfig
     * const standardConfig = await prisma.standardConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StandardConfigFindUniqueArgs>(args: SelectSubset<T, StandardConfigFindUniqueArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StandardConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StandardConfigFindUniqueOrThrowArgs} args - Arguments to find a StandardConfig
     * @example
     * // Get one StandardConfig
     * const standardConfig = await prisma.standardConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StandardConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StandardConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StandardConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigFindFirstArgs} args - Arguments to find a StandardConfig
     * @example
     * // Get one StandardConfig
     * const standardConfig = await prisma.standardConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StandardConfigFindFirstArgs>(args?: SelectSubset<T, StandardConfigFindFirstArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StandardConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigFindFirstOrThrowArgs} args - Arguments to find a StandardConfig
     * @example
     * // Get one StandardConfig
     * const standardConfig = await prisma.standardConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StandardConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StandardConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StandardConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StandardConfigs
     * const standardConfigs = await prisma.standardConfig.findMany()
     * 
     * // Get first 10 StandardConfigs
     * const standardConfigs = await prisma.standardConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const standardConfigWithIdOnly = await prisma.standardConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StandardConfigFindManyArgs>(args?: SelectSubset<T, StandardConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StandardConfig.
     * @param {StandardConfigCreateArgs} args - Arguments to create a StandardConfig.
     * @example
     * // Create one StandardConfig
     * const StandardConfig = await prisma.standardConfig.create({
     *   data: {
     *     // ... data to create a StandardConfig
     *   }
     * })
     * 
     */
    create<T extends StandardConfigCreateArgs>(args: SelectSubset<T, StandardConfigCreateArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StandardConfigs.
     * @param {StandardConfigCreateManyArgs} args - Arguments to create many StandardConfigs.
     * @example
     * // Create many StandardConfigs
     * const standardConfig = await prisma.standardConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StandardConfigCreateManyArgs>(args?: SelectSubset<T, StandardConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StandardConfigs and returns the data saved in the database.
     * @param {StandardConfigCreateManyAndReturnArgs} args - Arguments to create many StandardConfigs.
     * @example
     * // Create many StandardConfigs
     * const standardConfig = await prisma.standardConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StandardConfigs and only return the `id`
     * const standardConfigWithIdOnly = await prisma.standardConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StandardConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, StandardConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StandardConfig.
     * @param {StandardConfigDeleteArgs} args - Arguments to delete one StandardConfig.
     * @example
     * // Delete one StandardConfig
     * const StandardConfig = await prisma.standardConfig.delete({
     *   where: {
     *     // ... filter to delete one StandardConfig
     *   }
     * })
     * 
     */
    delete<T extends StandardConfigDeleteArgs>(args: SelectSubset<T, StandardConfigDeleteArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StandardConfig.
     * @param {StandardConfigUpdateArgs} args - Arguments to update one StandardConfig.
     * @example
     * // Update one StandardConfig
     * const standardConfig = await prisma.standardConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StandardConfigUpdateArgs>(args: SelectSubset<T, StandardConfigUpdateArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StandardConfigs.
     * @param {StandardConfigDeleteManyArgs} args - Arguments to filter StandardConfigs to delete.
     * @example
     * // Delete a few StandardConfigs
     * const { count } = await prisma.standardConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StandardConfigDeleteManyArgs>(args?: SelectSubset<T, StandardConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StandardConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StandardConfigs
     * const standardConfig = await prisma.standardConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StandardConfigUpdateManyArgs>(args: SelectSubset<T, StandardConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StandardConfig.
     * @param {StandardConfigUpsertArgs} args - Arguments to update or create a StandardConfig.
     * @example
     * // Update or create a StandardConfig
     * const standardConfig = await prisma.standardConfig.upsert({
     *   create: {
     *     // ... data to create a StandardConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StandardConfig we want to update
     *   }
     * })
     */
    upsert<T extends StandardConfigUpsertArgs>(args: SelectSubset<T, StandardConfigUpsertArgs<ExtArgs>>): Prisma__StandardConfigClient<$Result.GetResult<Prisma.$StandardConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StandardConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigCountArgs} args - Arguments to filter StandardConfigs to count.
     * @example
     * // Count the number of StandardConfigs
     * const count = await prisma.standardConfig.count({
     *   where: {
     *     // ... the filter for the StandardConfigs we want to count
     *   }
     * })
    **/
    count<T extends StandardConfigCountArgs>(
      args?: Subset<T, StandardConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StandardConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardConfigAggregateArgs>(args: Subset<T, StandardConfigAggregateArgs>): Prisma.PrismaPromise<GetStandardConfigAggregateType<T>>

    /**
     * Group by StandardConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StandardConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StandardConfigGroupByArgs['orderBy'] }
        : { orderBy?: StandardConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StandardConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StandardConfig model
   */
  readonly fields: StandardConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StandardConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StandardConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StandardConfig model
   */ 
  interface StandardConfigFieldRefs {
    readonly id: FieldRef<"StandardConfig", 'String'>
    readonly standardType: FieldRef<"StandardConfig", 'String'>
    readonly name: FieldRef<"StandardConfig", 'String'>
    readonly shortName: FieldRef<"StandardConfig", 'String'>
    readonly description: FieldRef<"StandardConfig", 'String'>
    readonly icon: FieldRef<"StandardConfig", 'String'>
    readonly questions: FieldRef<"StandardConfig", 'Json'>
    readonly chapters: FieldRef<"StandardConfig", 'Json'>
    readonly maturityLevels: FieldRef<"StandardConfig", 'Json'>
    readonly estimatedMonths: FieldRef<"StandardConfig", 'Int'>
    readonly typicalPrice: FieldRef<"StandardConfig", 'Int'>
    readonly sectorRelevance: FieldRef<"StandardConfig", 'Json'>
    readonly isActive: FieldRef<"StandardConfig", 'Boolean'>
    readonly createdAt: FieldRef<"StandardConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"StandardConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StandardConfig findUnique
   */
  export type StandardConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * Filter, which StandardConfig to fetch.
     */
    where: StandardConfigWhereUniqueInput
  }

  /**
   * StandardConfig findUniqueOrThrow
   */
  export type StandardConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * Filter, which StandardConfig to fetch.
     */
    where: StandardConfigWhereUniqueInput
  }

  /**
   * StandardConfig findFirst
   */
  export type StandardConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * Filter, which StandardConfig to fetch.
     */
    where?: StandardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardConfigs to fetch.
     */
    orderBy?: StandardConfigOrderByWithRelationInput | StandardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardConfigs.
     */
    cursor?: StandardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardConfigs.
     */
    distinct?: StandardConfigScalarFieldEnum | StandardConfigScalarFieldEnum[]
  }

  /**
   * StandardConfig findFirstOrThrow
   */
  export type StandardConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * Filter, which StandardConfig to fetch.
     */
    where?: StandardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardConfigs to fetch.
     */
    orderBy?: StandardConfigOrderByWithRelationInput | StandardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StandardConfigs.
     */
    cursor?: StandardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StandardConfigs.
     */
    distinct?: StandardConfigScalarFieldEnum | StandardConfigScalarFieldEnum[]
  }

  /**
   * StandardConfig findMany
   */
  export type StandardConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * Filter, which StandardConfigs to fetch.
     */
    where?: StandardConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StandardConfigs to fetch.
     */
    orderBy?: StandardConfigOrderByWithRelationInput | StandardConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StandardConfigs.
     */
    cursor?: StandardConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StandardConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StandardConfigs.
     */
    skip?: number
    distinct?: StandardConfigScalarFieldEnum | StandardConfigScalarFieldEnum[]
  }

  /**
   * StandardConfig create
   */
  export type StandardConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a StandardConfig.
     */
    data: XOR<StandardConfigCreateInput, StandardConfigUncheckedCreateInput>
  }

  /**
   * StandardConfig createMany
   */
  export type StandardConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StandardConfigs.
     */
    data: StandardConfigCreateManyInput | StandardConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardConfig createManyAndReturn
   */
  export type StandardConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StandardConfigs.
     */
    data: StandardConfigCreateManyInput | StandardConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StandardConfig update
   */
  export type StandardConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a StandardConfig.
     */
    data: XOR<StandardConfigUpdateInput, StandardConfigUncheckedUpdateInput>
    /**
     * Choose, which StandardConfig to update.
     */
    where: StandardConfigWhereUniqueInput
  }

  /**
   * StandardConfig updateMany
   */
  export type StandardConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StandardConfigs.
     */
    data: XOR<StandardConfigUpdateManyMutationInput, StandardConfigUncheckedUpdateManyInput>
    /**
     * Filter which StandardConfigs to update
     */
    where?: StandardConfigWhereInput
  }

  /**
   * StandardConfig upsert
   */
  export type StandardConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the StandardConfig to update in case it exists.
     */
    where: StandardConfigWhereUniqueInput
    /**
     * In case the StandardConfig found by the `where` argument doesn't exist, create a new StandardConfig with this data.
     */
    create: XOR<StandardConfigCreateInput, StandardConfigUncheckedCreateInput>
    /**
     * In case the StandardConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StandardConfigUpdateInput, StandardConfigUncheckedUpdateInput>
  }

  /**
   * StandardConfig delete
   */
  export type StandardConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
    /**
     * Filter which StandardConfig to delete.
     */
    where: StandardConfigWhereUniqueInput
  }

  /**
   * StandardConfig deleteMany
   */
  export type StandardConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StandardConfigs to delete
     */
    where?: StandardConfigWhereInput
  }

  /**
   * StandardConfig without action
   */
  export type StandardConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StandardConfig
     */
    select?: StandardConfigSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    eventType: 'eventType',
    eventData: 'eventData',
    page: 'page',
    referrer: 'referrer',
    userAgent: 'userAgent',
    ip: 'ip',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const DailyStatScalarFieldEnum: {
    id: 'id',
    date: 'date',
    totalEvents: 'totalEvents',
    uniqueUsers: 'uniqueUsers',
    uniqueSessions: 'uniqueSessions',
    pageViews: 'pageViews',
    quizStarted: 'quizStarted',
    quizCompleted: 'quizCompleted',
    modulesViewed: 'modulesViewed',
    lessonsCompleted: 'lessonsCompleted',
    avgSessionDuration: 'avgSessionDuration',
    eventsByType: 'eventsByType',
    topPages: 'topPages',
    topModules: 'topModules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyStatScalarFieldEnum = (typeof DailyStatScalarFieldEnum)[keyof typeof DailyStatScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalXp: 'totalXp',
    currentLevel: 'currentLevel',
    modulesStarted: 'modulesStarted',
    modulesCompleted: 'modulesCompleted',
    quizzesCompleted: 'quizzesCompleted',
    totalCorrect: 'totalCorrect',
    totalQuestions: 'totalQuestions',
    avgScore: 'avgScore',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastActiveAt: 'lastActiveAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const AlertRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    metric: 'metric',
    operator: 'operator',
    threshold: 'threshold',
    duration: 'duration',
    targetType: 'targetType',
    targetId: 'targetId',
    severity: 'severity',
    notifyChannels: 'notifyChannels',
    notifyRoles: 'notifyRoles',
    cooldownMinutes: 'cooldownMinutes',
    lastTriggeredAt: 'lastTriggeredAt',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertRuleScalarFieldEnum = (typeof AlertRuleScalarFieldEnum)[keyof typeof AlertRuleScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    ruleId: 'ruleId',
    severity: 'severity',
    title: 'title',
    description: 'description',
    affectedUserId: 'affectedUserId',
    affectedEntityType: 'affectedEntityType',
    affectedEntityId: 'affectedEntityId',
    triggerMetric: 'triggerMetric',
    triggerValue: 'triggerValue',
    triggerThreshold: 'triggerThreshold',
    recommendedActions: 'recommendedActions',
    status: 'status',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgedBy: 'acknowledgedBy',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    link: 'link',
    icon: 'icon',
    alertId: 'alertId',
    read: 'read',
    readAt: 'readAt',
    emailSent: 'emailSent',
    emailSentAt: 'emailSentAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ReportTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    format: 'format',
    config: 'config',
    scheduleEnabled: 'scheduleEnabled',
    scheduleCron: 'scheduleCron',
    recipients: 'recipients',
    isSystem: 'isSystem',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportTemplateScalarFieldEnum = (typeof ReportTemplateScalarFieldEnum)[keyof typeof ReportTemplateScalarFieldEnum]


  export const GeneratedReportScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    name: 'name',
    type: 'type',
    format: 'format',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    requestedBy: 'requestedBy',
    generatedAt: 'generatedAt',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    status: 'status',
    errorMessage: 'errorMessage',
    emailed: 'emailed',
    emailedAt: 'emailedAt',
    downloadCount: 'downloadCount',
    createdAt: 'createdAt'
  };

  export type GeneratedReportScalarFieldEnum = (typeof GeneratedReportScalarFieldEnum)[keyof typeof GeneratedReportScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    industry: 'industry',
    employeeCount: 'employeeCount',
    logo: 'logo',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    timezone: 'timezone',
    language: 'language',
    plan: 'plan',
    planSeats: 'planSeats',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    description: 'description',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    organizationId: 'organizationId',
    departmentId: 'departmentId',
    role: 'role',
    status: 'status',
    position: 'position',
    companyName: 'companyName',
    companySize: 'companySize',
    industrySector: 'industrySector',
    targetStandard: 'targetStandard',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionStartDate: 'subscriptionStartDate',
    subscriptionEndDate: 'subscriptionEndDate',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    onboardingCompletedSteps: 'onboardingCompletedSteps',
    lastLoginAt: 'lastLoginAt',
    invitedAt: 'invitedAt',
    invitedBy: 'invitedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ManagerNoteScalarFieldEnum: {
    id: 'id',
    aboutUserId: 'aboutUserId',
    byUserId: 'byUserId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManagerNoteScalarFieldEnum = (typeof ManagerNoteScalarFieldEnum)[keyof typeof ManagerNoteScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    title: 'title',
    description: 'description',
    coverImage: 'coverImage',
    category: 'category',
    tags: 'tags',
    difficulty: 'difficulty',
    estimatedDuration: 'estimatedDuration',
    sections: 'sections',
    xpReward: 'xpReward',
    badge: 'badge',
    status: 'status',
    publishedAt: 'publishedAt',
    completionCount: 'completionCount',
    avgScore: 'avgScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const ModulePrerequisiteScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    prerequisiteId: 'prerequisiteId'
  };

  export type ModulePrerequisiteScalarFieldEnum = (typeof ModulePrerequisiteScalarFieldEnum)[keyof typeof ModulePrerequisiteScalarFieldEnum]


  export const ModuleAssignmentScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    assignedToId: 'assignedToId',
    assignedById: 'assignedById',
    priority: 'priority',
    deadline: 'deadline',
    message: 'message',
    status: 'status',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type ModuleAssignmentScalarFieldEnum = (typeof ModuleAssignmentScalarFieldEnum)[keyof typeof ModuleAssignmentScalarFieldEnum]


  export const ModuleProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    moduleId: 'moduleId',
    status: 'status',
    progressPercent: 'progressPercent',
    completedSections: 'completedSections',
    timeSpentSeconds: 'timeSpentSeconds',
    quizScore: 'quizScore',
    quizAttempts: 'quizAttempts',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleProgressScalarFieldEnum = (typeof ModuleProgressScalarFieldEnum)[keyof typeof ModuleProgressScalarFieldEnum]


  export const AssessmentTemplateScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    name: 'name',
    description: 'description',
    certification: 'certification',
    version: 'version',
    estimatedDuration: 'estimatedDuration',
    sections: 'sections',
    scoringMethod: 'scoringMethod',
    maturityLevels: 'maturityLevels',
    status: 'status',
    isDemo: 'isDemo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssessmentTemplateScalarFieldEnum = (typeof AssessmentTemplateScalarFieldEnum)[keyof typeof AssessmentTemplateScalarFieldEnum]


  export const AssessmentSessionScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    userId: 'userId',
    email: 'email',
    companyName: 'companyName',
    industry: 'industry',
    employeeCount: 'employeeCount',
    answers: 'answers',
    sectionScores: 'sectionScores',
    overallScore: 'overallScore',
    maturityLevel: 'maturityLevel',
    gapAnalysis: 'gapAnalysis',
    recommendations: 'recommendations',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    convertedToSignup: 'convertedToSignup',
    pdfDownloaded: 'pdfDownloaded',
    createdAt: 'createdAt'
  };

  export type AssessmentSessionScalarFieldEnum = (typeof AssessmentSessionScalarFieldEnum)[keyof typeof AssessmentSessionScalarFieldEnum]


  export const UserCertificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    certification: 'certification',
    level: 'level',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    status: 'status',
    certificateUrl: 'certificateUrl',
    verificationCode: 'verificationCode',
    createdAt: 'createdAt'
  };

  export type UserCertificationScalarFieldEnum = (typeof UserCertificationScalarFieldEnum)[keyof typeof UserCertificationScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assessmentSessionId: 'assessmentSessionId',
    standardType: 'standardType',
    totalSprints: 'totalSprints',
    currentSprint: 'currentSprint',
    sprintDurationWeeks: 'sprintDurationWeeks',
    completionPercentage: 'completionPercentage',
    estimatedCompletionDate: 'estimatedCompletionDate',
    status: 'status',
    sprintDetails: 'sprintDetails',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    standardType: 'standardType',
    actionCode: 'actionCode',
    title: 'title',
    description: 'description',
    requirementRef: 'requirementRef',
    chapterNumber: 'chapterNumber',
    estimatedHours: 'estimatedHours',
    priorityWeight: 'priorityWeight',
    category: 'category',
    sectorVariations: 'sectorVariations',
    templateIds: 'templateIds',
    videoUrl: 'videoUrl',
    dependsOnActions: 'dependsOnActions',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const UserActionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roadmapId: 'roadmapId',
    actionId: 'actionId',
    sprintNumber: 'sprintNumber',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    notes: 'notes',
    blockedReason: 'blockedReason',
    uploadedFiles: 'uploadedFiles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserActionScalarFieldEnum = (typeof UserActionScalarFieldEnum)[keyof typeof UserActionScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    standardType: 'standardType',
    templateCode: 'templateCode',
    title: 'title',
    description: 'description',
    category: 'category',
    fileUrl: 'fileUrl',
    fileFormat: 'fileFormat',
    fileSize: 'fileSize',
    requirementRef: 'requirementRef',
    sectorAdaptations: 'sectorAdaptations',
    relatedActionCodes: 'relatedActionCodes',
    downloadCount: 'downloadCount',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const StandardConfigScalarFieldEnum: {
    id: 'id',
    standardType: 'standardType',
    name: 'name',
    shortName: 'shortName',
    description: 'description',
    icon: 'icon',
    questions: 'questions',
    chapters: 'chapters',
    maturityLevels: 'maturityLevels',
    estimatedMonths: 'estimatedMonths',
    typicalPrice: 'typicalPrice',
    sectorRelevance: 'sectorRelevance',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StandardConfigScalarFieldEnum = (typeof StandardConfigScalarFieldEnum)[keyof typeof StandardConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    userId?: StringNullableFilter<"Event"> | string | null
    sessionId?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    eventData?: JsonNullableFilter<"Event">
    page?: StringNullableFilter<"Event"> | string | null
    referrer?: StringNullableFilter<"Event"> | string | null
    userAgent?: StringNullableFilter<"Event"> | string | null
    ip?: StringNullableFilter<"Event"> | string | null
    timestamp?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrderInput | SortOrder
    page?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    userId?: StringNullableFilter<"Event"> | string | null
    sessionId?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    eventData?: JsonNullableFilter<"Event">
    page?: StringNullableFilter<"Event"> | string | null
    referrer?: StringNullableFilter<"Event"> | string | null
    userAgent?: StringNullableFilter<"Event"> | string | null
    ip?: StringNullableFilter<"Event"> | string | null
    timestamp?: DateTimeFilter<"Event"> | Date | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    sessionId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrderInput | SortOrder
    page?: SortOrderInput | SortOrder
    referrer?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    userId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    sessionId?: StringWithAggregatesFilter<"Event"> | string
    eventType?: StringWithAggregatesFilter<"Event"> | string
    eventData?: JsonNullableWithAggregatesFilter<"Event">
    page?: StringNullableWithAggregatesFilter<"Event"> | string | null
    referrer?: StringNullableWithAggregatesFilter<"Event"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Event"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Event"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type DailyStatWhereInput = {
    AND?: DailyStatWhereInput | DailyStatWhereInput[]
    OR?: DailyStatWhereInput[]
    NOT?: DailyStatWhereInput | DailyStatWhereInput[]
    id?: StringFilter<"DailyStat"> | string
    date?: DateTimeFilter<"DailyStat"> | Date | string
    totalEvents?: IntFilter<"DailyStat"> | number
    uniqueUsers?: IntFilter<"DailyStat"> | number
    uniqueSessions?: IntFilter<"DailyStat"> | number
    pageViews?: IntFilter<"DailyStat"> | number
    quizStarted?: IntFilter<"DailyStat"> | number
    quizCompleted?: IntFilter<"DailyStat"> | number
    modulesViewed?: IntFilter<"DailyStat"> | number
    lessonsCompleted?: IntFilter<"DailyStat"> | number
    avgSessionDuration?: FloatFilter<"DailyStat"> | number
    eventsByType?: JsonNullableFilter<"DailyStat">
    topPages?: JsonNullableFilter<"DailyStat">
    topModules?: JsonNullableFilter<"DailyStat">
    createdAt?: DateTimeFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStat"> | Date | string
  }

  export type DailyStatOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
    eventsByType?: SortOrderInput | SortOrder
    topPages?: SortOrderInput | SortOrder
    topModules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    date?: Date | string
    AND?: DailyStatWhereInput | DailyStatWhereInput[]
    OR?: DailyStatWhereInput[]
    NOT?: DailyStatWhereInput | DailyStatWhereInput[]
    totalEvents?: IntFilter<"DailyStat"> | number
    uniqueUsers?: IntFilter<"DailyStat"> | number
    uniqueSessions?: IntFilter<"DailyStat"> | number
    pageViews?: IntFilter<"DailyStat"> | number
    quizStarted?: IntFilter<"DailyStat"> | number
    quizCompleted?: IntFilter<"DailyStat"> | number
    modulesViewed?: IntFilter<"DailyStat"> | number
    lessonsCompleted?: IntFilter<"DailyStat"> | number
    avgSessionDuration?: FloatFilter<"DailyStat"> | number
    eventsByType?: JsonNullableFilter<"DailyStat">
    topPages?: JsonNullableFilter<"DailyStat">
    topModules?: JsonNullableFilter<"DailyStat">
    createdAt?: DateTimeFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeFilter<"DailyStat"> | Date | string
  }, "id" | "date">

  export type DailyStatOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
    eventsByType?: SortOrderInput | SortOrder
    topPages?: SortOrderInput | SortOrder
    topModules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyStatCountOrderByAggregateInput
    _avg?: DailyStatAvgOrderByAggregateInput
    _max?: DailyStatMaxOrderByAggregateInput
    _min?: DailyStatMinOrderByAggregateInput
    _sum?: DailyStatSumOrderByAggregateInput
  }

  export type DailyStatScalarWhereWithAggregatesInput = {
    AND?: DailyStatScalarWhereWithAggregatesInput | DailyStatScalarWhereWithAggregatesInput[]
    OR?: DailyStatScalarWhereWithAggregatesInput[]
    NOT?: DailyStatScalarWhereWithAggregatesInput | DailyStatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyStat"> | string
    date?: DateTimeWithAggregatesFilter<"DailyStat"> | Date | string
    totalEvents?: IntWithAggregatesFilter<"DailyStat"> | number
    uniqueUsers?: IntWithAggregatesFilter<"DailyStat"> | number
    uniqueSessions?: IntWithAggregatesFilter<"DailyStat"> | number
    pageViews?: IntWithAggregatesFilter<"DailyStat"> | number
    quizStarted?: IntWithAggregatesFilter<"DailyStat"> | number
    quizCompleted?: IntWithAggregatesFilter<"DailyStat"> | number
    modulesViewed?: IntWithAggregatesFilter<"DailyStat"> | number
    lessonsCompleted?: IntWithAggregatesFilter<"DailyStat"> | number
    avgSessionDuration?: FloatWithAggregatesFilter<"DailyStat"> | number
    eventsByType?: JsonNullableWithAggregatesFilter<"DailyStat">
    topPages?: JsonNullableWithAggregatesFilter<"DailyStat">
    topModules?: JsonNullableWithAggregatesFilter<"DailyStat">
    createdAt?: DateTimeWithAggregatesFilter<"DailyStat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyStat"> | Date | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    totalXp?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    modulesStarted?: StringNullableListFilter<"UserProgress">
    modulesCompleted?: StringNullableListFilter<"UserProgress">
    quizzesCompleted?: IntFilter<"UserProgress"> | number
    totalCorrect?: IntFilter<"UserProgress"> | number
    totalQuestions?: IntFilter<"UserProgress"> | number
    avgScore?: FloatFilter<"UserProgress"> | number
    currentStreak?: IntFilter<"UserProgress"> | number
    longestStreak?: IntFilter<"UserProgress"> | number
    lastActiveAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    currentLevel?: SortOrder
    modulesStarted?: SortOrder
    modulesCompleted?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    totalXp?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    modulesStarted?: StringNullableListFilter<"UserProgress">
    modulesCompleted?: StringNullableListFilter<"UserProgress">
    quizzesCompleted?: IntFilter<"UserProgress"> | number
    totalCorrect?: IntFilter<"UserProgress"> | number
    totalQuestions?: IntFilter<"UserProgress"> | number
    avgScore?: FloatFilter<"UserProgress"> | number
    currentStreak?: IntFilter<"UserProgress"> | number
    longestStreak?: IntFilter<"UserProgress"> | number
    lastActiveAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }, "id" | "userId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    currentLevel?: SortOrder
    modulesStarted?: SortOrder
    modulesCompleted?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    totalXp?: IntWithAggregatesFilter<"UserProgress"> | number
    currentLevel?: IntWithAggregatesFilter<"UserProgress"> | number
    modulesStarted?: StringNullableListFilter<"UserProgress">
    modulesCompleted?: StringNullableListFilter<"UserProgress">
    quizzesCompleted?: IntWithAggregatesFilter<"UserProgress"> | number
    totalCorrect?: IntWithAggregatesFilter<"UserProgress"> | number
    totalQuestions?: IntWithAggregatesFilter<"UserProgress"> | number
    avgScore?: FloatWithAggregatesFilter<"UserProgress"> | number
    currentStreak?: IntWithAggregatesFilter<"UserProgress"> | number
    longestStreak?: IntWithAggregatesFilter<"UserProgress"> | number
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"UserProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type AlertRuleWhereInput = {
    AND?: AlertRuleWhereInput | AlertRuleWhereInput[]
    OR?: AlertRuleWhereInput[]
    NOT?: AlertRuleWhereInput | AlertRuleWhereInput[]
    id?: StringFilter<"AlertRule"> | string
    name?: StringFilter<"AlertRule"> | string
    description?: StringNullableFilter<"AlertRule"> | string | null
    metric?: StringFilter<"AlertRule"> | string
    operator?: StringFilter<"AlertRule"> | string
    threshold?: FloatFilter<"AlertRule"> | number
    duration?: IntNullableFilter<"AlertRule"> | number | null
    targetType?: StringFilter<"AlertRule"> | string
    targetId?: StringNullableFilter<"AlertRule"> | string | null
    severity?: StringFilter<"AlertRule"> | string
    notifyChannels?: StringNullableListFilter<"AlertRule">
    notifyRoles?: StringNullableListFilter<"AlertRule">
    cooldownMinutes?: IntFilter<"AlertRule"> | number
    lastTriggeredAt?: DateTimeNullableFilter<"AlertRule"> | Date | string | null
    enabled?: BoolFilter<"AlertRule"> | boolean
    createdAt?: DateTimeFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeFilter<"AlertRule"> | Date | string
    alerts?: AlertListRelationFilter
  }

  export type AlertRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metric?: SortOrder
    operator?: SortOrder
    threshold?: SortOrder
    duration?: SortOrderInput | SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    severity?: SortOrder
    notifyChannels?: SortOrder
    notifyRoles?: SortOrder
    cooldownMinutes?: SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    alerts?: AlertOrderByRelationAggregateInput
  }

  export type AlertRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertRuleWhereInput | AlertRuleWhereInput[]
    OR?: AlertRuleWhereInput[]
    NOT?: AlertRuleWhereInput | AlertRuleWhereInput[]
    name?: StringFilter<"AlertRule"> | string
    description?: StringNullableFilter<"AlertRule"> | string | null
    metric?: StringFilter<"AlertRule"> | string
    operator?: StringFilter<"AlertRule"> | string
    threshold?: FloatFilter<"AlertRule"> | number
    duration?: IntNullableFilter<"AlertRule"> | number | null
    targetType?: StringFilter<"AlertRule"> | string
    targetId?: StringNullableFilter<"AlertRule"> | string | null
    severity?: StringFilter<"AlertRule"> | string
    notifyChannels?: StringNullableListFilter<"AlertRule">
    notifyRoles?: StringNullableListFilter<"AlertRule">
    cooldownMinutes?: IntFilter<"AlertRule"> | number
    lastTriggeredAt?: DateTimeNullableFilter<"AlertRule"> | Date | string | null
    enabled?: BoolFilter<"AlertRule"> | boolean
    createdAt?: DateTimeFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeFilter<"AlertRule"> | Date | string
    alerts?: AlertListRelationFilter
  }, "id">

  export type AlertRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    metric?: SortOrder
    operator?: SortOrder
    threshold?: SortOrder
    duration?: SortOrderInput | SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    severity?: SortOrder
    notifyChannels?: SortOrder
    notifyRoles?: SortOrder
    cooldownMinutes?: SortOrder
    lastTriggeredAt?: SortOrderInput | SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertRuleCountOrderByAggregateInput
    _avg?: AlertRuleAvgOrderByAggregateInput
    _max?: AlertRuleMaxOrderByAggregateInput
    _min?: AlertRuleMinOrderByAggregateInput
    _sum?: AlertRuleSumOrderByAggregateInput
  }

  export type AlertRuleScalarWhereWithAggregatesInput = {
    AND?: AlertRuleScalarWhereWithAggregatesInput | AlertRuleScalarWhereWithAggregatesInput[]
    OR?: AlertRuleScalarWhereWithAggregatesInput[]
    NOT?: AlertRuleScalarWhereWithAggregatesInput | AlertRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AlertRule"> | string
    name?: StringWithAggregatesFilter<"AlertRule"> | string
    description?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    metric?: StringWithAggregatesFilter<"AlertRule"> | string
    operator?: StringWithAggregatesFilter<"AlertRule"> | string
    threshold?: FloatWithAggregatesFilter<"AlertRule"> | number
    duration?: IntNullableWithAggregatesFilter<"AlertRule"> | number | null
    targetType?: StringWithAggregatesFilter<"AlertRule"> | string
    targetId?: StringNullableWithAggregatesFilter<"AlertRule"> | string | null
    severity?: StringWithAggregatesFilter<"AlertRule"> | string
    notifyChannels?: StringNullableListFilter<"AlertRule">
    notifyRoles?: StringNullableListFilter<"AlertRule">
    cooldownMinutes?: IntWithAggregatesFilter<"AlertRule"> | number
    lastTriggeredAt?: DateTimeNullableWithAggregatesFilter<"AlertRule"> | Date | string | null
    enabled?: BoolWithAggregatesFilter<"AlertRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AlertRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AlertRule"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    ruleId?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    title?: StringFilter<"Alert"> | string
    description?: StringNullableFilter<"Alert"> | string | null
    affectedUserId?: StringNullableFilter<"Alert"> | string | null
    affectedEntityType?: StringNullableFilter<"Alert"> | string | null
    affectedEntityId?: StringNullableFilter<"Alert"> | string | null
    triggerMetric?: StringFilter<"Alert"> | string
    triggerValue?: FloatFilter<"Alert"> | number
    triggerThreshold?: FloatFilter<"Alert"> | number
    recommendedActions?: StringNullableListFilter<"Alert">
    status?: StringFilter<"Alert"> | string
    acknowledgedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Alert"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    rule?: XOR<AlertRuleRelationFilter, AlertRuleWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    affectedUserId?: SortOrderInput | SortOrder
    affectedEntityType?: SortOrderInput | SortOrder
    affectedEntityId?: SortOrderInput | SortOrder
    triggerMetric?: SortOrder
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
    recommendedActions?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rule?: AlertRuleOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    ruleId?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    title?: StringFilter<"Alert"> | string
    description?: StringNullableFilter<"Alert"> | string | null
    affectedUserId?: StringNullableFilter<"Alert"> | string | null
    affectedEntityType?: StringNullableFilter<"Alert"> | string | null
    affectedEntityId?: StringNullableFilter<"Alert"> | string | null
    triggerMetric?: StringFilter<"Alert"> | string
    triggerValue?: FloatFilter<"Alert"> | number
    triggerThreshold?: FloatFilter<"Alert"> | number
    recommendedActions?: StringNullableListFilter<"Alert">
    status?: StringFilter<"Alert"> | string
    acknowledgedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Alert"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    rule?: XOR<AlertRuleRelationFilter, AlertRuleWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    affectedUserId?: SortOrderInput | SortOrder
    affectedEntityType?: SortOrderInput | SortOrder
    affectedEntityId?: SortOrderInput | SortOrder
    triggerMetric?: SortOrder
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
    recommendedActions?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _avg?: AlertAvgOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
    _sum?: AlertSumOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    ruleId?: StringWithAggregatesFilter<"Alert"> | string
    severity?: StringWithAggregatesFilter<"Alert"> | string
    title?: StringWithAggregatesFilter<"Alert"> | string
    description?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    affectedUserId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    affectedEntityType?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    affectedEntityId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    triggerMetric?: StringWithAggregatesFilter<"Alert"> | string
    triggerValue?: FloatWithAggregatesFilter<"Alert"> | number
    triggerThreshold?: FloatWithAggregatesFilter<"Alert"> | number
    recommendedActions?: StringNullableListFilter<"Alert">
    status?: StringWithAggregatesFilter<"Alert"> | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    acknowledgedBy?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    alertId?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    emailSent?: BoolFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    alert?: XOR<AlertNullableRelationFilter, AlertWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    alertId?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    alert?: AlertOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    alertId?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    emailSent?: BoolFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    alert?: XOR<AlertNullableRelationFilter, AlertWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    alertId?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    alertId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    emailSent?: BoolWithAggregatesFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ReportTemplateWhereInput = {
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    type?: StringFilter<"ReportTemplate"> | string
    format?: StringFilter<"ReportTemplate"> | string
    config?: JsonNullableFilter<"ReportTemplate">
    scheduleEnabled?: BoolFilter<"ReportTemplate"> | boolean
    scheduleCron?: StringNullableFilter<"ReportTemplate"> | string | null
    recipients?: StringNullableListFilter<"ReportTemplate">
    isSystem?: BoolFilter<"ReportTemplate"> | boolean
    createdBy?: StringNullableFilter<"ReportTemplate"> | string | null
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    reports?: GeneratedReportListRelationFilter
  }

  export type ReportTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    format?: SortOrder
    config?: SortOrderInput | SortOrder
    scheduleEnabled?: SortOrder
    scheduleCron?: SortOrderInput | SortOrder
    recipients?: SortOrder
    isSystem?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reports?: GeneratedReportOrderByRelationAggregateInput
  }

  export type ReportTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    type?: StringFilter<"ReportTemplate"> | string
    format?: StringFilter<"ReportTemplate"> | string
    config?: JsonNullableFilter<"ReportTemplate">
    scheduleEnabled?: BoolFilter<"ReportTemplate"> | boolean
    scheduleCron?: StringNullableFilter<"ReportTemplate"> | string | null
    recipients?: StringNullableListFilter<"ReportTemplate">
    isSystem?: BoolFilter<"ReportTemplate"> | boolean
    createdBy?: StringNullableFilter<"ReportTemplate"> | string | null
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    reports?: GeneratedReportListRelationFilter
  }, "id">

  export type ReportTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    format?: SortOrder
    config?: SortOrderInput | SortOrder
    scheduleEnabled?: SortOrder
    scheduleCron?: SortOrderInput | SortOrder
    recipients?: SortOrder
    isSystem?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportTemplateCountOrderByAggregateInput
    _max?: ReportTemplateMaxOrderByAggregateInput
    _min?: ReportTemplateMinOrderByAggregateInput
  }

  export type ReportTemplateScalarWhereWithAggregatesInput = {
    AND?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    OR?: ReportTemplateScalarWhereWithAggregatesInput[]
    NOT?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportTemplate"> | string
    name?: StringWithAggregatesFilter<"ReportTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    type?: StringWithAggregatesFilter<"ReportTemplate"> | string
    format?: StringWithAggregatesFilter<"ReportTemplate"> | string
    config?: JsonNullableWithAggregatesFilter<"ReportTemplate">
    scheduleEnabled?: BoolWithAggregatesFilter<"ReportTemplate"> | boolean
    scheduleCron?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    recipients?: StringNullableListFilter<"ReportTemplate">
    isSystem?: BoolWithAggregatesFilter<"ReportTemplate"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
  }

  export type GeneratedReportWhereInput = {
    AND?: GeneratedReportWhereInput | GeneratedReportWhereInput[]
    OR?: GeneratedReportWhereInput[]
    NOT?: GeneratedReportWhereInput | GeneratedReportWhereInput[]
    id?: StringFilter<"GeneratedReport"> | string
    templateId?: StringNullableFilter<"GeneratedReport"> | string | null
    name?: StringFilter<"GeneratedReport"> | string
    type?: StringFilter<"GeneratedReport"> | string
    format?: StringFilter<"GeneratedReport"> | string
    periodStart?: DateTimeFilter<"GeneratedReport"> | Date | string
    periodEnd?: DateTimeFilter<"GeneratedReport"> | Date | string
    requestedBy?: StringNullableFilter<"GeneratedReport"> | string | null
    generatedAt?: DateTimeFilter<"GeneratedReport"> | Date | string
    filePath?: StringNullableFilter<"GeneratedReport"> | string | null
    fileSize?: IntNullableFilter<"GeneratedReport"> | number | null
    mimeType?: StringNullableFilter<"GeneratedReport"> | string | null
    status?: StringFilter<"GeneratedReport"> | string
    errorMessage?: StringNullableFilter<"GeneratedReport"> | string | null
    emailed?: BoolFilter<"GeneratedReport"> | boolean
    emailedAt?: DateTimeNullableFilter<"GeneratedReport"> | Date | string | null
    downloadCount?: IntFilter<"GeneratedReport"> | number
    createdAt?: DateTimeFilter<"GeneratedReport"> | Date | string
    template?: XOR<ReportTemplateNullableRelationFilter, ReportTemplateWhereInput> | null
  }

  export type GeneratedReportOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    requestedBy?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    emailed?: SortOrder
    emailedAt?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    template?: ReportTemplateOrderByWithRelationInput
  }

  export type GeneratedReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GeneratedReportWhereInput | GeneratedReportWhereInput[]
    OR?: GeneratedReportWhereInput[]
    NOT?: GeneratedReportWhereInput | GeneratedReportWhereInput[]
    templateId?: StringNullableFilter<"GeneratedReport"> | string | null
    name?: StringFilter<"GeneratedReport"> | string
    type?: StringFilter<"GeneratedReport"> | string
    format?: StringFilter<"GeneratedReport"> | string
    periodStart?: DateTimeFilter<"GeneratedReport"> | Date | string
    periodEnd?: DateTimeFilter<"GeneratedReport"> | Date | string
    requestedBy?: StringNullableFilter<"GeneratedReport"> | string | null
    generatedAt?: DateTimeFilter<"GeneratedReport"> | Date | string
    filePath?: StringNullableFilter<"GeneratedReport"> | string | null
    fileSize?: IntNullableFilter<"GeneratedReport"> | number | null
    mimeType?: StringNullableFilter<"GeneratedReport"> | string | null
    status?: StringFilter<"GeneratedReport"> | string
    errorMessage?: StringNullableFilter<"GeneratedReport"> | string | null
    emailed?: BoolFilter<"GeneratedReport"> | boolean
    emailedAt?: DateTimeNullableFilter<"GeneratedReport"> | Date | string | null
    downloadCount?: IntFilter<"GeneratedReport"> | number
    createdAt?: DateTimeFilter<"GeneratedReport"> | Date | string
    template?: XOR<ReportTemplateNullableRelationFilter, ReportTemplateWhereInput> | null
  }, "id">

  export type GeneratedReportOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    requestedBy?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    filePath?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    emailed?: SortOrder
    emailedAt?: SortOrderInput | SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
    _count?: GeneratedReportCountOrderByAggregateInput
    _avg?: GeneratedReportAvgOrderByAggregateInput
    _max?: GeneratedReportMaxOrderByAggregateInput
    _min?: GeneratedReportMinOrderByAggregateInput
    _sum?: GeneratedReportSumOrderByAggregateInput
  }

  export type GeneratedReportScalarWhereWithAggregatesInput = {
    AND?: GeneratedReportScalarWhereWithAggregatesInput | GeneratedReportScalarWhereWithAggregatesInput[]
    OR?: GeneratedReportScalarWhereWithAggregatesInput[]
    NOT?: GeneratedReportScalarWhereWithAggregatesInput | GeneratedReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneratedReport"> | string
    templateId?: StringNullableWithAggregatesFilter<"GeneratedReport"> | string | null
    name?: StringWithAggregatesFilter<"GeneratedReport"> | string
    type?: StringWithAggregatesFilter<"GeneratedReport"> | string
    format?: StringWithAggregatesFilter<"GeneratedReport"> | string
    periodStart?: DateTimeWithAggregatesFilter<"GeneratedReport"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"GeneratedReport"> | Date | string
    requestedBy?: StringNullableWithAggregatesFilter<"GeneratedReport"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"GeneratedReport"> | Date | string
    filePath?: StringNullableWithAggregatesFilter<"GeneratedReport"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"GeneratedReport"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"GeneratedReport"> | string | null
    status?: StringWithAggregatesFilter<"GeneratedReport"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"GeneratedReport"> | string | null
    emailed?: BoolWithAggregatesFilter<"GeneratedReport"> | boolean
    emailedAt?: DateTimeNullableWithAggregatesFilter<"GeneratedReport"> | Date | string | null
    downloadCount?: IntWithAggregatesFilter<"GeneratedReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedReport"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    industry?: StringNullableFilter<"Organization"> | string | null
    employeeCount?: IntNullableFilter<"Organization"> | number | null
    logo?: StringNullableFilter<"Organization"> | string | null
    primaryColor?: StringNullableFilter<"Organization"> | string | null
    secondaryColor?: StringNullableFilter<"Organization"> | string | null
    timezone?: StringFilter<"Organization"> | string
    language?: StringFilter<"Organization"> | string
    plan?: StringFilter<"Organization"> | string
    planSeats?: IntFilter<"Organization"> | number
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    departments?: DepartmentListRelationFilter
    users?: UserListRelationFilter
    modules?: ModuleListRelationFilter
    assessmentTemplates?: AssessmentTemplateListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industry?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    plan?: SortOrder
    planSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    departments?: DepartmentOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    assessmentTemplates?: AssessmentTemplateOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    industry?: StringNullableFilter<"Organization"> | string | null
    employeeCount?: IntNullableFilter<"Organization"> | number | null
    logo?: StringNullableFilter<"Organization"> | string | null
    primaryColor?: StringNullableFilter<"Organization"> | string | null
    secondaryColor?: StringNullableFilter<"Organization"> | string | null
    timezone?: StringFilter<"Organization"> | string
    language?: StringFilter<"Organization"> | string
    plan?: StringFilter<"Organization"> | string
    planSeats?: IntFilter<"Organization"> | number
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    departments?: DepartmentListRelationFilter
    users?: UserListRelationFilter
    modules?: ModuleListRelationFilter
    assessmentTemplates?: AssessmentTemplateListRelationFilter
  }, "id" | "slug">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industry?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    plan?: SortOrder
    planSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    industry?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    employeeCount?: IntNullableWithAggregatesFilter<"Organization"> | number | null
    logo?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    timezone?: StringWithAggregatesFilter<"Organization"> | string
    language?: StringWithAggregatesFilter<"Organization"> | string
    plan?: StringWithAggregatesFilter<"Organization"> | string
    planSeats?: IntWithAggregatesFilter<"Organization"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    organizationId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    members?: UserListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    members?: UserOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_name?: DepartmentOrganizationIdNameCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    organizationId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    members?: UserListRelationFilter
  }, "id" | "organizationId_name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    organizationId?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    position?: StringNullableFilter<"User"> | string | null
    companyName?: StringNullableFilter<"User"> | string | null
    companySize?: StringNullableFilter<"User"> | string | null
    industrySector?: StringNullableFilter<"User"> | string | null
    targetStandard?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: StringFilter<"User"> | string
    subscriptionStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    onboardingCompletedSteps?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    invitedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    invitedBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    managerNotes?: ManagerNoteListRelationFilter
    notesWritten?: ManagerNoteListRelationFilter
    managedDepartments?: DepartmentListRelationFilter
    assignmentsReceived?: ModuleAssignmentListRelationFilter
    assignmentsMade?: ModuleAssignmentListRelationFilter
    moduleProgress?: ModuleProgressListRelationFilter
    assessmentSessions?: AssessmentSessionListRelationFilter
    certifications?: UserCertificationListRelationFilter
    roadmaps?: RoadmapListRelationFilter
    userActions?: UserActionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    position?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    industrySector?: SortOrderInput | SortOrder
    targetStandard?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrderInput | SortOrder
    subscriptionEndDate?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    onboardingCompletedSteps?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    invitedAt?: SortOrderInput | SortOrder
    invitedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    managerNotes?: ManagerNoteOrderByRelationAggregateInput
    notesWritten?: ManagerNoteOrderByRelationAggregateInput
    managedDepartments?: DepartmentOrderByRelationAggregateInput
    assignmentsReceived?: ModuleAssignmentOrderByRelationAggregateInput
    assignmentsMade?: ModuleAssignmentOrderByRelationAggregateInput
    moduleProgress?: ModuleProgressOrderByRelationAggregateInput
    assessmentSessions?: AssessmentSessionOrderByRelationAggregateInput
    certifications?: UserCertificationOrderByRelationAggregateInput
    roadmaps?: RoadmapOrderByRelationAggregateInput
    userActions?: UserActionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    position?: StringNullableFilter<"User"> | string | null
    companyName?: StringNullableFilter<"User"> | string | null
    companySize?: StringNullableFilter<"User"> | string | null
    industrySector?: StringNullableFilter<"User"> | string | null
    targetStandard?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: StringFilter<"User"> | string
    subscriptionStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    onboardingCompletedSteps?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    invitedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    invitedBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    managerNotes?: ManagerNoteListRelationFilter
    notesWritten?: ManagerNoteListRelationFilter
    managedDepartments?: DepartmentListRelationFilter
    assignmentsReceived?: ModuleAssignmentListRelationFilter
    assignmentsMade?: ModuleAssignmentListRelationFilter
    moduleProgress?: ModuleProgressListRelationFilter
    assessmentSessions?: AssessmentSessionListRelationFilter
    certifications?: UserCertificationListRelationFilter
    roadmaps?: RoadmapListRelationFilter
    userActions?: UserActionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    organizationId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    position?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    companySize?: SortOrderInput | SortOrder
    industrySector?: SortOrderInput | SortOrder
    targetStandard?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrderInput | SortOrder
    subscriptionEndDate?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    onboardingCompletedSteps?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    invitedAt?: SortOrderInput | SortOrder
    invitedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    organizationId?: StringNullableWithAggregatesFilter<"User"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    status?: StringWithAggregatesFilter<"User"> | string
    position?: StringNullableWithAggregatesFilter<"User"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"User"> | string | null
    companySize?: StringNullableWithAggregatesFilter<"User"> | string | null
    industrySector?: StringNullableWithAggregatesFilter<"User"> | string | null
    targetStandard?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionStatus?: StringWithAggregatesFilter<"User"> | string
    subscriptionStartDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    onboardingCompletedSteps?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    invitedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    invitedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ManagerNoteWhereInput = {
    AND?: ManagerNoteWhereInput | ManagerNoteWhereInput[]
    OR?: ManagerNoteWhereInput[]
    NOT?: ManagerNoteWhereInput | ManagerNoteWhereInput[]
    id?: StringFilter<"ManagerNote"> | string
    aboutUserId?: StringFilter<"ManagerNote"> | string
    byUserId?: StringFilter<"ManagerNote"> | string
    content?: StringFilter<"ManagerNote"> | string
    createdAt?: DateTimeFilter<"ManagerNote"> | Date | string
    updatedAt?: DateTimeFilter<"ManagerNote"> | Date | string
    aboutUser?: XOR<UserRelationFilter, UserWhereInput>
    byUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ManagerNoteOrderByWithRelationInput = {
    id?: SortOrder
    aboutUserId?: SortOrder
    byUserId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aboutUser?: UserOrderByWithRelationInput
    byUser?: UserOrderByWithRelationInput
  }

  export type ManagerNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    aboutUserId_byUserId?: ManagerNoteAboutUserIdByUserIdCompoundUniqueInput
    AND?: ManagerNoteWhereInput | ManagerNoteWhereInput[]
    OR?: ManagerNoteWhereInput[]
    NOT?: ManagerNoteWhereInput | ManagerNoteWhereInput[]
    aboutUserId?: StringFilter<"ManagerNote"> | string
    byUserId?: StringFilter<"ManagerNote"> | string
    content?: StringFilter<"ManagerNote"> | string
    createdAt?: DateTimeFilter<"ManagerNote"> | Date | string
    updatedAt?: DateTimeFilter<"ManagerNote"> | Date | string
    aboutUser?: XOR<UserRelationFilter, UserWhereInput>
    byUser?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "aboutUserId_byUserId">

  export type ManagerNoteOrderByWithAggregationInput = {
    id?: SortOrder
    aboutUserId?: SortOrder
    byUserId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManagerNoteCountOrderByAggregateInput
    _max?: ManagerNoteMaxOrderByAggregateInput
    _min?: ManagerNoteMinOrderByAggregateInput
  }

  export type ManagerNoteScalarWhereWithAggregatesInput = {
    AND?: ManagerNoteScalarWhereWithAggregatesInput | ManagerNoteScalarWhereWithAggregatesInput[]
    OR?: ManagerNoteScalarWhereWithAggregatesInput[]
    NOT?: ManagerNoteScalarWhereWithAggregatesInput | ManagerNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManagerNote"> | string
    aboutUserId?: StringWithAggregatesFilter<"ManagerNote"> | string
    byUserId?: StringWithAggregatesFilter<"ManagerNote"> | string
    content?: StringWithAggregatesFilter<"ManagerNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ManagerNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ManagerNote"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    organizationId?: StringNullableFilter<"Module"> | string | null
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    coverImage?: StringNullableFilter<"Module"> | string | null
    category?: StringFilter<"Module"> | string
    tags?: StringNullableListFilter<"Module">
    difficulty?: StringFilter<"Module"> | string
    estimatedDuration?: IntFilter<"Module"> | number
    sections?: JsonNullableFilter<"Module">
    xpReward?: IntFilter<"Module"> | number
    badge?: StringNullableFilter<"Module"> | string | null
    status?: StringFilter<"Module"> | string
    publishedAt?: DateTimeNullableFilter<"Module"> | Date | string | null
    completionCount?: IntFilter<"Module"> | number
    avgScore?: FloatFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    prerequisites?: ModulePrerequisiteListRelationFilter
    unlocksModules?: ModulePrerequisiteListRelationFilter
    assignments?: ModuleAssignmentListRelationFilter
    progress?: ModuleProgressListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    sections?: SortOrderInput | SortOrder
    xpReward?: SortOrder
    badge?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    prerequisites?: ModulePrerequisiteOrderByRelationAggregateInput
    unlocksModules?: ModulePrerequisiteOrderByRelationAggregateInput
    assignments?: ModuleAssignmentOrderByRelationAggregateInput
    progress?: ModuleProgressOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    organizationId?: StringNullableFilter<"Module"> | string | null
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    coverImage?: StringNullableFilter<"Module"> | string | null
    category?: StringFilter<"Module"> | string
    tags?: StringNullableListFilter<"Module">
    difficulty?: StringFilter<"Module"> | string
    estimatedDuration?: IntFilter<"Module"> | number
    sections?: JsonNullableFilter<"Module">
    xpReward?: IntFilter<"Module"> | number
    badge?: StringNullableFilter<"Module"> | string | null
    status?: StringFilter<"Module"> | string
    publishedAt?: DateTimeNullableFilter<"Module"> | Date | string | null
    completionCount?: IntFilter<"Module"> | number
    avgScore?: FloatFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    prerequisites?: ModulePrerequisiteListRelationFilter
    unlocksModules?: ModulePrerequisiteListRelationFilter
    assignments?: ModuleAssignmentListRelationFilter
    progress?: ModuleProgressListRelationFilter
  }, "id">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    sections?: SortOrderInput | SortOrder
    xpReward?: SortOrder
    badge?: SortOrderInput | SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    organizationId?: StringNullableWithAggregatesFilter<"Module"> | string | null
    title?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Module"> | string | null
    category?: StringWithAggregatesFilter<"Module"> | string
    tags?: StringNullableListFilter<"Module">
    difficulty?: StringWithAggregatesFilter<"Module"> | string
    estimatedDuration?: IntWithAggregatesFilter<"Module"> | number
    sections?: JsonNullableWithAggregatesFilter<"Module">
    xpReward?: IntWithAggregatesFilter<"Module"> | number
    badge?: StringNullableWithAggregatesFilter<"Module"> | string | null
    status?: StringWithAggregatesFilter<"Module"> | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
    completionCount?: IntWithAggregatesFilter<"Module"> | number
    avgScore?: FloatWithAggregatesFilter<"Module"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type ModulePrerequisiteWhereInput = {
    AND?: ModulePrerequisiteWhereInput | ModulePrerequisiteWhereInput[]
    OR?: ModulePrerequisiteWhereInput[]
    NOT?: ModulePrerequisiteWhereInput | ModulePrerequisiteWhereInput[]
    id?: StringFilter<"ModulePrerequisite"> | string
    moduleId?: StringFilter<"ModulePrerequisite"> | string
    prerequisiteId?: StringFilter<"ModulePrerequisite"> | string
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    prerequisite?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type ModulePrerequisiteOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    prerequisiteId?: SortOrder
    module?: ModuleOrderByWithRelationInput
    prerequisite?: ModuleOrderByWithRelationInput
  }

  export type ModulePrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    moduleId_prerequisiteId?: ModulePrerequisiteModuleIdPrerequisiteIdCompoundUniqueInput
    AND?: ModulePrerequisiteWhereInput | ModulePrerequisiteWhereInput[]
    OR?: ModulePrerequisiteWhereInput[]
    NOT?: ModulePrerequisiteWhereInput | ModulePrerequisiteWhereInput[]
    moduleId?: StringFilter<"ModulePrerequisite"> | string
    prerequisiteId?: StringFilter<"ModulePrerequisite"> | string
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    prerequisite?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id" | "moduleId_prerequisiteId">

  export type ModulePrerequisiteOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    prerequisiteId?: SortOrder
    _count?: ModulePrerequisiteCountOrderByAggregateInput
    _max?: ModulePrerequisiteMaxOrderByAggregateInput
    _min?: ModulePrerequisiteMinOrderByAggregateInput
  }

  export type ModulePrerequisiteScalarWhereWithAggregatesInput = {
    AND?: ModulePrerequisiteScalarWhereWithAggregatesInput | ModulePrerequisiteScalarWhereWithAggregatesInput[]
    OR?: ModulePrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: ModulePrerequisiteScalarWhereWithAggregatesInput | ModulePrerequisiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModulePrerequisite"> | string
    moduleId?: StringWithAggregatesFilter<"ModulePrerequisite"> | string
    prerequisiteId?: StringWithAggregatesFilter<"ModulePrerequisite"> | string
  }

  export type ModuleAssignmentWhereInput = {
    AND?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    OR?: ModuleAssignmentWhereInput[]
    NOT?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    id?: StringFilter<"ModuleAssignment"> | string
    moduleId?: StringFilter<"ModuleAssignment"> | string
    assignedToId?: StringFilter<"ModuleAssignment"> | string
    assignedById?: StringFilter<"ModuleAssignment"> | string
    priority?: StringFilter<"ModuleAssignment"> | string
    deadline?: DateTimeNullableFilter<"ModuleAssignment"> | Date | string | null
    message?: StringNullableFilter<"ModuleAssignment"> | string | null
    status?: StringFilter<"ModuleAssignment"> | string
    completedAt?: DateTimeNullableFilter<"ModuleAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"ModuleAssignment"> | Date | string
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    assignedTo?: XOR<UserRelationFilter, UserWhereInput>
    assignedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ModuleAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    priority?: SortOrder
    deadline?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    module?: ModuleOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
  }

  export type ModuleAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    OR?: ModuleAssignmentWhereInput[]
    NOT?: ModuleAssignmentWhereInput | ModuleAssignmentWhereInput[]
    moduleId?: StringFilter<"ModuleAssignment"> | string
    assignedToId?: StringFilter<"ModuleAssignment"> | string
    assignedById?: StringFilter<"ModuleAssignment"> | string
    priority?: StringFilter<"ModuleAssignment"> | string
    deadline?: DateTimeNullableFilter<"ModuleAssignment"> | Date | string | null
    message?: StringNullableFilter<"ModuleAssignment"> | string | null
    status?: StringFilter<"ModuleAssignment"> | string
    completedAt?: DateTimeNullableFilter<"ModuleAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"ModuleAssignment"> | Date | string
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    assignedTo?: XOR<UserRelationFilter, UserWhereInput>
    assignedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ModuleAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    priority?: SortOrder
    deadline?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ModuleAssignmentCountOrderByAggregateInput
    _max?: ModuleAssignmentMaxOrderByAggregateInput
    _min?: ModuleAssignmentMinOrderByAggregateInput
  }

  export type ModuleAssignmentScalarWhereWithAggregatesInput = {
    AND?: ModuleAssignmentScalarWhereWithAggregatesInput | ModuleAssignmentScalarWhereWithAggregatesInput[]
    OR?: ModuleAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ModuleAssignmentScalarWhereWithAggregatesInput | ModuleAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    moduleId?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    assignedToId?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    assignedById?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    priority?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    deadline?: DateTimeNullableWithAggregatesFilter<"ModuleAssignment"> | Date | string | null
    message?: StringNullableWithAggregatesFilter<"ModuleAssignment"> | string | null
    status?: StringWithAggregatesFilter<"ModuleAssignment"> | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ModuleAssignment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModuleAssignment"> | Date | string
  }

  export type ModuleProgressWhereInput = {
    AND?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    OR?: ModuleProgressWhereInput[]
    NOT?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    id?: StringFilter<"ModuleProgress"> | string
    userId?: StringFilter<"ModuleProgress"> | string
    moduleId?: StringFilter<"ModuleProgress"> | string
    status?: StringFilter<"ModuleProgress"> | string
    progressPercent?: IntFilter<"ModuleProgress"> | number
    completedSections?: StringNullableListFilter<"ModuleProgress">
    timeSpentSeconds?: IntFilter<"ModuleProgress"> | number
    quizScore?: FloatNullableFilter<"ModuleProgress"> | number | null
    quizAttempts?: IntFilter<"ModuleProgress"> | number
    startedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type ModuleProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    progressPercent?: SortOrder
    completedSections?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrderInput | SortOrder
    quizAttempts?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type ModuleProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_moduleId?: ModuleProgressUserIdModuleIdCompoundUniqueInput
    AND?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    OR?: ModuleProgressWhereInput[]
    NOT?: ModuleProgressWhereInput | ModuleProgressWhereInput[]
    userId?: StringFilter<"ModuleProgress"> | string
    moduleId?: StringFilter<"ModuleProgress"> | string
    status?: StringFilter<"ModuleProgress"> | string
    progressPercent?: IntFilter<"ModuleProgress"> | number
    completedSections?: StringNullableListFilter<"ModuleProgress">
    timeSpentSeconds?: IntFilter<"ModuleProgress"> | number
    quizScore?: FloatNullableFilter<"ModuleProgress"> | number | null
    quizAttempts?: IntFilter<"ModuleProgress"> | number
    startedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id" | "userId_moduleId">

  export type ModuleProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    progressPercent?: SortOrder
    completedSections?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrderInput | SortOrder
    quizAttempts?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleProgressCountOrderByAggregateInput
    _avg?: ModuleProgressAvgOrderByAggregateInput
    _max?: ModuleProgressMaxOrderByAggregateInput
    _min?: ModuleProgressMinOrderByAggregateInput
    _sum?: ModuleProgressSumOrderByAggregateInput
  }

  export type ModuleProgressScalarWhereWithAggregatesInput = {
    AND?: ModuleProgressScalarWhereWithAggregatesInput | ModuleProgressScalarWhereWithAggregatesInput[]
    OR?: ModuleProgressScalarWhereWithAggregatesInput[]
    NOT?: ModuleProgressScalarWhereWithAggregatesInput | ModuleProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuleProgress"> | string
    userId?: StringWithAggregatesFilter<"ModuleProgress"> | string
    moduleId?: StringWithAggregatesFilter<"ModuleProgress"> | string
    status?: StringWithAggregatesFilter<"ModuleProgress"> | string
    progressPercent?: IntWithAggregatesFilter<"ModuleProgress"> | number
    completedSections?: StringNullableListFilter<"ModuleProgress">
    timeSpentSeconds?: IntWithAggregatesFilter<"ModuleProgress"> | number
    quizScore?: FloatNullableWithAggregatesFilter<"ModuleProgress"> | number | null
    quizAttempts?: IntWithAggregatesFilter<"ModuleProgress"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"ModuleProgress"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ModuleProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ModuleProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModuleProgress"> | Date | string
  }

  export type AssessmentTemplateWhereInput = {
    AND?: AssessmentTemplateWhereInput | AssessmentTemplateWhereInput[]
    OR?: AssessmentTemplateWhereInput[]
    NOT?: AssessmentTemplateWhereInput | AssessmentTemplateWhereInput[]
    id?: StringFilter<"AssessmentTemplate"> | string
    organizationId?: StringNullableFilter<"AssessmentTemplate"> | string | null
    name?: StringFilter<"AssessmentTemplate"> | string
    description?: StringNullableFilter<"AssessmentTemplate"> | string | null
    certification?: StringFilter<"AssessmentTemplate"> | string
    version?: StringFilter<"AssessmentTemplate"> | string
    estimatedDuration?: IntFilter<"AssessmentTemplate"> | number
    sections?: JsonFilter<"AssessmentTemplate">
    scoringMethod?: StringFilter<"AssessmentTemplate"> | string
    maturityLevels?: JsonFilter<"AssessmentTemplate">
    status?: StringFilter<"AssessmentTemplate"> | string
    isDemo?: BoolFilter<"AssessmentTemplate"> | boolean
    createdAt?: DateTimeFilter<"AssessmentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentTemplate"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    sessions?: AssessmentSessionListRelationFilter
  }

  export type AssessmentTemplateOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    certification?: SortOrder
    version?: SortOrder
    estimatedDuration?: SortOrder
    sections?: SortOrder
    scoringMethod?: SortOrder
    maturityLevels?: SortOrder
    status?: SortOrder
    isDemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    sessions?: AssessmentSessionOrderByRelationAggregateInput
  }

  export type AssessmentTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssessmentTemplateWhereInput | AssessmentTemplateWhereInput[]
    OR?: AssessmentTemplateWhereInput[]
    NOT?: AssessmentTemplateWhereInput | AssessmentTemplateWhereInput[]
    organizationId?: StringNullableFilter<"AssessmentTemplate"> | string | null
    name?: StringFilter<"AssessmentTemplate"> | string
    description?: StringNullableFilter<"AssessmentTemplate"> | string | null
    certification?: StringFilter<"AssessmentTemplate"> | string
    version?: StringFilter<"AssessmentTemplate"> | string
    estimatedDuration?: IntFilter<"AssessmentTemplate"> | number
    sections?: JsonFilter<"AssessmentTemplate">
    scoringMethod?: StringFilter<"AssessmentTemplate"> | string
    maturityLevels?: JsonFilter<"AssessmentTemplate">
    status?: StringFilter<"AssessmentTemplate"> | string
    isDemo?: BoolFilter<"AssessmentTemplate"> | boolean
    createdAt?: DateTimeFilter<"AssessmentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentTemplate"> | Date | string
    organization?: XOR<OrganizationNullableRelationFilter, OrganizationWhereInput> | null
    sessions?: AssessmentSessionListRelationFilter
  }, "id">

  export type AssessmentTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    certification?: SortOrder
    version?: SortOrder
    estimatedDuration?: SortOrder
    sections?: SortOrder
    scoringMethod?: SortOrder
    maturityLevels?: SortOrder
    status?: SortOrder
    isDemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssessmentTemplateCountOrderByAggregateInput
    _avg?: AssessmentTemplateAvgOrderByAggregateInput
    _max?: AssessmentTemplateMaxOrderByAggregateInput
    _min?: AssessmentTemplateMinOrderByAggregateInput
    _sum?: AssessmentTemplateSumOrderByAggregateInput
  }

  export type AssessmentTemplateScalarWhereWithAggregatesInput = {
    AND?: AssessmentTemplateScalarWhereWithAggregatesInput | AssessmentTemplateScalarWhereWithAggregatesInput[]
    OR?: AssessmentTemplateScalarWhereWithAggregatesInput[]
    NOT?: AssessmentTemplateScalarWhereWithAggregatesInput | AssessmentTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssessmentTemplate"> | string
    organizationId?: StringNullableWithAggregatesFilter<"AssessmentTemplate"> | string | null
    name?: StringWithAggregatesFilter<"AssessmentTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"AssessmentTemplate"> | string | null
    certification?: StringWithAggregatesFilter<"AssessmentTemplate"> | string
    version?: StringWithAggregatesFilter<"AssessmentTemplate"> | string
    estimatedDuration?: IntWithAggregatesFilter<"AssessmentTemplate"> | number
    sections?: JsonWithAggregatesFilter<"AssessmentTemplate">
    scoringMethod?: StringWithAggregatesFilter<"AssessmentTemplate"> | string
    maturityLevels?: JsonWithAggregatesFilter<"AssessmentTemplate">
    status?: StringWithAggregatesFilter<"AssessmentTemplate"> | string
    isDemo?: BoolWithAggregatesFilter<"AssessmentTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AssessmentTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssessmentTemplate"> | Date | string
  }

  export type AssessmentSessionWhereInput = {
    AND?: AssessmentSessionWhereInput | AssessmentSessionWhereInput[]
    OR?: AssessmentSessionWhereInput[]
    NOT?: AssessmentSessionWhereInput | AssessmentSessionWhereInput[]
    id?: StringFilter<"AssessmentSession"> | string
    templateId?: StringFilter<"AssessmentSession"> | string
    userId?: StringNullableFilter<"AssessmentSession"> | string | null
    email?: StringNullableFilter<"AssessmentSession"> | string | null
    companyName?: StringNullableFilter<"AssessmentSession"> | string | null
    industry?: StringNullableFilter<"AssessmentSession"> | string | null
    employeeCount?: StringNullableFilter<"AssessmentSession"> | string | null
    answers?: JsonNullableFilter<"AssessmentSession">
    sectionScores?: JsonNullableFilter<"AssessmentSession">
    overallScore?: FloatNullableFilter<"AssessmentSession"> | number | null
    maturityLevel?: StringNullableFilter<"AssessmentSession"> | string | null
    gapAnalysis?: JsonNullableFilter<"AssessmentSession">
    recommendations?: JsonNullableFilter<"AssessmentSession">
    status?: StringFilter<"AssessmentSession"> | string
    startedAt?: DateTimeFilter<"AssessmentSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"AssessmentSession"> | Date | string | null
    convertedToSignup?: BoolFilter<"AssessmentSession"> | boolean
    pdfDownloaded?: BoolFilter<"AssessmentSession"> | boolean
    createdAt?: DateTimeFilter<"AssessmentSession"> | Date | string
    template?: XOR<AssessmentTemplateRelationFilter, AssessmentTemplateWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AssessmentSessionOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    sectionScores?: SortOrderInput | SortOrder
    overallScore?: SortOrderInput | SortOrder
    maturityLevel?: SortOrderInput | SortOrder
    gapAnalysis?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    convertedToSignup?: SortOrder
    pdfDownloaded?: SortOrder
    createdAt?: SortOrder
    template?: AssessmentTemplateOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AssessmentSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssessmentSessionWhereInput | AssessmentSessionWhereInput[]
    OR?: AssessmentSessionWhereInput[]
    NOT?: AssessmentSessionWhereInput | AssessmentSessionWhereInput[]
    templateId?: StringFilter<"AssessmentSession"> | string
    userId?: StringNullableFilter<"AssessmentSession"> | string | null
    email?: StringNullableFilter<"AssessmentSession"> | string | null
    companyName?: StringNullableFilter<"AssessmentSession"> | string | null
    industry?: StringNullableFilter<"AssessmentSession"> | string | null
    employeeCount?: StringNullableFilter<"AssessmentSession"> | string | null
    answers?: JsonNullableFilter<"AssessmentSession">
    sectionScores?: JsonNullableFilter<"AssessmentSession">
    overallScore?: FloatNullableFilter<"AssessmentSession"> | number | null
    maturityLevel?: StringNullableFilter<"AssessmentSession"> | string | null
    gapAnalysis?: JsonNullableFilter<"AssessmentSession">
    recommendations?: JsonNullableFilter<"AssessmentSession">
    status?: StringFilter<"AssessmentSession"> | string
    startedAt?: DateTimeFilter<"AssessmentSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"AssessmentSession"> | Date | string | null
    convertedToSignup?: BoolFilter<"AssessmentSession"> | boolean
    pdfDownloaded?: BoolFilter<"AssessmentSession"> | boolean
    createdAt?: DateTimeFilter<"AssessmentSession"> | Date | string
    template?: XOR<AssessmentTemplateRelationFilter, AssessmentTemplateWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AssessmentSessionOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    industry?: SortOrderInput | SortOrder
    employeeCount?: SortOrderInput | SortOrder
    answers?: SortOrderInput | SortOrder
    sectionScores?: SortOrderInput | SortOrder
    overallScore?: SortOrderInput | SortOrder
    maturityLevel?: SortOrderInput | SortOrder
    gapAnalysis?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    convertedToSignup?: SortOrder
    pdfDownloaded?: SortOrder
    createdAt?: SortOrder
    _count?: AssessmentSessionCountOrderByAggregateInput
    _avg?: AssessmentSessionAvgOrderByAggregateInput
    _max?: AssessmentSessionMaxOrderByAggregateInput
    _min?: AssessmentSessionMinOrderByAggregateInput
    _sum?: AssessmentSessionSumOrderByAggregateInput
  }

  export type AssessmentSessionScalarWhereWithAggregatesInput = {
    AND?: AssessmentSessionScalarWhereWithAggregatesInput | AssessmentSessionScalarWhereWithAggregatesInput[]
    OR?: AssessmentSessionScalarWhereWithAggregatesInput[]
    NOT?: AssessmentSessionScalarWhereWithAggregatesInput | AssessmentSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssessmentSession"> | string
    templateId?: StringWithAggregatesFilter<"AssessmentSession"> | string
    userId?: StringNullableWithAggregatesFilter<"AssessmentSession"> | string | null
    email?: StringNullableWithAggregatesFilter<"AssessmentSession"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"AssessmentSession"> | string | null
    industry?: StringNullableWithAggregatesFilter<"AssessmentSession"> | string | null
    employeeCount?: StringNullableWithAggregatesFilter<"AssessmentSession"> | string | null
    answers?: JsonNullableWithAggregatesFilter<"AssessmentSession">
    sectionScores?: JsonNullableWithAggregatesFilter<"AssessmentSession">
    overallScore?: FloatNullableWithAggregatesFilter<"AssessmentSession"> | number | null
    maturityLevel?: StringNullableWithAggregatesFilter<"AssessmentSession"> | string | null
    gapAnalysis?: JsonNullableWithAggregatesFilter<"AssessmentSession">
    recommendations?: JsonNullableWithAggregatesFilter<"AssessmentSession">
    status?: StringWithAggregatesFilter<"AssessmentSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"AssessmentSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"AssessmentSession"> | Date | string | null
    convertedToSignup?: BoolWithAggregatesFilter<"AssessmentSession"> | boolean
    pdfDownloaded?: BoolWithAggregatesFilter<"AssessmentSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AssessmentSession"> | Date | string
  }

  export type UserCertificationWhereInput = {
    AND?: UserCertificationWhereInput | UserCertificationWhereInput[]
    OR?: UserCertificationWhereInput[]
    NOT?: UserCertificationWhereInput | UserCertificationWhereInput[]
    id?: StringFilter<"UserCertification"> | string
    userId?: StringFilter<"UserCertification"> | string
    name?: StringFilter<"UserCertification"> | string
    certification?: StringFilter<"UserCertification"> | string
    level?: StringNullableFilter<"UserCertification"> | string | null
    issuedAt?: DateTimeFilter<"UserCertification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserCertification"> | Date | string | null
    status?: StringFilter<"UserCertification"> | string
    certificateUrl?: StringNullableFilter<"UserCertification"> | string | null
    verificationCode?: StringNullableFilter<"UserCertification"> | string | null
    createdAt?: DateTimeFilter<"UserCertification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserCertificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    certification?: SortOrder
    level?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    verificationCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserCertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    verificationCode?: string
    AND?: UserCertificationWhereInput | UserCertificationWhereInput[]
    OR?: UserCertificationWhereInput[]
    NOT?: UserCertificationWhereInput | UserCertificationWhereInput[]
    userId?: StringFilter<"UserCertification"> | string
    name?: StringFilter<"UserCertification"> | string
    certification?: StringFilter<"UserCertification"> | string
    level?: StringNullableFilter<"UserCertification"> | string | null
    issuedAt?: DateTimeFilter<"UserCertification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserCertification"> | Date | string | null
    status?: StringFilter<"UserCertification"> | string
    certificateUrl?: StringNullableFilter<"UserCertification"> | string | null
    createdAt?: DateTimeFilter<"UserCertification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "verificationCode">

  export type UserCertificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    certification?: SortOrder
    level?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    verificationCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCertificationCountOrderByAggregateInput
    _max?: UserCertificationMaxOrderByAggregateInput
    _min?: UserCertificationMinOrderByAggregateInput
  }

  export type UserCertificationScalarWhereWithAggregatesInput = {
    AND?: UserCertificationScalarWhereWithAggregatesInput | UserCertificationScalarWhereWithAggregatesInput[]
    OR?: UserCertificationScalarWhereWithAggregatesInput[]
    NOT?: UserCertificationScalarWhereWithAggregatesInput | UserCertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserCertification"> | string
    userId?: StringWithAggregatesFilter<"UserCertification"> | string
    name?: StringWithAggregatesFilter<"UserCertification"> | string
    certification?: StringWithAggregatesFilter<"UserCertification"> | string
    level?: StringNullableWithAggregatesFilter<"UserCertification"> | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"UserCertification"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"UserCertification"> | Date | string | null
    status?: StringWithAggregatesFilter<"UserCertification"> | string
    certificateUrl?: StringNullableWithAggregatesFilter<"UserCertification"> | string | null
    verificationCode?: StringNullableWithAggregatesFilter<"UserCertification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserCertification"> | Date | string
  }

  export type RoadmapWhereInput = {
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    userId?: StringFilter<"Roadmap"> | string
    assessmentSessionId?: StringNullableFilter<"Roadmap"> | string | null
    standardType?: StringFilter<"Roadmap"> | string
    totalSprints?: IntFilter<"Roadmap"> | number
    currentSprint?: IntFilter<"Roadmap"> | number
    sprintDurationWeeks?: IntFilter<"Roadmap"> | number
    completionPercentage?: FloatFilter<"Roadmap"> | number
    estimatedCompletionDate?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    status?: StringFilter<"Roadmap"> | string
    sprintDetails?: JsonNullableFilter<"Roadmap">
    startedAt?: DateTimeFilter<"Roadmap"> | Date | string
    completedAt?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userActions?: UserActionListRelationFilter
  }

  export type RoadmapOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentSessionId?: SortOrderInput | SortOrder
    standardType?: SortOrder
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
    estimatedCompletionDate?: SortOrderInput | SortOrder
    status?: SortOrder
    sprintDetails?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    userActions?: UserActionOrderByRelationAggregateInput
  }

  export type RoadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    userId?: StringFilter<"Roadmap"> | string
    assessmentSessionId?: StringNullableFilter<"Roadmap"> | string | null
    standardType?: StringFilter<"Roadmap"> | string
    totalSprints?: IntFilter<"Roadmap"> | number
    currentSprint?: IntFilter<"Roadmap"> | number
    sprintDurationWeeks?: IntFilter<"Roadmap"> | number
    completionPercentage?: FloatFilter<"Roadmap"> | number
    estimatedCompletionDate?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    status?: StringFilter<"Roadmap"> | string
    sprintDetails?: JsonNullableFilter<"Roadmap">
    startedAt?: DateTimeFilter<"Roadmap"> | Date | string
    completedAt?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userActions?: UserActionListRelationFilter
  }, "id">

  export type RoadmapOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentSessionId?: SortOrderInput | SortOrder
    standardType?: SortOrder
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
    estimatedCompletionDate?: SortOrderInput | SortOrder
    status?: SortOrder
    sprintDetails?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapCountOrderByAggregateInput
    _avg?: RoadmapAvgOrderByAggregateInput
    _max?: RoadmapMaxOrderByAggregateInput
    _min?: RoadmapMinOrderByAggregateInput
    _sum?: RoadmapSumOrderByAggregateInput
  }

  export type RoadmapScalarWhereWithAggregatesInput = {
    AND?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    OR?: RoadmapScalarWhereWithAggregatesInput[]
    NOT?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roadmap"> | string
    userId?: StringWithAggregatesFilter<"Roadmap"> | string
    assessmentSessionId?: StringNullableWithAggregatesFilter<"Roadmap"> | string | null
    standardType?: StringWithAggregatesFilter<"Roadmap"> | string
    totalSprints?: IntWithAggregatesFilter<"Roadmap"> | number
    currentSprint?: IntWithAggregatesFilter<"Roadmap"> | number
    sprintDurationWeeks?: IntWithAggregatesFilter<"Roadmap"> | number
    completionPercentage?: FloatWithAggregatesFilter<"Roadmap"> | number
    estimatedCompletionDate?: DateTimeNullableWithAggregatesFilter<"Roadmap"> | Date | string | null
    status?: StringWithAggregatesFilter<"Roadmap"> | string
    sprintDetails?: JsonNullableWithAggregatesFilter<"Roadmap">
    startedAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Roadmap"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: StringFilter<"Action"> | string
    standardType?: StringFilter<"Action"> | string
    actionCode?: StringFilter<"Action"> | string
    title?: StringFilter<"Action"> | string
    description?: StringFilter<"Action"> | string
    requirementRef?: StringFilter<"Action"> | string
    chapterNumber?: StringNullableFilter<"Action"> | string | null
    estimatedHours?: IntFilter<"Action"> | number
    priorityWeight?: IntFilter<"Action"> | number
    category?: StringNullableFilter<"Action"> | string | null
    sectorVariations?: JsonNullableFilter<"Action">
    templateIds?: StringNullableListFilter<"Action">
    videoUrl?: StringNullableFilter<"Action"> | string | null
    dependsOnActions?: StringNullableListFilter<"Action">
    displayOrder?: IntFilter<"Action"> | number
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    userActions?: UserActionListRelationFilter
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    standardType?: SortOrder
    actionCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirementRef?: SortOrder
    chapterNumber?: SortOrderInput | SortOrder
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    category?: SortOrderInput | SortOrder
    sectorVariations?: SortOrderInput | SortOrder
    templateIds?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    dependsOnActions?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userActions?: UserActionOrderByRelationAggregateInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    actionCode?: string
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    standardType?: StringFilter<"Action"> | string
    title?: StringFilter<"Action"> | string
    description?: StringFilter<"Action"> | string
    requirementRef?: StringFilter<"Action"> | string
    chapterNumber?: StringNullableFilter<"Action"> | string | null
    estimatedHours?: IntFilter<"Action"> | number
    priorityWeight?: IntFilter<"Action"> | number
    category?: StringNullableFilter<"Action"> | string | null
    sectorVariations?: JsonNullableFilter<"Action">
    templateIds?: StringNullableListFilter<"Action">
    videoUrl?: StringNullableFilter<"Action"> | string | null
    dependsOnActions?: StringNullableListFilter<"Action">
    displayOrder?: IntFilter<"Action"> | number
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    userActions?: UserActionListRelationFilter
  }, "id" | "actionCode">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    standardType?: SortOrder
    actionCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirementRef?: SortOrder
    chapterNumber?: SortOrderInput | SortOrder
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    category?: SortOrderInput | SortOrder
    sectorVariations?: SortOrderInput | SortOrder
    templateIds?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    dependsOnActions?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Action"> | string
    standardType?: StringWithAggregatesFilter<"Action"> | string
    actionCode?: StringWithAggregatesFilter<"Action"> | string
    title?: StringWithAggregatesFilter<"Action"> | string
    description?: StringWithAggregatesFilter<"Action"> | string
    requirementRef?: StringWithAggregatesFilter<"Action"> | string
    chapterNumber?: StringNullableWithAggregatesFilter<"Action"> | string | null
    estimatedHours?: IntWithAggregatesFilter<"Action"> | number
    priorityWeight?: IntWithAggregatesFilter<"Action"> | number
    category?: StringNullableWithAggregatesFilter<"Action"> | string | null
    sectorVariations?: JsonNullableWithAggregatesFilter<"Action">
    templateIds?: StringNullableListFilter<"Action">
    videoUrl?: StringNullableWithAggregatesFilter<"Action"> | string | null
    dependsOnActions?: StringNullableListFilter<"Action">
    displayOrder?: IntWithAggregatesFilter<"Action"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
  }

  export type UserActionWhereInput = {
    AND?: UserActionWhereInput | UserActionWhereInput[]
    OR?: UserActionWhereInput[]
    NOT?: UserActionWhereInput | UserActionWhereInput[]
    id?: StringFilter<"UserAction"> | string
    userId?: StringFilter<"UserAction"> | string
    roadmapId?: StringFilter<"UserAction"> | string
    actionId?: StringFilter<"UserAction"> | string
    sprintNumber?: IntFilter<"UserAction"> | number
    status?: StringFilter<"UserAction"> | string
    startedAt?: DateTimeNullableFilter<"UserAction"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserAction"> | Date | string | null
    notes?: StringNullableFilter<"UserAction"> | string | null
    blockedReason?: StringNullableFilter<"UserAction"> | string | null
    uploadedFiles?: JsonNullableFilter<"UserAction">
    createdAt?: DateTimeFilter<"UserAction"> | Date | string
    updatedAt?: DateTimeFilter<"UserAction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    action?: XOR<ActionRelationFilter, ActionWhereInput>
  }

  export type UserActionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    actionId?: SortOrder
    sprintNumber?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    blockedReason?: SortOrderInput | SortOrder
    uploadedFiles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    roadmap?: RoadmapOrderByWithRelationInput
    action?: ActionOrderByWithRelationInput
  }

  export type UserActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roadmapId_actionId?: UserActionRoadmapIdActionIdCompoundUniqueInput
    AND?: UserActionWhereInput | UserActionWhereInput[]
    OR?: UserActionWhereInput[]
    NOT?: UserActionWhereInput | UserActionWhereInput[]
    userId?: StringFilter<"UserAction"> | string
    roadmapId?: StringFilter<"UserAction"> | string
    actionId?: StringFilter<"UserAction"> | string
    sprintNumber?: IntFilter<"UserAction"> | number
    status?: StringFilter<"UserAction"> | string
    startedAt?: DateTimeNullableFilter<"UserAction"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserAction"> | Date | string | null
    notes?: StringNullableFilter<"UserAction"> | string | null
    blockedReason?: StringNullableFilter<"UserAction"> | string | null
    uploadedFiles?: JsonNullableFilter<"UserAction">
    createdAt?: DateTimeFilter<"UserAction"> | Date | string
    updatedAt?: DateTimeFilter<"UserAction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    action?: XOR<ActionRelationFilter, ActionWhereInput>
  }, "id" | "roadmapId_actionId">

  export type UserActionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    actionId?: SortOrder
    sprintNumber?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    blockedReason?: SortOrderInput | SortOrder
    uploadedFiles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserActionCountOrderByAggregateInput
    _avg?: UserActionAvgOrderByAggregateInput
    _max?: UserActionMaxOrderByAggregateInput
    _min?: UserActionMinOrderByAggregateInput
    _sum?: UserActionSumOrderByAggregateInput
  }

  export type UserActionScalarWhereWithAggregatesInput = {
    AND?: UserActionScalarWhereWithAggregatesInput | UserActionScalarWhereWithAggregatesInput[]
    OR?: UserActionScalarWhereWithAggregatesInput[]
    NOT?: UserActionScalarWhereWithAggregatesInput | UserActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAction"> | string
    userId?: StringWithAggregatesFilter<"UserAction"> | string
    roadmapId?: StringWithAggregatesFilter<"UserAction"> | string
    actionId?: StringWithAggregatesFilter<"UserAction"> | string
    sprintNumber?: IntWithAggregatesFilter<"UserAction"> | number
    status?: StringWithAggregatesFilter<"UserAction"> | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"UserAction"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserAction"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"UserAction"> | string | null
    blockedReason?: StringNullableWithAggregatesFilter<"UserAction"> | string | null
    uploadedFiles?: JsonNullableWithAggregatesFilter<"UserAction">
    createdAt?: DateTimeWithAggregatesFilter<"UserAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAction"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    standardType?: StringFilter<"Template"> | string
    templateCode?: StringFilter<"Template"> | string
    title?: StringFilter<"Template"> | string
    description?: StringNullableFilter<"Template"> | string | null
    category?: StringFilter<"Template"> | string
    fileUrl?: StringFilter<"Template"> | string
    fileFormat?: StringFilter<"Template"> | string
    fileSize?: IntNullableFilter<"Template"> | number | null
    requirementRef?: StringNullableFilter<"Template"> | string | null
    sectorAdaptations?: JsonNullableFilter<"Template">
    relatedActionCodes?: StringNullableListFilter<"Template">
    downloadCount?: IntFilter<"Template"> | number
    displayOrder?: IntFilter<"Template"> | number
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    standardType?: SortOrder
    templateCode?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileFormat?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    requirementRef?: SortOrderInput | SortOrder
    sectorAdaptations?: SortOrderInput | SortOrder
    relatedActionCodes?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    templateCode?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    standardType?: StringFilter<"Template"> | string
    title?: StringFilter<"Template"> | string
    description?: StringNullableFilter<"Template"> | string | null
    category?: StringFilter<"Template"> | string
    fileUrl?: StringFilter<"Template"> | string
    fileFormat?: StringFilter<"Template"> | string
    fileSize?: IntNullableFilter<"Template"> | number | null
    requirementRef?: StringNullableFilter<"Template"> | string | null
    sectorAdaptations?: JsonNullableFilter<"Template">
    relatedActionCodes?: StringNullableListFilter<"Template">
    downloadCount?: IntFilter<"Template"> | number
    displayOrder?: IntFilter<"Template"> | number
    isActive?: BoolFilter<"Template"> | boolean
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
  }, "id" | "templateCode">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    standardType?: SortOrder
    templateCode?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileFormat?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    requirementRef?: SortOrderInput | SortOrder
    sectorAdaptations?: SortOrderInput | SortOrder
    relatedActionCodes?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _avg?: TemplateAvgOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
    _sum?: TemplateSumOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    standardType?: StringWithAggregatesFilter<"Template"> | string
    templateCode?: StringWithAggregatesFilter<"Template"> | string
    title?: StringWithAggregatesFilter<"Template"> | string
    description?: StringNullableWithAggregatesFilter<"Template"> | string | null
    category?: StringWithAggregatesFilter<"Template"> | string
    fileUrl?: StringWithAggregatesFilter<"Template"> | string
    fileFormat?: StringWithAggregatesFilter<"Template"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Template"> | number | null
    requirementRef?: StringNullableWithAggregatesFilter<"Template"> | string | null
    sectorAdaptations?: JsonNullableWithAggregatesFilter<"Template">
    relatedActionCodes?: StringNullableListFilter<"Template">
    downloadCount?: IntWithAggregatesFilter<"Template"> | number
    displayOrder?: IntWithAggregatesFilter<"Template"> | number
    isActive?: BoolWithAggregatesFilter<"Template"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type StandardConfigWhereInput = {
    AND?: StandardConfigWhereInput | StandardConfigWhereInput[]
    OR?: StandardConfigWhereInput[]
    NOT?: StandardConfigWhereInput | StandardConfigWhereInput[]
    id?: StringFilter<"StandardConfig"> | string
    standardType?: StringFilter<"StandardConfig"> | string
    name?: StringFilter<"StandardConfig"> | string
    shortName?: StringFilter<"StandardConfig"> | string
    description?: StringNullableFilter<"StandardConfig"> | string | null
    icon?: StringNullableFilter<"StandardConfig"> | string | null
    questions?: JsonFilter<"StandardConfig">
    chapters?: JsonFilter<"StandardConfig">
    maturityLevels?: JsonFilter<"StandardConfig">
    estimatedMonths?: IntFilter<"StandardConfig"> | number
    typicalPrice?: IntNullableFilter<"StandardConfig"> | number | null
    sectorRelevance?: JsonNullableFilter<"StandardConfig">
    isActive?: BoolFilter<"StandardConfig"> | boolean
    createdAt?: DateTimeFilter<"StandardConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StandardConfig"> | Date | string
  }

  export type StandardConfigOrderByWithRelationInput = {
    id?: SortOrder
    standardType?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    questions?: SortOrder
    chapters?: SortOrder
    maturityLevels?: SortOrder
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrderInput | SortOrder
    sectorRelevance?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    standardType?: string
    AND?: StandardConfigWhereInput | StandardConfigWhereInput[]
    OR?: StandardConfigWhereInput[]
    NOT?: StandardConfigWhereInput | StandardConfigWhereInput[]
    name?: StringFilter<"StandardConfig"> | string
    shortName?: StringFilter<"StandardConfig"> | string
    description?: StringNullableFilter<"StandardConfig"> | string | null
    icon?: StringNullableFilter<"StandardConfig"> | string | null
    questions?: JsonFilter<"StandardConfig">
    chapters?: JsonFilter<"StandardConfig">
    maturityLevels?: JsonFilter<"StandardConfig">
    estimatedMonths?: IntFilter<"StandardConfig"> | number
    typicalPrice?: IntNullableFilter<"StandardConfig"> | number | null
    sectorRelevance?: JsonNullableFilter<"StandardConfig">
    isActive?: BoolFilter<"StandardConfig"> | boolean
    createdAt?: DateTimeFilter<"StandardConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StandardConfig"> | Date | string
  }, "id" | "standardType">

  export type StandardConfigOrderByWithAggregationInput = {
    id?: SortOrder
    standardType?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    questions?: SortOrder
    chapters?: SortOrder
    maturityLevels?: SortOrder
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrderInput | SortOrder
    sectorRelevance?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StandardConfigCountOrderByAggregateInput
    _avg?: StandardConfigAvgOrderByAggregateInput
    _max?: StandardConfigMaxOrderByAggregateInput
    _min?: StandardConfigMinOrderByAggregateInput
    _sum?: StandardConfigSumOrderByAggregateInput
  }

  export type StandardConfigScalarWhereWithAggregatesInput = {
    AND?: StandardConfigScalarWhereWithAggregatesInput | StandardConfigScalarWhereWithAggregatesInput[]
    OR?: StandardConfigScalarWhereWithAggregatesInput[]
    NOT?: StandardConfigScalarWhereWithAggregatesInput | StandardConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StandardConfig"> | string
    standardType?: StringWithAggregatesFilter<"StandardConfig"> | string
    name?: StringWithAggregatesFilter<"StandardConfig"> | string
    shortName?: StringWithAggregatesFilter<"StandardConfig"> | string
    description?: StringNullableWithAggregatesFilter<"StandardConfig"> | string | null
    icon?: StringNullableWithAggregatesFilter<"StandardConfig"> | string | null
    questions?: JsonWithAggregatesFilter<"StandardConfig">
    chapters?: JsonWithAggregatesFilter<"StandardConfig">
    maturityLevels?: JsonWithAggregatesFilter<"StandardConfig">
    estimatedMonths?: IntWithAggregatesFilter<"StandardConfig"> | number
    typicalPrice?: IntNullableWithAggregatesFilter<"StandardConfig"> | number | null
    sectorRelevance?: JsonNullableWithAggregatesFilter<"StandardConfig">
    isActive?: BoolWithAggregatesFilter<"StandardConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StandardConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StandardConfig"> | Date | string
  }

  export type EventCreateInput = {
    id?: string
    userId?: string | null
    sessionId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: string | null
    referrer?: string | null
    userAgent?: string | null
    ip?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type EventUncheckedCreateInput = {
    id?: string
    userId?: string | null
    sessionId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: string | null
    referrer?: string | null
    userAgent?: string | null
    ip?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    userId?: string | null
    sessionId: string
    eventType: string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: string | null
    referrer?: string | null
    userAgent?: string | null
    ip?: string | null
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventData?: NullableJsonNullValueInput | InputJsonValue
    page?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatCreateInput = {
    id?: string
    date: Date | string
    totalEvents?: number
    uniqueUsers?: number
    uniqueSessions?: number
    pageViews?: number
    quizStarted?: number
    quizCompleted?: number
    modulesViewed?: number
    lessonsCompleted?: number
    avgSessionDuration?: number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatUncheckedCreateInput = {
    id?: string
    date: Date | string
    totalEvents?: number
    uniqueUsers?: number
    uniqueSessions?: number
    pageViews?: number
    quizStarted?: number
    quizCompleted?: number
    modulesViewed?: number
    lessonsCompleted?: number
    avgSessionDuration?: number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    uniqueSessions?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    modulesViewed?: IntFieldUpdateOperationsInput | number
    lessonsCompleted?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: FloatFieldUpdateOperationsInput | number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    uniqueSessions?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    modulesViewed?: IntFieldUpdateOperationsInput | number
    lessonsCompleted?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: FloatFieldUpdateOperationsInput | number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatCreateManyInput = {
    id?: string
    date: Date | string
    totalEvents?: number
    uniqueUsers?: number
    uniqueSessions?: number
    pageViews?: number
    quizStarted?: number
    quizCompleted?: number
    modulesViewed?: number
    lessonsCompleted?: number
    avgSessionDuration?: number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    uniqueSessions?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    modulesViewed?: IntFieldUpdateOperationsInput | number
    lessonsCompleted?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: FloatFieldUpdateOperationsInput | number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalEvents?: IntFieldUpdateOperationsInput | number
    uniqueUsers?: IntFieldUpdateOperationsInput | number
    uniqueSessions?: IntFieldUpdateOperationsInput | number
    pageViews?: IntFieldUpdateOperationsInput | number
    quizStarted?: IntFieldUpdateOperationsInput | number
    quizCompleted?: IntFieldUpdateOperationsInput | number
    modulesViewed?: IntFieldUpdateOperationsInput | number
    lessonsCompleted?: IntFieldUpdateOperationsInput | number
    avgSessionDuration?: FloatFieldUpdateOperationsInput | number
    eventsByType?: NullableJsonNullValueInput | InputJsonValue
    topPages?: NullableJsonNullValueInput | InputJsonValue
    topModules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateInput = {
    id?: string
    userId: string
    totalXp?: number
    currentLevel?: number
    modulesStarted?: UserProgressCreatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressCreatemodulesCompletedInput | string[]
    quizzesCompleted?: number
    totalCorrect?: number
    totalQuestions?: number
    avgScore?: number
    currentStreak?: number
    longestStreak?: number
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    totalXp?: number
    currentLevel?: number
    modulesStarted?: UserProgressCreatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressCreatemodulesCompletedInput | string[]
    quizzesCompleted?: number
    totalCorrect?: number
    totalQuestions?: number
    avgScore?: number
    currentStreak?: number
    longestStreak?: number
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    modulesStarted?: UserProgressUpdatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressUpdatemodulesCompletedInput | string[]
    quizzesCompleted?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    modulesStarted?: UserProgressUpdatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressUpdatemodulesCompletedInput | string[]
    quizzesCompleted?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    totalXp?: number
    currentLevel?: number
    modulesStarted?: UserProgressCreatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressCreatemodulesCompletedInput | string[]
    quizzesCompleted?: number
    totalCorrect?: number
    totalQuestions?: number
    avgScore?: number
    currentStreak?: number
    longestStreak?: number
    lastActiveAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    modulesStarted?: UserProgressUpdatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressUpdatemodulesCompletedInput | string[]
    quizzesCompleted?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalXp?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    modulesStarted?: UserProgressUpdatemodulesStartedInput | string[]
    modulesCompleted?: UserProgressUpdatemodulesCompletedInput | string[]
    quizzesCompleted?: IntFieldUpdateOperationsInput | number
    totalCorrect?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    metric: string
    operator: string
    threshold: number
    duration?: number | null
    targetType?: string
    targetId?: string | null
    severity?: string
    notifyChannels?: AlertRuleCreatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleCreatenotifyRolesInput | string[]
    cooldownMinutes?: number
    lastTriggeredAt?: Date | string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutRuleInput
  }

  export type AlertRuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    metric: string
    operator: string
    threshold: number
    duration?: number | null
    targetType?: string
    targetId?: string | null
    severity?: string
    notifyChannels?: AlertRuleCreatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleCreatenotifyRolesInput | string[]
    cooldownMinutes?: number
    lastTriggeredAt?: Date | string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutRuleInput
  }

  export type AlertRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metric?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    notifyChannels?: AlertRuleUpdatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleUpdatenotifyRolesInput | string[]
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutRuleNestedInput
  }

  export type AlertRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metric?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    notifyChannels?: AlertRuleUpdatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleUpdatenotifyRolesInput | string[]
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type AlertRuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    metric: string
    operator: string
    threshold: number
    duration?: number | null
    targetType?: string
    targetId?: string | null
    severity?: string
    notifyChannels?: AlertRuleCreatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleCreatenotifyRolesInput | string[]
    cooldownMinutes?: number
    lastTriggeredAt?: Date | string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metric?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    notifyChannels?: AlertRuleUpdatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleUpdatenotifyRolesInput | string[]
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metric?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    notifyChannels?: AlertRuleUpdatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleUpdatenotifyRolesInput | string[]
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rule: AlertRuleCreateNestedOneWithoutAlertsInput
    notifications?: NotificationCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    ruleId: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: AlertRuleUpdateOneRequiredWithoutAlertsNestedInput
    notifications?: NotificationUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertCreateManyInput = {
    id?: string
    ruleId: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    readAt?: Date | string | null
    emailSent?: boolean
    emailSentAt?: Date | string | null
    createdAt?: Date | string
    alert?: AlertCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    alertId?: string | null
    read?: boolean
    readAt?: Date | string | null
    emailSent?: boolean
    emailSentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alert?: AlertUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    alertId?: string | null
    read?: boolean
    readAt?: Date | string | null
    emailSent?: boolean
    emailSentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    alertId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    format?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: boolean
    scheduleCron?: string | null
    recipients?: ReportTemplateCreaterecipientsInput | string[]
    isSystem?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: GeneratedReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    format?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: boolean
    scheduleCron?: string | null
    recipients?: ReportTemplateCreaterecipientsInput | string[]
    isSystem?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: GeneratedReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    scheduleCron?: NullableStringFieldUpdateOperationsInput | string | null
    recipients?: ReportTemplateUpdaterecipientsInput | string[]
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: GeneratedReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    scheduleCron?: NullableStringFieldUpdateOperationsInput | string | null
    recipients?: ReportTemplateUpdaterecipientsInput | string[]
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: GeneratedReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    format?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: boolean
    scheduleCron?: string | null
    recipients?: ReportTemplateCreaterecipientsInput | string[]
    isSystem?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    scheduleCron?: NullableStringFieldUpdateOperationsInput | string | null
    recipients?: ReportTemplateUpdaterecipientsInput | string[]
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    scheduleCron?: NullableStringFieldUpdateOperationsInput | string | null
    recipients?: ReportTemplateUpdaterecipientsInput | string[]
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportCreateInput = {
    id?: string
    name: string
    type: string
    format: string
    periodStart: Date | string
    periodEnd: Date | string
    requestedBy?: string | null
    generatedAt?: Date | string
    filePath?: string | null
    fileSize?: number | null
    mimeType?: string | null
    status?: string
    errorMessage?: string | null
    emailed?: boolean
    emailedAt?: Date | string | null
    downloadCount?: number
    createdAt?: Date | string
    template?: ReportTemplateCreateNestedOneWithoutReportsInput
  }

  export type GeneratedReportUncheckedCreateInput = {
    id?: string
    templateId?: string | null
    name: string
    type: string
    format: string
    periodStart: Date | string
    periodEnd: Date | string
    requestedBy?: string | null
    generatedAt?: Date | string
    filePath?: string | null
    fileSize?: number | null
    mimeType?: string | null
    status?: string
    errorMessage?: string | null
    emailed?: boolean
    emailedAt?: Date | string | null
    downloadCount?: number
    createdAt?: Date | string
  }

  export type GeneratedReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ReportTemplateUpdateOneWithoutReportsNestedInput
  }

  export type GeneratedReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportCreateManyInput = {
    id?: string
    templateId?: string | null
    name: string
    type: string
    format: string
    periodStart: Date | string
    periodEnd: Date | string
    requestedBy?: string | null
    generatedAt?: Date | string
    filePath?: string | null
    fileSize?: number | null
    mimeType?: string | null
    status?: string
    errorMessage?: string | null
    emailed?: boolean
    emailedAt?: Date | string | null
    downloadCount?: number
    createdAt?: Date | string
  }

  export type GeneratedReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    modules?: ModuleCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    modules?: ModuleUncheckedCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
    members?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
    members?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aboutUser: UserCreateNestedOneWithoutManagerNotesInput
    byUser: UserCreateNestedOneWithoutNotesWrittenInput
  }

  export type ManagerNoteUncheckedCreateInput = {
    id?: string
    aboutUserId: string
    byUserId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutUser?: UserUpdateOneRequiredWithoutManagerNotesNestedInput
    byUser?: UserUpdateOneRequiredWithoutNotesWrittenNestedInput
  }

  export type ManagerNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    aboutUserId?: StringFieldUpdateOperationsInput | string
    byUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteCreateManyInput = {
    id?: string
    aboutUserId: string
    byUserId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    aboutUserId?: StringFieldUpdateOperationsInput | string
    byUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutModulesInput
    prerequisites?: ModulePrerequisiteCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    organizationId?: string | null
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisites?: ModulePrerequisiteUncheckedCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutModulesNestedInput
    prerequisites?: ModulePrerequisiteUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisites?: ModulePrerequisiteUncheckedUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    organizationId?: string | null
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePrerequisiteCreateInput = {
    id?: string
    module: ModuleCreateNestedOneWithoutPrerequisitesInput
    prerequisite: ModuleCreateNestedOneWithoutUnlocksModulesInput
  }

  export type ModulePrerequisiteUncheckedCreateInput = {
    id?: string
    moduleId: string
    prerequisiteId: string
  }

  export type ModulePrerequisiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: ModuleUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisite?: ModuleUpdateOneRequiredWithoutUnlocksModulesNestedInput
  }

  export type ModulePrerequisiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePrerequisiteCreateManyInput = {
    id?: string
    moduleId: string
    prerequisiteId: string
  }

  export type ModulePrerequisiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePrerequisiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleAssignmentCreateInput = {
    id?: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    module: ModuleCreateNestedOneWithoutAssignmentsInput
    assignedTo: UserCreateNestedOneWithoutAssignmentsReceivedInput
    assignedBy: UserCreateNestedOneWithoutAssignmentsMadeInput
  }

  export type ModuleAssignmentUncheckedCreateInput = {
    id?: string
    moduleId: string
    assignedToId: string
    assignedById: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutAssignmentsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignmentsReceivedNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignmentsMadeNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentCreateManyInput = {
    id?: string
    moduleId: string
    assignedToId: string
    assignedById: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressCreateInput = {
    id?: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutModuleProgressInput
    module: ModuleCreateNestedOneWithoutProgressInput
  }

  export type ModuleProgressUncheckedCreateInput = {
    id?: string
    userId: string
    moduleId: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutModuleProgressNestedInput
    module?: ModuleUpdateOneRequiredWithoutProgressNestedInput
  }

  export type ModuleProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressCreateManyInput = {
    id?: string
    userId: string
    moduleId: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutAssessmentTemplatesInput
    sessions?: AssessmentSessionCreateNestedManyWithoutTemplateInput
  }

  export type AssessmentTemplateUncheckedCreateInput = {
    id?: string
    organizationId?: string | null
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AssessmentSessionUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type AssessmentTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutAssessmentTemplatesNestedInput
    sessions?: AssessmentSessionUpdateManyWithoutTemplateNestedInput
  }

  export type AssessmentTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AssessmentSessionUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type AssessmentTemplateCreateManyInput = {
    id?: string
    organizationId?: string | null
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionCreateInput = {
    id?: string
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
    template: AssessmentTemplateCreateNestedOneWithoutSessionsInput
    user?: UserCreateNestedOneWithoutAssessmentSessionsInput
  }

  export type AssessmentSessionUncheckedCreateInput = {
    id?: string
    templateId: string
    userId?: string | null
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
  }

  export type AssessmentSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AssessmentTemplateUpdateOneRequiredWithoutSessionsNestedInput
    user?: UserUpdateOneWithoutAssessmentSessionsNestedInput
  }

  export type AssessmentSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionCreateManyInput = {
    id?: string
    templateId: string
    userId?: string | null
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
  }

  export type AssessmentSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCertificationCreateInput = {
    id?: string
    name: string
    certification: string
    level?: string | null
    issuedAt: Date | string
    expiresAt?: Date | string | null
    status?: string
    certificateUrl?: string | null
    verificationCode?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCertificationsInput
  }

  export type UserCertificationUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    certification: string
    level?: string | null
    issuedAt: Date | string
    expiresAt?: Date | string | null
    status?: string
    certificateUrl?: string | null
    verificationCode?: string | null
    createdAt?: Date | string
  }

  export type UserCertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type UserCertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCertificationCreateManyInput = {
    id?: string
    userId: string
    name: string
    certification: string
    level?: string | null
    issuedAt: Date | string
    expiresAt?: Date | string | null
    status?: string
    certificateUrl?: string | null
    verificationCode?: string | null
    createdAt?: Date | string
  }

  export type UserCertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapCreateInput = {
    id?: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoadmapsInput
    userActions?: UserActionCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateInput = {
    id?: string
    userId: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userActions?: UserActionUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoadmapsNestedInput
    userActions?: UserActionUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userActions?: UserActionUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapCreateManyInput = {
    id?: string
    userId: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionCreateInput = {
    id?: string
    standardType: string
    actionCode: string
    title: string
    description: string
    requirementRef: string
    chapterNumber?: string | null
    estimatedHours?: number
    priorityWeight?: number
    category?: string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionCreatetemplateIdsInput | string[]
    videoUrl?: string | null
    dependsOnActions?: ActionCreatedependsOnActionsInput | string[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userActions?: UserActionCreateNestedManyWithoutActionInput
  }

  export type ActionUncheckedCreateInput = {
    id?: string
    standardType: string
    actionCode: string
    title: string
    description: string
    requirementRef: string
    chapterNumber?: string | null
    estimatedHours?: number
    priorityWeight?: number
    category?: string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionCreatetemplateIdsInput | string[]
    videoUrl?: string | null
    dependsOnActions?: ActionCreatedependsOnActionsInput | string[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userActions?: UserActionUncheckedCreateNestedManyWithoutActionInput
  }

  export type ActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    actionCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirementRef?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedHours?: IntFieldUpdateOperationsInput | number
    priorityWeight?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionUpdatetemplateIdsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnActions?: ActionUpdatedependsOnActionsInput | string[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userActions?: UserActionUpdateManyWithoutActionNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    actionCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirementRef?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedHours?: IntFieldUpdateOperationsInput | number
    priorityWeight?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionUpdatetemplateIdsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnActions?: ActionUpdatedependsOnActionsInput | string[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userActions?: UserActionUncheckedUpdateManyWithoutActionNestedInput
  }

  export type ActionCreateManyInput = {
    id?: string
    standardType: string
    actionCode: string
    title: string
    description: string
    requirementRef: string
    chapterNumber?: string | null
    estimatedHours?: number
    priorityWeight?: number
    category?: string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionCreatetemplateIdsInput | string[]
    videoUrl?: string | null
    dependsOnActions?: ActionCreatedependsOnActionsInput | string[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    actionCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirementRef?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedHours?: IntFieldUpdateOperationsInput | number
    priorityWeight?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionUpdatetemplateIdsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnActions?: ActionUpdatedependsOnActionsInput | string[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    actionCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirementRef?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedHours?: IntFieldUpdateOperationsInput | number
    priorityWeight?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionUpdatetemplateIdsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnActions?: ActionUpdatedependsOnActionsInput | string[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionCreateInput = {
    id?: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserActionsInput
    roadmap: RoadmapCreateNestedOneWithoutUserActionsInput
    action: ActionCreateNestedOneWithoutUserActionsInput
  }

  export type UserActionUncheckedCreateInput = {
    id?: string
    userId: string
    roadmapId: string
    actionId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserActionsNestedInput
    roadmap?: RoadmapUpdateOneRequiredWithoutUserActionsNestedInput
    action?: ActionUpdateOneRequiredWithoutUserActionsNestedInput
  }

  export type UserActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    actionId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionCreateManyInput = {
    id?: string
    userId: string
    roadmapId: string
    actionId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    actionId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    standardType: string
    templateCode: string
    title: string
    description?: string | null
    category: string
    fileUrl: string
    fileFormat: string
    fileSize?: number | null
    requirementRef?: string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateCreaterelatedActionCodesInput | string[]
    downloadCount?: number
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    standardType: string
    templateCode: string
    title: string
    description?: string | null
    category: string
    fileUrl: string
    fileFormat: string
    fileSize?: number | null
    requirementRef?: string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateCreaterelatedActionCodesInput | string[]
    downloadCount?: number
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    templateCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileFormat?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    requirementRef?: NullableStringFieldUpdateOperationsInput | string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateUpdaterelatedActionCodesInput | string[]
    downloadCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    templateCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileFormat?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    requirementRef?: NullableStringFieldUpdateOperationsInput | string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateUpdaterelatedActionCodesInput | string[]
    downloadCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateManyInput = {
    id?: string
    standardType: string
    templateCode: string
    title: string
    description?: string | null
    category: string
    fileUrl: string
    fileFormat: string
    fileSize?: number | null
    requirementRef?: string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateCreaterelatedActionCodesInput | string[]
    downloadCount?: number
    displayOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    templateCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileFormat?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    requirementRef?: NullableStringFieldUpdateOperationsInput | string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateUpdaterelatedActionCodesInput | string[]
    downloadCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    templateCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileFormat?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    requirementRef?: NullableStringFieldUpdateOperationsInput | string | null
    sectorAdaptations?: NullableJsonNullValueInput | InputJsonValue
    relatedActionCodes?: TemplateUpdaterelatedActionCodesInput | string[]
    downloadCount?: IntFieldUpdateOperationsInput | number
    displayOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardConfigCreateInput = {
    id?: string
    standardType: string
    name: string
    shortName: string
    description?: string | null
    icon?: string | null
    questions: JsonNullValueInput | InputJsonValue
    chapters: JsonNullValueInput | InputJsonValue
    maturityLevels: JsonNullValueInput | InputJsonValue
    estimatedMonths?: number
    typicalPrice?: number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardConfigUncheckedCreateInput = {
    id?: string
    standardType: string
    name: string
    shortName: string
    description?: string | null
    icon?: string | null
    questions: JsonNullValueInput | InputJsonValue
    chapters: JsonNullValueInput | InputJsonValue
    maturityLevels: JsonNullValueInput | InputJsonValue
    estimatedMonths?: number
    typicalPrice?: number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: JsonNullValueInput | InputJsonValue
    chapters?: JsonNullValueInput | InputJsonValue
    maturityLevels?: JsonNullValueInput | InputJsonValue
    estimatedMonths?: IntFieldUpdateOperationsInput | number
    typicalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: JsonNullValueInput | InputJsonValue
    chapters?: JsonNullValueInput | InputJsonValue
    maturityLevels?: JsonNullValueInput | InputJsonValue
    estimatedMonths?: IntFieldUpdateOperationsInput | number
    typicalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardConfigCreateManyInput = {
    id?: string
    standardType: string
    name: string
    shortName: string
    description?: string | null
    icon?: string | null
    questions: JsonNullValueInput | InputJsonValue
    chapters: JsonNullValueInput | InputJsonValue
    maturityLevels: JsonNullValueInput | InputJsonValue
    estimatedMonths?: number
    typicalPrice?: number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StandardConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: JsonNullValueInput | InputJsonValue
    chapters?: JsonNullValueInput | InputJsonValue
    maturityLevels?: JsonNullValueInput | InputJsonValue
    estimatedMonths?: IntFieldUpdateOperationsInput | number
    typicalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StandardConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: JsonNullValueInput | InputJsonValue
    chapters?: JsonNullValueInput | InputJsonValue
    maturityLevels?: JsonNullValueInput | InputJsonValue
    estimatedMonths?: IntFieldUpdateOperationsInput | number
    typicalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    sectorRelevance?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    page?: SortOrder
    referrer?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    eventType?: SortOrder
    page?: SortOrder
    referrer?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    eventType?: SortOrder
    page?: SortOrder
    referrer?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DailyStatCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
    eventsByType?: SortOrder
    topPages?: SortOrder
    topModules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatAvgOrderByAggregateInput = {
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
  }

  export type DailyStatMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyStatSumOrderByAggregateInput = {
    totalEvents?: SortOrder
    uniqueUsers?: SortOrder
    uniqueSessions?: SortOrder
    pageViews?: SortOrder
    quizStarted?: SortOrder
    quizCompleted?: SortOrder
    modulesViewed?: SortOrder
    lessonsCompleted?: SortOrder
    avgSessionDuration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    currentLevel?: SortOrder
    modulesStarted?: SortOrder
    modulesCompleted?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    totalXp?: SortOrder
    currentLevel?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    currentLevel?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalXp?: SortOrder
    currentLevel?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    totalXp?: SortOrder
    currentLevel?: SortOrder
    quizzesCompleted?: SortOrder
    totalCorrect?: SortOrder
    totalQuestions?: SortOrder
    avgScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metric?: SortOrder
    operator?: SortOrder
    threshold?: SortOrder
    duration?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    severity?: SortOrder
    notifyChannels?: SortOrder
    notifyRoles?: SortOrder
    cooldownMinutes?: SortOrder
    lastTriggeredAt?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertRuleAvgOrderByAggregateInput = {
    threshold?: SortOrder
    duration?: SortOrder
    cooldownMinutes?: SortOrder
  }

  export type AlertRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metric?: SortOrder
    operator?: SortOrder
    threshold?: SortOrder
    duration?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    severity?: SortOrder
    cooldownMinutes?: SortOrder
    lastTriggeredAt?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    metric?: SortOrder
    operator?: SortOrder
    threshold?: SortOrder
    duration?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    severity?: SortOrder
    cooldownMinutes?: SortOrder
    lastTriggeredAt?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertRuleSumOrderByAggregateInput = {
    threshold?: SortOrder
    duration?: SortOrder
    cooldownMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AlertRuleRelationFilter = {
    is?: AlertRuleWhereInput
    isNot?: AlertRuleWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    affectedUserId?: SortOrder
    affectedEntityType?: SortOrder
    affectedEntityId?: SortOrder
    triggerMetric?: SortOrder
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
    recommendedActions?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertAvgOrderByAggregateInput = {
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    affectedUserId?: SortOrder
    affectedEntityType?: SortOrder
    affectedEntityId?: SortOrder
    triggerMetric?: SortOrder
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    severity?: SortOrder
    title?: SortOrder
    description?: SortOrder
    affectedUserId?: SortOrder
    affectedEntityType?: SortOrder
    affectedEntityId?: SortOrder
    triggerMetric?: SortOrder
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
    status?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertSumOrderByAggregateInput = {
    triggerValue?: SortOrder
    triggerThreshold?: SortOrder
  }

  export type AlertNullableRelationFilter = {
    is?: AlertWhereInput | null
    isNot?: AlertWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    alertId?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    alertId?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    alertId?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    emailSent?: SortOrder
    emailSentAt?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedReportListRelationFilter = {
    every?: GeneratedReportWhereInput
    some?: GeneratedReportWhereInput
    none?: GeneratedReportWhereInput
  }

  export type GeneratedReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    format?: SortOrder
    config?: SortOrder
    scheduleEnabled?: SortOrder
    scheduleCron?: SortOrder
    recipients?: SortOrder
    isSystem?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    format?: SortOrder
    scheduleEnabled?: SortOrder
    scheduleCron?: SortOrder
    isSystem?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    format?: SortOrder
    scheduleEnabled?: SortOrder
    scheduleCron?: SortOrder
    isSystem?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateNullableRelationFilter = {
    is?: ReportTemplateWhereInput | null
    isNot?: ReportTemplateWhereInput | null
  }

  export type GeneratedReportCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    requestedBy?: SortOrder
    generatedAt?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    emailed?: SortOrder
    emailedAt?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedReportAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    downloadCount?: SortOrder
  }

  export type GeneratedReportMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    requestedBy?: SortOrder
    generatedAt?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    emailed?: SortOrder
    emailedAt?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedReportMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    format?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    requestedBy?: SortOrder
    generatedAt?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    emailed?: SortOrder
    emailedAt?: SortOrder
    downloadCount?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedReportSumOrderByAggregateInput = {
    fileSize?: SortOrder
    downloadCount?: SortOrder
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type AssessmentTemplateListRelationFilter = {
    every?: AssessmentTemplateWhereInput
    some?: AssessmentTemplateWhereInput
    none?: AssessmentTemplateWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    logo?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    plan?: SortOrder
    planSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    employeeCount?: SortOrder
    planSeats?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    logo?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    plan?: SortOrder
    planSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    logo?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    plan?: SortOrder
    planSeats?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    employeeCount?: SortOrder
    planSeats?: SortOrder
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DepartmentOrganizationIdNameCompoundUniqueInput = {
    organizationId: string
    name: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationNullableRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type ManagerNoteListRelationFilter = {
    every?: ManagerNoteWhereInput
    some?: ManagerNoteWhereInput
    none?: ManagerNoteWhereInput
  }

  export type ModuleAssignmentListRelationFilter = {
    every?: ModuleAssignmentWhereInput
    some?: ModuleAssignmentWhereInput
    none?: ModuleAssignmentWhereInput
  }

  export type ModuleProgressListRelationFilter = {
    every?: ModuleProgressWhereInput
    some?: ModuleProgressWhereInput
    none?: ModuleProgressWhereInput
  }

  export type AssessmentSessionListRelationFilter = {
    every?: AssessmentSessionWhereInput
    some?: AssessmentSessionWhereInput
    none?: AssessmentSessionWhereInput
  }

  export type UserCertificationListRelationFilter = {
    every?: UserCertificationWhereInput
    some?: UserCertificationWhereInput
    none?: UserCertificationWhereInput
  }

  export type RoadmapListRelationFilter = {
    every?: RoadmapWhereInput
    some?: RoadmapWhereInput
    none?: RoadmapWhereInput
  }

  export type UserActionListRelationFilter = {
    every?: UserActionWhereInput
    some?: UserActionWhereInput
    none?: UserActionWhereInput
  }

  export type ManagerNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssessmentSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    organizationId?: SortOrder
    departmentId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    position?: SortOrder
    companyName?: SortOrder
    companySize?: SortOrder
    industrySector?: SortOrder
    targetStandard?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    onboardingCompletedSteps?: SortOrder
    lastLoginAt?: SortOrder
    invitedAt?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    organizationId?: SortOrder
    departmentId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    position?: SortOrder
    companyName?: SortOrder
    companySize?: SortOrder
    industrySector?: SortOrder
    targetStandard?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    lastLoginAt?: SortOrder
    invitedAt?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    organizationId?: SortOrder
    departmentId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    position?: SortOrder
    companyName?: SortOrder
    companySize?: SortOrder
    industrySector?: SortOrder
    targetStandard?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionStartDate?: SortOrder
    subscriptionEndDate?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    lastLoginAt?: SortOrder
    invitedAt?: SortOrder
    invitedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ManagerNoteAboutUserIdByUserIdCompoundUniqueInput = {
    aboutUserId: string
    byUserId: string
  }

  export type ManagerNoteCountOrderByAggregateInput = {
    id?: SortOrder
    aboutUserId?: SortOrder
    byUserId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    aboutUserId?: SortOrder
    byUserId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerNoteMinOrderByAggregateInput = {
    id?: SortOrder
    aboutUserId?: SortOrder
    byUserId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModulePrerequisiteListRelationFilter = {
    every?: ModulePrerequisiteWhereInput
    some?: ModulePrerequisiteWhereInput
    none?: ModulePrerequisiteWhereInput
  }

  export type ModulePrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    sections?: SortOrder
    xpReward?: SortOrder
    badge?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    xpReward?: SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    xpReward?: SortOrder
    badge?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    difficulty?: SortOrder
    estimatedDuration?: SortOrder
    xpReward?: SortOrder
    badge?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
    xpReward?: SortOrder
    completionCount?: SortOrder
    avgScore?: SortOrder
  }

  export type ModuleRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type ModulePrerequisiteModuleIdPrerequisiteIdCompoundUniqueInput = {
    moduleId: string
    prerequisiteId: string
  }

  export type ModulePrerequisiteCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type ModulePrerequisiteMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type ModulePrerequisiteMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    prerequisiteId?: SortOrder
  }

  export type ModuleAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    message?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ModuleAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    message?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ModuleAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    assignedToId?: SortOrder
    assignedById?: SortOrder
    priority?: SortOrder
    deadline?: SortOrder
    message?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ModuleProgressUserIdModuleIdCompoundUniqueInput = {
    userId: string
    moduleId: string
  }

  export type ModuleProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    progressPercent?: SortOrder
    completedSections?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrder
    quizAttempts?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleProgressAvgOrderByAggregateInput = {
    progressPercent?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrder
    quizAttempts?: SortOrder
  }

  export type ModuleProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    progressPercent?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrder
    quizAttempts?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    moduleId?: SortOrder
    status?: SortOrder
    progressPercent?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrder
    quizAttempts?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleProgressSumOrderByAggregateInput = {
    progressPercent?: SortOrder
    timeSpentSeconds?: SortOrder
    quizScore?: SortOrder
    quizAttempts?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AssessmentTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    certification?: SortOrder
    version?: SortOrder
    estimatedDuration?: SortOrder
    sections?: SortOrder
    scoringMethod?: SortOrder
    maturityLevels?: SortOrder
    status?: SortOrder
    isDemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentTemplateAvgOrderByAggregateInput = {
    estimatedDuration?: SortOrder
  }

  export type AssessmentTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    certification?: SortOrder
    version?: SortOrder
    estimatedDuration?: SortOrder
    scoringMethod?: SortOrder
    status?: SortOrder
    isDemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    certification?: SortOrder
    version?: SortOrder
    estimatedDuration?: SortOrder
    scoringMethod?: SortOrder
    status?: SortOrder
    isDemo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssessmentTemplateSumOrderByAggregateInput = {
    estimatedDuration?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AssessmentTemplateRelationFilter = {
    is?: AssessmentTemplateWhereInput
    isNot?: AssessmentTemplateWhereInput
  }

  export type AssessmentSessionCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    answers?: SortOrder
    sectionScores?: SortOrder
    overallScore?: SortOrder
    maturityLevel?: SortOrder
    gapAnalysis?: SortOrder
    recommendations?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    convertedToSignup?: SortOrder
    pdfDownloaded?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentSessionAvgOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type AssessmentSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    overallScore?: SortOrder
    maturityLevel?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    convertedToSignup?: SortOrder
    pdfDownloaded?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentSessionMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    companyName?: SortOrder
    industry?: SortOrder
    employeeCount?: SortOrder
    overallScore?: SortOrder
    maturityLevel?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    convertedToSignup?: SortOrder
    pdfDownloaded?: SortOrder
    createdAt?: SortOrder
  }

  export type AssessmentSessionSumOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type UserCertificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    certification?: SortOrder
    level?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrder
    verificationCode?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    certification?: SortOrder
    level?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrder
    verificationCode?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCertificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    certification?: SortOrder
    level?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    certificateUrl?: SortOrder
    verificationCode?: SortOrder
    createdAt?: SortOrder
  }

  export type RoadmapCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentSessionId?: SortOrder
    standardType?: SortOrder
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
    estimatedCompletionDate?: SortOrder
    status?: SortOrder
    sprintDetails?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapAvgOrderByAggregateInput = {
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
  }

  export type RoadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentSessionId?: SortOrder
    standardType?: SortOrder
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
    estimatedCompletionDate?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assessmentSessionId?: SortOrder
    standardType?: SortOrder
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
    estimatedCompletionDate?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapSumOrderByAggregateInput = {
    totalSprints?: SortOrder
    currentSprint?: SortOrder
    sprintDurationWeeks?: SortOrder
    completionPercentage?: SortOrder
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    actionCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirementRef?: SortOrder
    chapterNumber?: SortOrder
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    category?: SortOrder
    sectorVariations?: SortOrder
    templateIds?: SortOrder
    videoUrl?: SortOrder
    dependsOnActions?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    displayOrder?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    actionCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirementRef?: SortOrder
    chapterNumber?: SortOrder
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    category?: SortOrder
    videoUrl?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    actionCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    requirementRef?: SortOrder
    chapterNumber?: SortOrder
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    category?: SortOrder
    videoUrl?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    estimatedHours?: SortOrder
    priorityWeight?: SortOrder
    displayOrder?: SortOrder
  }

  export type RoadmapRelationFilter = {
    is?: RoadmapWhereInput
    isNot?: RoadmapWhereInput
  }

  export type ActionRelationFilter = {
    is?: ActionWhereInput
    isNot?: ActionWhereInput
  }

  export type UserActionRoadmapIdActionIdCompoundUniqueInput = {
    roadmapId: string
    actionId: string
  }

  export type UserActionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    actionId?: SortOrder
    sprintNumber?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    blockedReason?: SortOrder
    uploadedFiles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserActionAvgOrderByAggregateInput = {
    sprintNumber?: SortOrder
  }

  export type UserActionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    actionId?: SortOrder
    sprintNumber?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    blockedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserActionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    actionId?: SortOrder
    sprintNumber?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
    blockedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserActionSumOrderByAggregateInput = {
    sprintNumber?: SortOrder
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    templateCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileFormat?: SortOrder
    fileSize?: SortOrder
    requirementRef?: SortOrder
    sectorAdaptations?: SortOrder
    relatedActionCodes?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    templateCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileFormat?: SortOrder
    fileSize?: SortOrder
    requirementRef?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    templateCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    fileFormat?: SortOrder
    fileSize?: SortOrder
    requirementRef?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSumOrderByAggregateInput = {
    fileSize?: SortOrder
    downloadCount?: SortOrder
    displayOrder?: SortOrder
  }

  export type StandardConfigCountOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    questions?: SortOrder
    chapters?: SortOrder
    maturityLevels?: SortOrder
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrder
    sectorRelevance?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardConfigAvgOrderByAggregateInput = {
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrder
  }

  export type StandardConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardConfigMinOrderByAggregateInput = {
    id?: SortOrder
    standardType?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StandardConfigSumOrderByAggregateInput = {
    estimatedMonths?: SortOrder
    typicalPrice?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProgressCreatemodulesStartedInput = {
    set: string[]
  }

  export type UserProgressCreatemodulesCompletedInput = {
    set: string[]
  }

  export type UserProgressUpdatemodulesStartedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProgressUpdatemodulesCompletedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AlertRuleCreatenotifyChannelsInput = {
    set: string[]
  }

  export type AlertRuleCreatenotifyRolesInput = {
    set: string[]
  }

  export type AlertCreateNestedManyWithoutRuleInput = {
    create?: XOR<AlertCreateWithoutRuleInput, AlertUncheckedCreateWithoutRuleInput> | AlertCreateWithoutRuleInput[] | AlertUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutRuleInput | AlertCreateOrConnectWithoutRuleInput[]
    createMany?: AlertCreateManyRuleInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<AlertCreateWithoutRuleInput, AlertUncheckedCreateWithoutRuleInput> | AlertCreateWithoutRuleInput[] | AlertUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutRuleInput | AlertCreateOrConnectWithoutRuleInput[]
    createMany?: AlertCreateManyRuleInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AlertRuleUpdatenotifyChannelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AlertRuleUpdatenotifyRolesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AlertUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AlertCreateWithoutRuleInput, AlertUncheckedCreateWithoutRuleInput> | AlertCreateWithoutRuleInput[] | AlertUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutRuleInput | AlertCreateOrConnectWithoutRuleInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutRuleInput | AlertUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AlertCreateManyRuleInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutRuleInput | AlertUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutRuleInput | AlertUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<AlertCreateWithoutRuleInput, AlertUncheckedCreateWithoutRuleInput> | AlertCreateWithoutRuleInput[] | AlertUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutRuleInput | AlertCreateOrConnectWithoutRuleInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutRuleInput | AlertUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: AlertCreateManyRuleInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutRuleInput | AlertUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutRuleInput | AlertUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type AlertCreaterecommendedActionsInput = {
    set: string[]
  }

  export type AlertRuleCreateNestedOneWithoutAlertsInput = {
    create?: XOR<AlertRuleCreateWithoutAlertsInput, AlertRuleUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: AlertRuleCreateOrConnectWithoutAlertsInput
    connect?: AlertRuleWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutAlertInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAlertInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AlertUpdaterecommendedActionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AlertRuleUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<AlertRuleCreateWithoutAlertsInput, AlertRuleUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: AlertRuleCreateOrConnectWithoutAlertsInput
    upsert?: AlertRuleUpsertWithoutAlertsInput
    connect?: AlertRuleWhereUniqueInput
    update?: XOR<XOR<AlertRuleUpdateToOneWithWhereWithoutAlertsInput, AlertRuleUpdateWithoutAlertsInput>, AlertRuleUncheckedUpdateWithoutAlertsInput>
  }

  export type NotificationUpdateManyWithoutAlertNestedInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAlertInput | NotificationUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAlertInput | NotificationUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAlertInput | NotificationUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAlertNestedInput = {
    create?: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput> | NotificationCreateWithoutAlertInput[] | NotificationUncheckedCreateWithoutAlertInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAlertInput | NotificationCreateOrConnectWithoutAlertInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAlertInput | NotificationUpsertWithWhereUniqueWithoutAlertInput[]
    createMany?: NotificationCreateManyAlertInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAlertInput | NotificationUpdateWithWhereUniqueWithoutAlertInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAlertInput | NotificationUpdateManyWithWhereWithoutAlertInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AlertCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutNotificationsInput
    connect?: AlertWhereUniqueInput
  }

  export type AlertUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AlertCreateOrConnectWithoutNotificationsInput
    upsert?: AlertUpsertWithoutNotificationsInput
    disconnect?: AlertWhereInput | boolean
    delete?: AlertWhereInput | boolean
    connect?: AlertWhereUniqueInput
    update?: XOR<XOR<AlertUpdateToOneWithWhereWithoutNotificationsInput, AlertUpdateWithoutNotificationsInput>, AlertUncheckedUpdateWithoutNotificationsInput>
  }

  export type ReportTemplateCreaterecipientsInput = {
    set: string[]
  }

  export type GeneratedReportCreateNestedManyWithoutTemplateInput = {
    create?: XOR<GeneratedReportCreateWithoutTemplateInput, GeneratedReportUncheckedCreateWithoutTemplateInput> | GeneratedReportCreateWithoutTemplateInput[] | GeneratedReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedReportCreateOrConnectWithoutTemplateInput | GeneratedReportCreateOrConnectWithoutTemplateInput[]
    createMany?: GeneratedReportCreateManyTemplateInputEnvelope
    connect?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
  }

  export type GeneratedReportUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<GeneratedReportCreateWithoutTemplateInput, GeneratedReportUncheckedCreateWithoutTemplateInput> | GeneratedReportCreateWithoutTemplateInput[] | GeneratedReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedReportCreateOrConnectWithoutTemplateInput | GeneratedReportCreateOrConnectWithoutTemplateInput[]
    createMany?: GeneratedReportCreateManyTemplateInputEnvelope
    connect?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
  }

  export type ReportTemplateUpdaterecipientsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GeneratedReportUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<GeneratedReportCreateWithoutTemplateInput, GeneratedReportUncheckedCreateWithoutTemplateInput> | GeneratedReportCreateWithoutTemplateInput[] | GeneratedReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedReportCreateOrConnectWithoutTemplateInput | GeneratedReportCreateOrConnectWithoutTemplateInput[]
    upsert?: GeneratedReportUpsertWithWhereUniqueWithoutTemplateInput | GeneratedReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: GeneratedReportCreateManyTemplateInputEnvelope
    set?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    disconnect?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    delete?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    connect?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    update?: GeneratedReportUpdateWithWhereUniqueWithoutTemplateInput | GeneratedReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: GeneratedReportUpdateManyWithWhereWithoutTemplateInput | GeneratedReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: GeneratedReportScalarWhereInput | GeneratedReportScalarWhereInput[]
  }

  export type GeneratedReportUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<GeneratedReportCreateWithoutTemplateInput, GeneratedReportUncheckedCreateWithoutTemplateInput> | GeneratedReportCreateWithoutTemplateInput[] | GeneratedReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: GeneratedReportCreateOrConnectWithoutTemplateInput | GeneratedReportCreateOrConnectWithoutTemplateInput[]
    upsert?: GeneratedReportUpsertWithWhereUniqueWithoutTemplateInput | GeneratedReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: GeneratedReportCreateManyTemplateInputEnvelope
    set?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    disconnect?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    delete?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    connect?: GeneratedReportWhereUniqueInput | GeneratedReportWhereUniqueInput[]
    update?: GeneratedReportUpdateWithWhereUniqueWithoutTemplateInput | GeneratedReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: GeneratedReportUpdateManyWithWhereWithoutTemplateInput | GeneratedReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: GeneratedReportScalarWhereInput | GeneratedReportScalarWhereInput[]
  }

  export type ReportTemplateCreateNestedOneWithoutReportsInput = {
    create?: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutReportsInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type ReportTemplateUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutReportsInput
    upsert?: ReportTemplateUpsertWithoutReportsInput
    disconnect?: ReportTemplateWhereInput | boolean
    delete?: ReportTemplateWhereInput | boolean
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutReportsInput, ReportTemplateUpdateWithoutReportsInput>, ReportTemplateUncheckedUpdateWithoutReportsInput>
  }

  export type DepartmentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ModuleCreateWithoutOrganizationInput, ModuleUncheckedCreateWithoutOrganizationInput> | ModuleCreateWithoutOrganizationInput[] | ModuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOrganizationInput | ModuleCreateOrConnectWithoutOrganizationInput[]
    createMany?: ModuleCreateManyOrganizationInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type AssessmentTemplateCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AssessmentTemplateCreateWithoutOrganizationInput, AssessmentTemplateUncheckedCreateWithoutOrganizationInput> | AssessmentTemplateCreateWithoutOrganizationInput[] | AssessmentTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AssessmentTemplateCreateOrConnectWithoutOrganizationInput | AssessmentTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: AssessmentTemplateCreateManyOrganizationInputEnvelope
    connect?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ModuleCreateWithoutOrganizationInput, ModuleUncheckedCreateWithoutOrganizationInput> | ModuleCreateWithoutOrganizationInput[] | ModuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOrganizationInput | ModuleCreateOrConnectWithoutOrganizationInput[]
    createMany?: ModuleCreateManyOrganizationInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type AssessmentTemplateUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AssessmentTemplateCreateWithoutOrganizationInput, AssessmentTemplateUncheckedCreateWithoutOrganizationInput> | AssessmentTemplateCreateWithoutOrganizationInput[] | AssessmentTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AssessmentTemplateCreateOrConnectWithoutOrganizationInput | AssessmentTemplateCreateOrConnectWithoutOrganizationInput[]
    createMany?: AssessmentTemplateCreateManyOrganizationInputEnvelope
    connect?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
  }

  export type DepartmentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutOrganizationInput | DepartmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutOrganizationInput | DepartmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutOrganizationInput | DepartmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ModuleCreateWithoutOrganizationInput, ModuleUncheckedCreateWithoutOrganizationInput> | ModuleCreateWithoutOrganizationInput[] | ModuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOrganizationInput | ModuleCreateOrConnectWithoutOrganizationInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutOrganizationInput | ModuleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ModuleCreateManyOrganizationInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutOrganizationInput | ModuleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutOrganizationInput | ModuleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type AssessmentTemplateUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AssessmentTemplateCreateWithoutOrganizationInput, AssessmentTemplateUncheckedCreateWithoutOrganizationInput> | AssessmentTemplateCreateWithoutOrganizationInput[] | AssessmentTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AssessmentTemplateCreateOrConnectWithoutOrganizationInput | AssessmentTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: AssessmentTemplateUpsertWithWhereUniqueWithoutOrganizationInput | AssessmentTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AssessmentTemplateCreateManyOrganizationInputEnvelope
    set?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    disconnect?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    delete?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    connect?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    update?: AssessmentTemplateUpdateWithWhereUniqueWithoutOrganizationInput | AssessmentTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AssessmentTemplateUpdateManyWithWhereWithoutOrganizationInput | AssessmentTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AssessmentTemplateScalarWhereInput | AssessmentTemplateScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput> | DepartmentCreateWithoutOrganizationInput[] | DepartmentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrganizationInput | DepartmentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutOrganizationInput | DepartmentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DepartmentCreateManyOrganizationInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutOrganizationInput | DepartmentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutOrganizationInput | DepartmentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ModuleCreateWithoutOrganizationInput, ModuleUncheckedCreateWithoutOrganizationInput> | ModuleCreateWithoutOrganizationInput[] | ModuleUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutOrganizationInput | ModuleCreateOrConnectWithoutOrganizationInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutOrganizationInput | ModuleUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ModuleCreateManyOrganizationInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutOrganizationInput | ModuleUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutOrganizationInput | ModuleUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type AssessmentTemplateUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AssessmentTemplateCreateWithoutOrganizationInput, AssessmentTemplateUncheckedCreateWithoutOrganizationInput> | AssessmentTemplateCreateWithoutOrganizationInput[] | AssessmentTemplateUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AssessmentTemplateCreateOrConnectWithoutOrganizationInput | AssessmentTemplateCreateOrConnectWithoutOrganizationInput[]
    upsert?: AssessmentTemplateUpsertWithWhereUniqueWithoutOrganizationInput | AssessmentTemplateUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AssessmentTemplateCreateManyOrganizationInputEnvelope
    set?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    disconnect?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    delete?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    connect?: AssessmentTemplateWhereUniqueInput | AssessmentTemplateWhereUniqueInput[]
    update?: AssessmentTemplateUpdateWithWhereUniqueWithoutOrganizationInput | AssessmentTemplateUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AssessmentTemplateUpdateManyWithWhereWithoutOrganizationInput | AssessmentTemplateUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AssessmentTemplateScalarWhereInput | AssessmentTemplateScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartmentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedDepartmentsInput = {
    create?: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartmentsInput
    upsert?: OrganizationUpsertWithoutDepartmentsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDepartmentsInput, OrganizationUpdateWithoutDepartmentsInput>, OrganizationUncheckedUpdateWithoutDepartmentsInput>
  }

  export type UserUpdateOneWithoutManagedDepartmentsNestedInput = {
    create?: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedDepartmentsInput
    upsert?: UserUpsertWithoutManagedDepartmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedDepartmentsInput, UserUpdateWithoutManagedDepartmentsInput>, UserUncheckedUpdateWithoutManagedDepartmentsInput>
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateonboardingCompletedStepsInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutMembersInput = {
    create?: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMembersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ManagerNoteCreateNestedManyWithoutAboutUserInput = {
    create?: XOR<ManagerNoteCreateWithoutAboutUserInput, ManagerNoteUncheckedCreateWithoutAboutUserInput> | ManagerNoteCreateWithoutAboutUserInput[] | ManagerNoteUncheckedCreateWithoutAboutUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutAboutUserInput | ManagerNoteCreateOrConnectWithoutAboutUserInput[]
    createMany?: ManagerNoteCreateManyAboutUserInputEnvelope
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
  }

  export type ManagerNoteCreateNestedManyWithoutByUserInput = {
    create?: XOR<ManagerNoteCreateWithoutByUserInput, ManagerNoteUncheckedCreateWithoutByUserInput> | ManagerNoteCreateWithoutByUserInput[] | ManagerNoteUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutByUserInput | ManagerNoteCreateOrConnectWithoutByUserInput[]
    createMany?: ManagerNoteCreateManyByUserInputEnvelope
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutManagerInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type ModuleAssignmentCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedToInput, ModuleAssignmentUncheckedCreateWithoutAssignedToInput> | ModuleAssignmentCreateWithoutAssignedToInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedToInput | ModuleAssignmentCreateOrConnectWithoutAssignedToInput[]
    createMany?: ModuleAssignmentCreateManyAssignedToInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ModuleAssignmentCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedByInput, ModuleAssignmentUncheckedCreateWithoutAssignedByInput> | ModuleAssignmentCreateWithoutAssignedByInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedByInput | ModuleAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: ModuleAssignmentCreateManyAssignedByInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ModuleProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<ModuleProgressCreateWithoutUserInput, ModuleProgressUncheckedCreateWithoutUserInput> | ModuleProgressCreateWithoutUserInput[] | ModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutUserInput | ModuleProgressCreateOrConnectWithoutUserInput[]
    createMany?: ModuleProgressCreateManyUserInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type AssessmentSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AssessmentSessionCreateWithoutUserInput, AssessmentSessionUncheckedCreateWithoutUserInput> | AssessmentSessionCreateWithoutUserInput[] | AssessmentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutUserInput | AssessmentSessionCreateOrConnectWithoutUserInput[]
    createMany?: AssessmentSessionCreateManyUserInputEnvelope
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
  }

  export type UserCertificationCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCertificationCreateWithoutUserInput, UserCertificationUncheckedCreateWithoutUserInput> | UserCertificationCreateWithoutUserInput[] | UserCertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCertificationCreateOrConnectWithoutUserInput | UserCertificationCreateOrConnectWithoutUserInput[]
    createMany?: UserCertificationCreateManyUserInputEnvelope
    connect?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
  }

  export type RoadmapCreateNestedManyWithoutUserInput = {
    create?: XOR<RoadmapCreateWithoutUserInput, RoadmapUncheckedCreateWithoutUserInput> | RoadmapCreateWithoutUserInput[] | RoadmapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutUserInput | RoadmapCreateOrConnectWithoutUserInput[]
    createMany?: RoadmapCreateManyUserInputEnvelope
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
  }

  export type UserActionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActionCreateWithoutUserInput, UserActionUncheckedCreateWithoutUserInput> | UserActionCreateWithoutUserInput[] | UserActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutUserInput | UserActionCreateOrConnectWithoutUserInput[]
    createMany?: UserActionCreateManyUserInputEnvelope
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
  }

  export type ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput = {
    create?: XOR<ManagerNoteCreateWithoutAboutUserInput, ManagerNoteUncheckedCreateWithoutAboutUserInput> | ManagerNoteCreateWithoutAboutUserInput[] | ManagerNoteUncheckedCreateWithoutAboutUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutAboutUserInput | ManagerNoteCreateOrConnectWithoutAboutUserInput[]
    createMany?: ManagerNoteCreateManyAboutUserInputEnvelope
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
  }

  export type ManagerNoteUncheckedCreateNestedManyWithoutByUserInput = {
    create?: XOR<ManagerNoteCreateWithoutByUserInput, ManagerNoteUncheckedCreateWithoutByUserInput> | ManagerNoteCreateWithoutByUserInput[] | ManagerNoteUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutByUserInput | ManagerNoteCreateOrConnectWithoutByUserInput[]
    createMany?: ManagerNoteCreateManyByUserInputEnvelope
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedToInput, ModuleAssignmentUncheckedCreateWithoutAssignedToInput> | ModuleAssignmentCreateWithoutAssignedToInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedToInput | ModuleAssignmentCreateOrConnectWithoutAssignedToInput[]
    createMany?: ModuleAssignmentCreateManyAssignedToInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedByInput, ModuleAssignmentUncheckedCreateWithoutAssignedByInput> | ModuleAssignmentCreateWithoutAssignedByInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedByInput | ModuleAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: ModuleAssignmentCreateManyAssignedByInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ModuleProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ModuleProgressCreateWithoutUserInput, ModuleProgressUncheckedCreateWithoutUserInput> | ModuleProgressCreateWithoutUserInput[] | ModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutUserInput | ModuleProgressCreateOrConnectWithoutUserInput[]
    createMany?: ModuleProgressCreateManyUserInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type AssessmentSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AssessmentSessionCreateWithoutUserInput, AssessmentSessionUncheckedCreateWithoutUserInput> | AssessmentSessionCreateWithoutUserInput[] | AssessmentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutUserInput | AssessmentSessionCreateOrConnectWithoutUserInput[]
    createMany?: AssessmentSessionCreateManyUserInputEnvelope
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
  }

  export type UserCertificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCertificationCreateWithoutUserInput, UserCertificationUncheckedCreateWithoutUserInput> | UserCertificationCreateWithoutUserInput[] | UserCertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCertificationCreateOrConnectWithoutUserInput | UserCertificationCreateOrConnectWithoutUserInput[]
    createMany?: UserCertificationCreateManyUserInputEnvelope
    connect?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
  }

  export type RoadmapUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoadmapCreateWithoutUserInput, RoadmapUncheckedCreateWithoutUserInput> | RoadmapCreateWithoutUserInput[] | RoadmapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutUserInput | RoadmapCreateOrConnectWithoutUserInput[]
    createMany?: RoadmapCreateManyUserInputEnvelope
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
  }

  export type UserActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserActionCreateWithoutUserInput, UserActionUncheckedCreateWithoutUserInput> | UserActionCreateWithoutUserInput[] | UserActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutUserInput | UserActionCreateOrConnectWithoutUserInput[]
    createMany?: UserActionCreateManyUserInputEnvelope
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
  }

  export type UserUpdateonboardingCompletedStepsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateOneWithoutMembersNestedInput = {
    create?: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutMembersInput
    upsert?: DepartmentUpsertWithoutMembersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutMembersInput, DepartmentUpdateWithoutMembersInput>, DepartmentUncheckedUpdateWithoutMembersInput>
  }

  export type ManagerNoteUpdateManyWithoutAboutUserNestedInput = {
    create?: XOR<ManagerNoteCreateWithoutAboutUserInput, ManagerNoteUncheckedCreateWithoutAboutUserInput> | ManagerNoteCreateWithoutAboutUserInput[] | ManagerNoteUncheckedCreateWithoutAboutUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutAboutUserInput | ManagerNoteCreateOrConnectWithoutAboutUserInput[]
    upsert?: ManagerNoteUpsertWithWhereUniqueWithoutAboutUserInput | ManagerNoteUpsertWithWhereUniqueWithoutAboutUserInput[]
    createMany?: ManagerNoteCreateManyAboutUserInputEnvelope
    set?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    disconnect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    delete?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    update?: ManagerNoteUpdateWithWhereUniqueWithoutAboutUserInput | ManagerNoteUpdateWithWhereUniqueWithoutAboutUserInput[]
    updateMany?: ManagerNoteUpdateManyWithWhereWithoutAboutUserInput | ManagerNoteUpdateManyWithWhereWithoutAboutUserInput[]
    deleteMany?: ManagerNoteScalarWhereInput | ManagerNoteScalarWhereInput[]
  }

  export type ManagerNoteUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ManagerNoteCreateWithoutByUserInput, ManagerNoteUncheckedCreateWithoutByUserInput> | ManagerNoteCreateWithoutByUserInput[] | ManagerNoteUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutByUserInput | ManagerNoteCreateOrConnectWithoutByUserInput[]
    upsert?: ManagerNoteUpsertWithWhereUniqueWithoutByUserInput | ManagerNoteUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ManagerNoteCreateManyByUserInputEnvelope
    set?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    disconnect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    delete?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    update?: ManagerNoteUpdateWithWhereUniqueWithoutByUserInput | ManagerNoteUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ManagerNoteUpdateManyWithWhereWithoutByUserInput | ManagerNoteUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ManagerNoteScalarWhereInput | ManagerNoteScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutManagerInput | DepartmentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutManagerInput | DepartmentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutManagerInput | DepartmentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type ModuleAssignmentUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedToInput, ModuleAssignmentUncheckedCreateWithoutAssignedToInput> | ModuleAssignmentCreateWithoutAssignedToInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedToInput | ModuleAssignmentCreateOrConnectWithoutAssignedToInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedToInput | ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ModuleAssignmentCreateManyAssignedToInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedToInput | ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutAssignedToInput | ModuleAssignmentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ModuleAssignmentUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedByInput, ModuleAssignmentUncheckedCreateWithoutAssignedByInput> | ModuleAssignmentCreateWithoutAssignedByInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedByInput | ModuleAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ModuleAssignmentCreateManyAssignedByInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutAssignedByInput | ModuleAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ModuleProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutUserInput, ModuleProgressUncheckedCreateWithoutUserInput> | ModuleProgressCreateWithoutUserInput[] | ModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutUserInput | ModuleProgressCreateOrConnectWithoutUserInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutUserInput | ModuleProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModuleProgressCreateManyUserInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutUserInput | ModuleProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutUserInput | ModuleProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type AssessmentSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssessmentSessionCreateWithoutUserInput, AssessmentSessionUncheckedCreateWithoutUserInput> | AssessmentSessionCreateWithoutUserInput[] | AssessmentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutUserInput | AssessmentSessionCreateOrConnectWithoutUserInput[]
    upsert?: AssessmentSessionUpsertWithWhereUniqueWithoutUserInput | AssessmentSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssessmentSessionCreateManyUserInputEnvelope
    set?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    disconnect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    delete?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    update?: AssessmentSessionUpdateWithWhereUniqueWithoutUserInput | AssessmentSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssessmentSessionUpdateManyWithWhereWithoutUserInput | AssessmentSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssessmentSessionScalarWhereInput | AssessmentSessionScalarWhereInput[]
  }

  export type UserCertificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCertificationCreateWithoutUserInput, UserCertificationUncheckedCreateWithoutUserInput> | UserCertificationCreateWithoutUserInput[] | UserCertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCertificationCreateOrConnectWithoutUserInput | UserCertificationCreateOrConnectWithoutUserInput[]
    upsert?: UserCertificationUpsertWithWhereUniqueWithoutUserInput | UserCertificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCertificationCreateManyUserInputEnvelope
    set?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    disconnect?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    delete?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    connect?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    update?: UserCertificationUpdateWithWhereUniqueWithoutUserInput | UserCertificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCertificationUpdateManyWithWhereWithoutUserInput | UserCertificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCertificationScalarWhereInput | UserCertificationScalarWhereInput[]
  }

  export type RoadmapUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoadmapCreateWithoutUserInput, RoadmapUncheckedCreateWithoutUserInput> | RoadmapCreateWithoutUserInput[] | RoadmapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutUserInput | RoadmapCreateOrConnectWithoutUserInput[]
    upsert?: RoadmapUpsertWithWhereUniqueWithoutUserInput | RoadmapUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoadmapCreateManyUserInputEnvelope
    set?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    disconnect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    delete?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    update?: RoadmapUpdateWithWhereUniqueWithoutUserInput | RoadmapUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoadmapUpdateManyWithWhereWithoutUserInput | RoadmapUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
  }

  export type UserActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActionCreateWithoutUserInput, UserActionUncheckedCreateWithoutUserInput> | UserActionCreateWithoutUserInput[] | UserActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutUserInput | UserActionCreateOrConnectWithoutUserInput[]
    upsert?: UserActionUpsertWithWhereUniqueWithoutUserInput | UserActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActionCreateManyUserInputEnvelope
    set?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    disconnect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    delete?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    update?: UserActionUpdateWithWhereUniqueWithoutUserInput | UserActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActionUpdateManyWithWhereWithoutUserInput | UserActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
  }

  export type ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput = {
    create?: XOR<ManagerNoteCreateWithoutAboutUserInput, ManagerNoteUncheckedCreateWithoutAboutUserInput> | ManagerNoteCreateWithoutAboutUserInput[] | ManagerNoteUncheckedCreateWithoutAboutUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutAboutUserInput | ManagerNoteCreateOrConnectWithoutAboutUserInput[]
    upsert?: ManagerNoteUpsertWithWhereUniqueWithoutAboutUserInput | ManagerNoteUpsertWithWhereUniqueWithoutAboutUserInput[]
    createMany?: ManagerNoteCreateManyAboutUserInputEnvelope
    set?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    disconnect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    delete?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    update?: ManagerNoteUpdateWithWhereUniqueWithoutAboutUserInput | ManagerNoteUpdateWithWhereUniqueWithoutAboutUserInput[]
    updateMany?: ManagerNoteUpdateManyWithWhereWithoutAboutUserInput | ManagerNoteUpdateManyWithWhereWithoutAboutUserInput[]
    deleteMany?: ManagerNoteScalarWhereInput | ManagerNoteScalarWhereInput[]
  }

  export type ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput = {
    create?: XOR<ManagerNoteCreateWithoutByUserInput, ManagerNoteUncheckedCreateWithoutByUserInput> | ManagerNoteCreateWithoutByUserInput[] | ManagerNoteUncheckedCreateWithoutByUserInput[]
    connectOrCreate?: ManagerNoteCreateOrConnectWithoutByUserInput | ManagerNoteCreateOrConnectWithoutByUserInput[]
    upsert?: ManagerNoteUpsertWithWhereUniqueWithoutByUserInput | ManagerNoteUpsertWithWhereUniqueWithoutByUserInput[]
    createMany?: ManagerNoteCreateManyByUserInputEnvelope
    set?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    disconnect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    delete?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    connect?: ManagerNoteWhereUniqueInput | ManagerNoteWhereUniqueInput[]
    update?: ManagerNoteUpdateWithWhereUniqueWithoutByUserInput | ManagerNoteUpdateWithWhereUniqueWithoutByUserInput[]
    updateMany?: ManagerNoteUpdateManyWithWhereWithoutByUserInput | ManagerNoteUpdateManyWithWhereWithoutByUserInput[]
    deleteMany?: ManagerNoteScalarWhereInput | ManagerNoteScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutManagerInput | DepartmentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutManagerInput | DepartmentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutManagerInput | DepartmentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedToInput, ModuleAssignmentUncheckedCreateWithoutAssignedToInput> | ModuleAssignmentCreateWithoutAssignedToInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedToInput | ModuleAssignmentCreateOrConnectWithoutAssignedToInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedToInput | ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ModuleAssignmentCreateManyAssignedToInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedToInput | ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutAssignedToInput | ModuleAssignmentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutAssignedByInput, ModuleAssignmentUncheckedCreateWithoutAssignedByInput> | ModuleAssignmentCreateWithoutAssignedByInput[] | ModuleAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutAssignedByInput | ModuleAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ModuleAssignmentCreateManyAssignedByInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutAssignedByInput | ModuleAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ModuleProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutUserInput, ModuleProgressUncheckedCreateWithoutUserInput> | ModuleProgressCreateWithoutUserInput[] | ModuleProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutUserInput | ModuleProgressCreateOrConnectWithoutUserInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutUserInput | ModuleProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModuleProgressCreateManyUserInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutUserInput | ModuleProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutUserInput | ModuleProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AssessmentSessionCreateWithoutUserInput, AssessmentSessionUncheckedCreateWithoutUserInput> | AssessmentSessionCreateWithoutUserInput[] | AssessmentSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutUserInput | AssessmentSessionCreateOrConnectWithoutUserInput[]
    upsert?: AssessmentSessionUpsertWithWhereUniqueWithoutUserInput | AssessmentSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AssessmentSessionCreateManyUserInputEnvelope
    set?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    disconnect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    delete?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    update?: AssessmentSessionUpdateWithWhereUniqueWithoutUserInput | AssessmentSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AssessmentSessionUpdateManyWithWhereWithoutUserInput | AssessmentSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AssessmentSessionScalarWhereInput | AssessmentSessionScalarWhereInput[]
  }

  export type UserCertificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCertificationCreateWithoutUserInput, UserCertificationUncheckedCreateWithoutUserInput> | UserCertificationCreateWithoutUserInput[] | UserCertificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCertificationCreateOrConnectWithoutUserInput | UserCertificationCreateOrConnectWithoutUserInput[]
    upsert?: UserCertificationUpsertWithWhereUniqueWithoutUserInput | UserCertificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCertificationCreateManyUserInputEnvelope
    set?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    disconnect?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    delete?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    connect?: UserCertificationWhereUniqueInput | UserCertificationWhereUniqueInput[]
    update?: UserCertificationUpdateWithWhereUniqueWithoutUserInput | UserCertificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCertificationUpdateManyWithWhereWithoutUserInput | UserCertificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCertificationScalarWhereInput | UserCertificationScalarWhereInput[]
  }

  export type RoadmapUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoadmapCreateWithoutUserInput, RoadmapUncheckedCreateWithoutUserInput> | RoadmapCreateWithoutUserInput[] | RoadmapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutUserInput | RoadmapCreateOrConnectWithoutUserInput[]
    upsert?: RoadmapUpsertWithWhereUniqueWithoutUserInput | RoadmapUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoadmapCreateManyUserInputEnvelope
    set?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    disconnect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    delete?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    update?: RoadmapUpdateWithWhereUniqueWithoutUserInput | RoadmapUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoadmapUpdateManyWithWhereWithoutUserInput | RoadmapUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
  }

  export type UserActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserActionCreateWithoutUserInput, UserActionUncheckedCreateWithoutUserInput> | UserActionCreateWithoutUserInput[] | UserActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutUserInput | UserActionCreateOrConnectWithoutUserInput[]
    upsert?: UserActionUpsertWithWhereUniqueWithoutUserInput | UserActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserActionCreateManyUserInputEnvelope
    set?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    disconnect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    delete?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    update?: UserActionUpdateWithWhereUniqueWithoutUserInput | UserActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserActionUpdateManyWithWhereWithoutUserInput | UserActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutManagerNotesInput = {
    create?: XOR<UserCreateWithoutManagerNotesInput, UserUncheckedCreateWithoutManagerNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerNotesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesWrittenInput = {
    create?: XOR<UserCreateWithoutNotesWrittenInput, UserUncheckedCreateWithoutNotesWrittenInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesWrittenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutManagerNotesNestedInput = {
    create?: XOR<UserCreateWithoutManagerNotesInput, UserUncheckedCreateWithoutManagerNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagerNotesInput
    upsert?: UserUpsertWithoutManagerNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagerNotesInput, UserUpdateWithoutManagerNotesInput>, UserUncheckedUpdateWithoutManagerNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesWrittenNestedInput = {
    create?: XOR<UserCreateWithoutNotesWrittenInput, UserUncheckedCreateWithoutNotesWrittenInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesWrittenInput
    upsert?: UserUpsertWithoutNotesWrittenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesWrittenInput, UserUpdateWithoutNotesWrittenInput>, UserUncheckedUpdateWithoutNotesWrittenInput>
  }

  export type ModuleCreatetagsInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutModulesInput = {
    create?: XOR<OrganizationCreateWithoutModulesInput, OrganizationUncheckedCreateWithoutModulesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutModulesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ModulePrerequisiteCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutModuleInput, ModulePrerequisiteUncheckedCreateWithoutModuleInput> | ModulePrerequisiteCreateWithoutModuleInput[] | ModulePrerequisiteUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutModuleInput | ModulePrerequisiteCreateOrConnectWithoutModuleInput[]
    createMany?: ModulePrerequisiteCreateManyModuleInputEnvelope
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
  }

  export type ModulePrerequisiteCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ModulePrerequisiteCreateWithoutPrerequisiteInput[] | ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: ModulePrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
  }

  export type ModuleAssignmentCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ModuleProgressCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type ModulePrerequisiteUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutModuleInput, ModulePrerequisiteUncheckedCreateWithoutModuleInput> | ModulePrerequisiteCreateWithoutModuleInput[] | ModulePrerequisiteUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutModuleInput | ModulePrerequisiteCreateOrConnectWithoutModuleInput[]
    createMany?: ModulePrerequisiteCreateManyModuleInputEnvelope
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
  }

  export type ModulePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ModulePrerequisiteCreateWithoutPrerequisiteInput[] | ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: ModulePrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
  }

  export type ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
  }

  export type ModuleProgressUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
  }

  export type ModuleUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneWithoutModulesNestedInput = {
    create?: XOR<OrganizationCreateWithoutModulesInput, OrganizationUncheckedCreateWithoutModulesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutModulesInput
    upsert?: OrganizationUpsertWithoutModulesInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutModulesInput, OrganizationUpdateWithoutModulesInput>, OrganizationUncheckedUpdateWithoutModulesInput>
  }

  export type ModulePrerequisiteUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutModuleInput, ModulePrerequisiteUncheckedCreateWithoutModuleInput> | ModulePrerequisiteCreateWithoutModuleInput[] | ModulePrerequisiteUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutModuleInput | ModulePrerequisiteCreateOrConnectWithoutModuleInput[]
    upsert?: ModulePrerequisiteUpsertWithWhereUniqueWithoutModuleInput | ModulePrerequisiteUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModulePrerequisiteCreateManyModuleInputEnvelope
    set?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    disconnect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    delete?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    update?: ModulePrerequisiteUpdateWithWhereUniqueWithoutModuleInput | ModulePrerequisiteUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModulePrerequisiteUpdateManyWithWhereWithoutModuleInput | ModulePrerequisiteUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModulePrerequisiteScalarWhereInput | ModulePrerequisiteScalarWhereInput[]
  }

  export type ModulePrerequisiteUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ModulePrerequisiteCreateWithoutPrerequisiteInput[] | ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: ModulePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | ModulePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: ModulePrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    disconnect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    delete?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    update?: ModulePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | ModulePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: ModulePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | ModulePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: ModulePrerequisiteScalarWhereInput | ModulePrerequisiteScalarWhereInput[]
  }

  export type ModuleAssignmentUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutModuleInput | ModuleAssignmentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ModuleProgressUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutModuleInput | ModuleProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutModuleInput | ModuleProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutModuleInput | ModuleProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type ModulePrerequisiteUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutModuleInput, ModulePrerequisiteUncheckedCreateWithoutModuleInput> | ModulePrerequisiteCreateWithoutModuleInput[] | ModulePrerequisiteUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutModuleInput | ModulePrerequisiteCreateOrConnectWithoutModuleInput[]
    upsert?: ModulePrerequisiteUpsertWithWhereUniqueWithoutModuleInput | ModulePrerequisiteUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModulePrerequisiteCreateManyModuleInputEnvelope
    set?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    disconnect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    delete?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    update?: ModulePrerequisiteUpdateWithWhereUniqueWithoutModuleInput | ModulePrerequisiteUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModulePrerequisiteUpdateManyWithWhereWithoutModuleInput | ModulePrerequisiteUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModulePrerequisiteScalarWhereInput | ModulePrerequisiteScalarWhereInput[]
  }

  export type ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<ModulePrerequisiteCreateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ModulePrerequisiteCreateWithoutPrerequisiteInput[] | ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: ModulePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | ModulePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: ModulePrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    disconnect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    delete?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    connect?: ModulePrerequisiteWhereUniqueInput | ModulePrerequisiteWhereUniqueInput[]
    update?: ModulePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | ModulePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: ModulePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | ModulePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: ModulePrerequisiteScalarWhereInput | ModulePrerequisiteScalarWhereInput[]
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput> | ModuleAssignmentCreateWithoutModuleInput[] | ModuleAssignmentUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleAssignmentCreateOrConnectWithoutModuleInput | ModuleAssignmentCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleAssignmentCreateManyModuleInputEnvelope
    set?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    disconnect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    delete?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    connect?: ModuleAssignmentWhereUniqueInput | ModuleAssignmentWhereUniqueInput[]
    update?: ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput | ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleAssignmentUpdateManyWithWhereWithoutModuleInput | ModuleAssignmentUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
  }

  export type ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput> | ModuleProgressCreateWithoutModuleInput[] | ModuleProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleProgressCreateOrConnectWithoutModuleInput | ModuleProgressCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleProgressUpsertWithWhereUniqueWithoutModuleInput | ModuleProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleProgressCreateManyModuleInputEnvelope
    set?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    disconnect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    delete?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    connect?: ModuleProgressWhereUniqueInput | ModuleProgressWhereUniqueInput[]
    update?: ModuleProgressUpdateWithWhereUniqueWithoutModuleInput | ModuleProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleProgressUpdateManyWithWhereWithoutModuleInput | ModuleProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<ModuleCreateWithoutPrerequisitesInput, ModuleUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPrerequisitesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutUnlocksModulesInput = {
    create?: XOR<ModuleCreateWithoutUnlocksModulesInput, ModuleUncheckedCreateWithoutUnlocksModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutUnlocksModulesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<ModuleCreateWithoutPrerequisitesInput, ModuleUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutPrerequisitesInput
    upsert?: ModuleUpsertWithoutPrerequisitesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutPrerequisitesInput, ModuleUpdateWithoutPrerequisitesInput>, ModuleUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type ModuleUpdateOneRequiredWithoutUnlocksModulesNestedInput = {
    create?: XOR<ModuleCreateWithoutUnlocksModulesInput, ModuleUncheckedCreateWithoutUnlocksModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutUnlocksModulesInput
    upsert?: ModuleUpsertWithoutUnlocksModulesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutUnlocksModulesInput, ModuleUpdateWithoutUnlocksModulesInput>, ModuleUncheckedUpdateWithoutUnlocksModulesInput>
  }

  export type ModuleCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutAssignmentsInput
    connect?: ModuleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentsReceivedInput = {
    create?: XOR<UserCreateWithoutAssignmentsReceivedInput, UserUncheckedCreateWithoutAssignmentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignmentsMadeInput = {
    create?: XOR<UserCreateWithoutAssignmentsMadeInput, UserUncheckedCreateWithoutAssignmentsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutAssignmentsInput
    upsert?: ModuleUpsertWithoutAssignmentsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutAssignmentsInput, ModuleUpdateWithoutAssignmentsInput>, ModuleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentsReceivedInput, UserUncheckedCreateWithoutAssignmentsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsReceivedInput
    upsert?: UserUpsertWithoutAssignmentsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentsReceivedInput, UserUpdateWithoutAssignmentsReceivedInput>, UserUncheckedUpdateWithoutAssignmentsReceivedInput>
  }

  export type UserUpdateOneRequiredWithoutAssignmentsMadeNestedInput = {
    create?: XOR<UserCreateWithoutAssignmentsMadeInput, UserUncheckedCreateWithoutAssignmentsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignmentsMadeInput
    upsert?: UserUpsertWithoutAssignmentsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignmentsMadeInput, UserUpdateWithoutAssignmentsMadeInput>, UserUncheckedUpdateWithoutAssignmentsMadeInput>
  }

  export type ModuleProgressCreatecompletedSectionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutModuleProgressInput = {
    create?: XOR<UserCreateWithoutModuleProgressInput, UserUncheckedCreateWithoutModuleProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutModuleProgressInput
    connect?: UserWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutProgressInput = {
    create?: XOR<ModuleCreateWithoutProgressInput, ModuleUncheckedCreateWithoutProgressInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutProgressInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleProgressUpdatecompletedSectionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutModuleProgressNestedInput = {
    create?: XOR<UserCreateWithoutModuleProgressInput, UserUncheckedCreateWithoutModuleProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutModuleProgressInput
    upsert?: UserUpsertWithoutModuleProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModuleProgressInput, UserUpdateWithoutModuleProgressInput>, UserUncheckedUpdateWithoutModuleProgressInput>
  }

  export type ModuleUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<ModuleCreateWithoutProgressInput, ModuleUncheckedCreateWithoutProgressInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutProgressInput
    upsert?: ModuleUpsertWithoutProgressInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutProgressInput, ModuleUpdateWithoutProgressInput>, ModuleUncheckedUpdateWithoutProgressInput>
  }

  export type OrganizationCreateNestedOneWithoutAssessmentTemplatesInput = {
    create?: XOR<OrganizationCreateWithoutAssessmentTemplatesInput, OrganizationUncheckedCreateWithoutAssessmentTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAssessmentTemplatesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type AssessmentSessionCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AssessmentSessionCreateWithoutTemplateInput, AssessmentSessionUncheckedCreateWithoutTemplateInput> | AssessmentSessionCreateWithoutTemplateInput[] | AssessmentSessionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutTemplateInput | AssessmentSessionCreateOrConnectWithoutTemplateInput[]
    createMany?: AssessmentSessionCreateManyTemplateInputEnvelope
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
  }

  export type AssessmentSessionUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AssessmentSessionCreateWithoutTemplateInput, AssessmentSessionUncheckedCreateWithoutTemplateInput> | AssessmentSessionCreateWithoutTemplateInput[] | AssessmentSessionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutTemplateInput | AssessmentSessionCreateOrConnectWithoutTemplateInput[]
    createMany?: AssessmentSessionCreateManyTemplateInputEnvelope
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
  }

  export type OrganizationUpdateOneWithoutAssessmentTemplatesNestedInput = {
    create?: XOR<OrganizationCreateWithoutAssessmentTemplatesInput, OrganizationUncheckedCreateWithoutAssessmentTemplatesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAssessmentTemplatesInput
    upsert?: OrganizationUpsertWithoutAssessmentTemplatesInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAssessmentTemplatesInput, OrganizationUpdateWithoutAssessmentTemplatesInput>, OrganizationUncheckedUpdateWithoutAssessmentTemplatesInput>
  }

  export type AssessmentSessionUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AssessmentSessionCreateWithoutTemplateInput, AssessmentSessionUncheckedCreateWithoutTemplateInput> | AssessmentSessionCreateWithoutTemplateInput[] | AssessmentSessionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutTemplateInput | AssessmentSessionCreateOrConnectWithoutTemplateInput[]
    upsert?: AssessmentSessionUpsertWithWhereUniqueWithoutTemplateInput | AssessmentSessionUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AssessmentSessionCreateManyTemplateInputEnvelope
    set?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    disconnect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    delete?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    update?: AssessmentSessionUpdateWithWhereUniqueWithoutTemplateInput | AssessmentSessionUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AssessmentSessionUpdateManyWithWhereWithoutTemplateInput | AssessmentSessionUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AssessmentSessionScalarWhereInput | AssessmentSessionScalarWhereInput[]
  }

  export type AssessmentSessionUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AssessmentSessionCreateWithoutTemplateInput, AssessmentSessionUncheckedCreateWithoutTemplateInput> | AssessmentSessionCreateWithoutTemplateInput[] | AssessmentSessionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AssessmentSessionCreateOrConnectWithoutTemplateInput | AssessmentSessionCreateOrConnectWithoutTemplateInput[]
    upsert?: AssessmentSessionUpsertWithWhereUniqueWithoutTemplateInput | AssessmentSessionUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AssessmentSessionCreateManyTemplateInputEnvelope
    set?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    disconnect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    delete?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    connect?: AssessmentSessionWhereUniqueInput | AssessmentSessionWhereUniqueInput[]
    update?: AssessmentSessionUpdateWithWhereUniqueWithoutTemplateInput | AssessmentSessionUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AssessmentSessionUpdateManyWithWhereWithoutTemplateInput | AssessmentSessionUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AssessmentSessionScalarWhereInput | AssessmentSessionScalarWhereInput[]
  }

  export type AssessmentTemplateCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AssessmentTemplateCreateWithoutSessionsInput, AssessmentTemplateUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AssessmentTemplateCreateOrConnectWithoutSessionsInput
    connect?: AssessmentTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssessmentSessionsInput = {
    create?: XOR<UserCreateWithoutAssessmentSessionsInput, UserUncheckedCreateWithoutAssessmentSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssessmentSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type AssessmentTemplateUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AssessmentTemplateCreateWithoutSessionsInput, AssessmentTemplateUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AssessmentTemplateCreateOrConnectWithoutSessionsInput
    upsert?: AssessmentTemplateUpsertWithoutSessionsInput
    connect?: AssessmentTemplateWhereUniqueInput
    update?: XOR<XOR<AssessmentTemplateUpdateToOneWithWhereWithoutSessionsInput, AssessmentTemplateUpdateWithoutSessionsInput>, AssessmentTemplateUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateOneWithoutAssessmentSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAssessmentSessionsInput, UserUncheckedCreateWithoutAssessmentSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssessmentSessionsInput
    upsert?: UserUpsertWithoutAssessmentSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssessmentSessionsInput, UserUpdateWithoutAssessmentSessionsInput>, UserUncheckedUpdateWithoutAssessmentSessionsInput>
  }

  export type UserCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificationsInput
    upsert?: UserUpsertWithoutCertificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificationsInput, UserUpdateWithoutCertificationsInput>, UserUncheckedUpdateWithoutCertificationsInput>
  }

  export type UserCreateNestedOneWithoutRoadmapsInput = {
    create?: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapsInput
    connect?: UserWhereUniqueInput
  }

  export type UserActionCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<UserActionCreateWithoutRoadmapInput, UserActionUncheckedCreateWithoutRoadmapInput> | UserActionCreateWithoutRoadmapInput[] | UserActionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutRoadmapInput | UserActionCreateOrConnectWithoutRoadmapInput[]
    createMany?: UserActionCreateManyRoadmapInputEnvelope
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
  }

  export type UserActionUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<UserActionCreateWithoutRoadmapInput, UserActionUncheckedCreateWithoutRoadmapInput> | UserActionCreateWithoutRoadmapInput[] | UserActionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutRoadmapInput | UserActionCreateOrConnectWithoutRoadmapInput[]
    createMany?: UserActionCreateManyRoadmapInputEnvelope
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutRoadmapsNestedInput = {
    create?: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapsInput
    upsert?: UserUpsertWithoutRoadmapsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoadmapsInput, UserUpdateWithoutRoadmapsInput>, UserUncheckedUpdateWithoutRoadmapsInput>
  }

  export type UserActionUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<UserActionCreateWithoutRoadmapInput, UserActionUncheckedCreateWithoutRoadmapInput> | UserActionCreateWithoutRoadmapInput[] | UserActionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutRoadmapInput | UserActionCreateOrConnectWithoutRoadmapInput[]
    upsert?: UserActionUpsertWithWhereUniqueWithoutRoadmapInput | UserActionUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: UserActionCreateManyRoadmapInputEnvelope
    set?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    disconnect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    delete?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    update?: UserActionUpdateWithWhereUniqueWithoutRoadmapInput | UserActionUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: UserActionUpdateManyWithWhereWithoutRoadmapInput | UserActionUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
  }

  export type UserActionUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<UserActionCreateWithoutRoadmapInput, UserActionUncheckedCreateWithoutRoadmapInput> | UserActionCreateWithoutRoadmapInput[] | UserActionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutRoadmapInput | UserActionCreateOrConnectWithoutRoadmapInput[]
    upsert?: UserActionUpsertWithWhereUniqueWithoutRoadmapInput | UserActionUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: UserActionCreateManyRoadmapInputEnvelope
    set?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    disconnect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    delete?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    update?: UserActionUpdateWithWhereUniqueWithoutRoadmapInput | UserActionUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: UserActionUpdateManyWithWhereWithoutRoadmapInput | UserActionUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
  }

  export type ActionCreatetemplateIdsInput = {
    set: string[]
  }

  export type ActionCreatedependsOnActionsInput = {
    set: string[]
  }

  export type UserActionCreateNestedManyWithoutActionInput = {
    create?: XOR<UserActionCreateWithoutActionInput, UserActionUncheckedCreateWithoutActionInput> | UserActionCreateWithoutActionInput[] | UserActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutActionInput | UserActionCreateOrConnectWithoutActionInput[]
    createMany?: UserActionCreateManyActionInputEnvelope
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
  }

  export type UserActionUncheckedCreateNestedManyWithoutActionInput = {
    create?: XOR<UserActionCreateWithoutActionInput, UserActionUncheckedCreateWithoutActionInput> | UserActionCreateWithoutActionInput[] | UserActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutActionInput | UserActionCreateOrConnectWithoutActionInput[]
    createMany?: UserActionCreateManyActionInputEnvelope
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
  }

  export type ActionUpdatetemplateIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ActionUpdatedependsOnActionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserActionUpdateManyWithoutActionNestedInput = {
    create?: XOR<UserActionCreateWithoutActionInput, UserActionUncheckedCreateWithoutActionInput> | UserActionCreateWithoutActionInput[] | UserActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutActionInput | UserActionCreateOrConnectWithoutActionInput[]
    upsert?: UserActionUpsertWithWhereUniqueWithoutActionInput | UserActionUpsertWithWhereUniqueWithoutActionInput[]
    createMany?: UserActionCreateManyActionInputEnvelope
    set?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    disconnect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    delete?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    update?: UserActionUpdateWithWhereUniqueWithoutActionInput | UserActionUpdateWithWhereUniqueWithoutActionInput[]
    updateMany?: UserActionUpdateManyWithWhereWithoutActionInput | UserActionUpdateManyWithWhereWithoutActionInput[]
    deleteMany?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
  }

  export type UserActionUncheckedUpdateManyWithoutActionNestedInput = {
    create?: XOR<UserActionCreateWithoutActionInput, UserActionUncheckedCreateWithoutActionInput> | UserActionCreateWithoutActionInput[] | UserActionUncheckedCreateWithoutActionInput[]
    connectOrCreate?: UserActionCreateOrConnectWithoutActionInput | UserActionCreateOrConnectWithoutActionInput[]
    upsert?: UserActionUpsertWithWhereUniqueWithoutActionInput | UserActionUpsertWithWhereUniqueWithoutActionInput[]
    createMany?: UserActionCreateManyActionInputEnvelope
    set?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    disconnect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    delete?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    connect?: UserActionWhereUniqueInput | UserActionWhereUniqueInput[]
    update?: UserActionUpdateWithWhereUniqueWithoutActionInput | UserActionUpdateWithWhereUniqueWithoutActionInput[]
    updateMany?: UserActionUpdateManyWithWhereWithoutActionInput | UserActionUpdateManyWithWhereWithoutActionInput[]
    deleteMany?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserActionsInput = {
    create?: XOR<UserCreateWithoutUserActionsInput, UserUncheckedCreateWithoutUserActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserActionsInput
    connect?: UserWhereUniqueInput
  }

  export type RoadmapCreateNestedOneWithoutUserActionsInput = {
    create?: XOR<RoadmapCreateWithoutUserActionsInput, RoadmapUncheckedCreateWithoutUserActionsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutUserActionsInput
    connect?: RoadmapWhereUniqueInput
  }

  export type ActionCreateNestedOneWithoutUserActionsInput = {
    create?: XOR<ActionCreateWithoutUserActionsInput, ActionUncheckedCreateWithoutUserActionsInput>
    connectOrCreate?: ActionCreateOrConnectWithoutUserActionsInput
    connect?: ActionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserActionsNestedInput = {
    create?: XOR<UserCreateWithoutUserActionsInput, UserUncheckedCreateWithoutUserActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserActionsInput
    upsert?: UserUpsertWithoutUserActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserActionsInput, UserUpdateWithoutUserActionsInput>, UserUncheckedUpdateWithoutUserActionsInput>
  }

  export type RoadmapUpdateOneRequiredWithoutUserActionsNestedInput = {
    create?: XOR<RoadmapCreateWithoutUserActionsInput, RoadmapUncheckedCreateWithoutUserActionsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutUserActionsInput
    upsert?: RoadmapUpsertWithoutUserActionsInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutUserActionsInput, RoadmapUpdateWithoutUserActionsInput>, RoadmapUncheckedUpdateWithoutUserActionsInput>
  }

  export type ActionUpdateOneRequiredWithoutUserActionsNestedInput = {
    create?: XOR<ActionCreateWithoutUserActionsInput, ActionUncheckedCreateWithoutUserActionsInput>
    connectOrCreate?: ActionCreateOrConnectWithoutUserActionsInput
    upsert?: ActionUpsertWithoutUserActionsInput
    connect?: ActionWhereUniqueInput
    update?: XOR<XOR<ActionUpdateToOneWithWhereWithoutUserActionsInput, ActionUpdateWithoutUserActionsInput>, ActionUncheckedUpdateWithoutUserActionsInput>
  }

  export type TemplateCreaterelatedActionCodesInput = {
    set: string[]
  }

  export type TemplateUpdaterelatedActionCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AlertCreateWithoutRuleInput = {
    id?: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutAlertInput
  }

  export type AlertUncheckedCreateWithoutRuleInput = {
    id?: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutAlertInput
  }

  export type AlertCreateOrConnectWithoutRuleInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutRuleInput, AlertUncheckedCreateWithoutRuleInput>
  }

  export type AlertCreateManyRuleInputEnvelope = {
    data: AlertCreateManyRuleInput | AlertCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type AlertUpsertWithWhereUniqueWithoutRuleInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutRuleInput, AlertUncheckedUpdateWithoutRuleInput>
    create: XOR<AlertCreateWithoutRuleInput, AlertUncheckedCreateWithoutRuleInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutRuleInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutRuleInput, AlertUncheckedUpdateWithoutRuleInput>
  }

  export type AlertUpdateManyWithWhereWithoutRuleInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutRuleInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    ruleId?: StringFilter<"Alert"> | string
    severity?: StringFilter<"Alert"> | string
    title?: StringFilter<"Alert"> | string
    description?: StringNullableFilter<"Alert"> | string | null
    affectedUserId?: StringNullableFilter<"Alert"> | string | null
    affectedEntityType?: StringNullableFilter<"Alert"> | string | null
    affectedEntityId?: StringNullableFilter<"Alert"> | string | null
    triggerMetric?: StringFilter<"Alert"> | string
    triggerValue?: FloatFilter<"Alert"> | number
    triggerThreshold?: FloatFilter<"Alert"> | number
    recommendedActions?: StringNullableListFilter<"Alert">
    status?: StringFilter<"Alert"> | string
    acknowledgedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Alert"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type AlertRuleCreateWithoutAlertsInput = {
    id?: string
    name: string
    description?: string | null
    metric: string
    operator: string
    threshold: number
    duration?: number | null
    targetType?: string
    targetId?: string | null
    severity?: string
    notifyChannels?: AlertRuleCreatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleCreatenotifyRolesInput | string[]
    cooldownMinutes?: number
    lastTriggeredAt?: Date | string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertRuleUncheckedCreateWithoutAlertsInput = {
    id?: string
    name: string
    description?: string | null
    metric: string
    operator: string
    threshold: number
    duration?: number | null
    targetType?: string
    targetId?: string | null
    severity?: string
    notifyChannels?: AlertRuleCreatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleCreatenotifyRolesInput | string[]
    cooldownMinutes?: number
    lastTriggeredAt?: Date | string | null
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertRuleCreateOrConnectWithoutAlertsInput = {
    where: AlertRuleWhereUniqueInput
    create: XOR<AlertRuleCreateWithoutAlertsInput, AlertRuleUncheckedCreateWithoutAlertsInput>
  }

  export type NotificationCreateWithoutAlertInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    readAt?: Date | string | null
    emailSent?: boolean
    emailSentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutAlertInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    readAt?: Date | string | null
    emailSent?: boolean
    emailSentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAlertInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput>
  }

  export type NotificationCreateManyAlertInputEnvelope = {
    data: NotificationCreateManyAlertInput | NotificationCreateManyAlertInput[]
    skipDuplicates?: boolean
  }

  export type AlertRuleUpsertWithoutAlertsInput = {
    update: XOR<AlertRuleUpdateWithoutAlertsInput, AlertRuleUncheckedUpdateWithoutAlertsInput>
    create: XOR<AlertRuleCreateWithoutAlertsInput, AlertRuleUncheckedCreateWithoutAlertsInput>
    where?: AlertRuleWhereInput
  }

  export type AlertRuleUpdateToOneWithWhereWithoutAlertsInput = {
    where?: AlertRuleWhereInput
    data: XOR<AlertRuleUpdateWithoutAlertsInput, AlertRuleUncheckedUpdateWithoutAlertsInput>
  }

  export type AlertRuleUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metric?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    notifyChannels?: AlertRuleUpdatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleUpdatenotifyRolesInput | string[]
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertRuleUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metric?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: StringFieldUpdateOperationsInput | string
    notifyChannels?: AlertRuleUpdatenotifyChannelsInput | string[]
    notifyRoles?: AlertRuleUpdatenotifyRolesInput | string[]
    cooldownMinutes?: IntFieldUpdateOperationsInput | number
    lastTriggeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutAlertInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAlertInput, NotificationUncheckedUpdateWithoutAlertInput>
    create: XOR<NotificationCreateWithoutAlertInput, NotificationUncheckedCreateWithoutAlertInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAlertInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAlertInput, NotificationUncheckedUpdateWithoutAlertInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAlertInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAlertInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    icon?: StringNullableFilter<"Notification"> | string | null
    alertId?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    emailSent?: BoolFilter<"Notification"> | boolean
    emailSentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AlertCreateWithoutNotificationsInput = {
    id?: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rule: AlertRuleCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutNotificationsInput = {
    id?: string
    ruleId: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutNotificationsInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
  }

  export type AlertUpsertWithoutNotificationsInput = {
    update: XOR<AlertUpdateWithoutNotificationsInput, AlertUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AlertCreateWithoutNotificationsInput, AlertUncheckedCreateWithoutNotificationsInput>
    where?: AlertWhereInput
  }

  export type AlertUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AlertWhereInput
    data: XOR<AlertUpdateWithoutNotificationsInput, AlertUncheckedUpdateWithoutNotificationsInput>
  }

  export type AlertUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: AlertRuleUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ruleId?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportCreateWithoutTemplateInput = {
    id?: string
    name: string
    type: string
    format: string
    periodStart: Date | string
    periodEnd: Date | string
    requestedBy?: string | null
    generatedAt?: Date | string
    filePath?: string | null
    fileSize?: number | null
    mimeType?: string | null
    status?: string
    errorMessage?: string | null
    emailed?: boolean
    emailedAt?: Date | string | null
    downloadCount?: number
    createdAt?: Date | string
  }

  export type GeneratedReportUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    type: string
    format: string
    periodStart: Date | string
    periodEnd: Date | string
    requestedBy?: string | null
    generatedAt?: Date | string
    filePath?: string | null
    fileSize?: number | null
    mimeType?: string | null
    status?: string
    errorMessage?: string | null
    emailed?: boolean
    emailedAt?: Date | string | null
    downloadCount?: number
    createdAt?: Date | string
  }

  export type GeneratedReportCreateOrConnectWithoutTemplateInput = {
    where: GeneratedReportWhereUniqueInput
    create: XOR<GeneratedReportCreateWithoutTemplateInput, GeneratedReportUncheckedCreateWithoutTemplateInput>
  }

  export type GeneratedReportCreateManyTemplateInputEnvelope = {
    data: GeneratedReportCreateManyTemplateInput | GeneratedReportCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedReportUpsertWithWhereUniqueWithoutTemplateInput = {
    where: GeneratedReportWhereUniqueInput
    update: XOR<GeneratedReportUpdateWithoutTemplateInput, GeneratedReportUncheckedUpdateWithoutTemplateInput>
    create: XOR<GeneratedReportCreateWithoutTemplateInput, GeneratedReportUncheckedCreateWithoutTemplateInput>
  }

  export type GeneratedReportUpdateWithWhereUniqueWithoutTemplateInput = {
    where: GeneratedReportWhereUniqueInput
    data: XOR<GeneratedReportUpdateWithoutTemplateInput, GeneratedReportUncheckedUpdateWithoutTemplateInput>
  }

  export type GeneratedReportUpdateManyWithWhereWithoutTemplateInput = {
    where: GeneratedReportScalarWhereInput
    data: XOR<GeneratedReportUpdateManyMutationInput, GeneratedReportUncheckedUpdateManyWithoutTemplateInput>
  }

  export type GeneratedReportScalarWhereInput = {
    AND?: GeneratedReportScalarWhereInput | GeneratedReportScalarWhereInput[]
    OR?: GeneratedReportScalarWhereInput[]
    NOT?: GeneratedReportScalarWhereInput | GeneratedReportScalarWhereInput[]
    id?: StringFilter<"GeneratedReport"> | string
    templateId?: StringNullableFilter<"GeneratedReport"> | string | null
    name?: StringFilter<"GeneratedReport"> | string
    type?: StringFilter<"GeneratedReport"> | string
    format?: StringFilter<"GeneratedReport"> | string
    periodStart?: DateTimeFilter<"GeneratedReport"> | Date | string
    periodEnd?: DateTimeFilter<"GeneratedReport"> | Date | string
    requestedBy?: StringNullableFilter<"GeneratedReport"> | string | null
    generatedAt?: DateTimeFilter<"GeneratedReport"> | Date | string
    filePath?: StringNullableFilter<"GeneratedReport"> | string | null
    fileSize?: IntNullableFilter<"GeneratedReport"> | number | null
    mimeType?: StringNullableFilter<"GeneratedReport"> | string | null
    status?: StringFilter<"GeneratedReport"> | string
    errorMessage?: StringNullableFilter<"GeneratedReport"> | string | null
    emailed?: BoolFilter<"GeneratedReport"> | boolean
    emailedAt?: DateTimeNullableFilter<"GeneratedReport"> | Date | string | null
    downloadCount?: IntFilter<"GeneratedReport"> | number
    createdAt?: DateTimeFilter<"GeneratedReport"> | Date | string
  }

  export type ReportTemplateCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    format?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: boolean
    scheduleCron?: string | null
    recipients?: ReportTemplateCreaterecipientsInput | string[]
    isSystem?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    type: string
    format?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: boolean
    scheduleCron?: string | null
    recipients?: ReportTemplateCreaterecipientsInput | string[]
    isSystem?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateCreateOrConnectWithoutReportsInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
  }

  export type ReportTemplateUpsertWithoutReportsInput = {
    update: XOR<ReportTemplateUpdateWithoutReportsInput, ReportTemplateUncheckedUpdateWithoutReportsInput>
    create: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutReportsInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutReportsInput, ReportTemplateUncheckedUpdateWithoutReportsInput>
  }

  export type ReportTemplateUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    scheduleCron?: NullableStringFieldUpdateOperationsInput | string | null
    recipients?: ReportTemplateUpdaterecipientsInput | string[]
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    scheduleEnabled?: BoolFieldUpdateOperationsInput | boolean
    scheduleCron?: NullableStringFieldUpdateOperationsInput | string | null
    recipients?: ReportTemplateUpdaterecipientsInput | string[]
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
    members?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutOrganizationInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput>
  }

  export type DepartmentCreateManyOrganizationInputEnvelope = {
    data: DepartmentCreateManyOrganizationInput | DepartmentCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisites?: ModulePrerequisiteCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisites?: ModulePrerequisiteUncheckedCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutOrganizationInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutOrganizationInput, ModuleUncheckedCreateWithoutOrganizationInput>
  }

  export type ModuleCreateManyOrganizationInputEnvelope = {
    data: ModuleCreateManyOrganizationInput | ModuleCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentTemplateCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AssessmentSessionCreateNestedManyWithoutTemplateInput
  }

  export type AssessmentTemplateUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: AssessmentSessionUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type AssessmentTemplateCreateOrConnectWithoutOrganizationInput = {
    where: AssessmentTemplateWhereUniqueInput
    create: XOR<AssessmentTemplateCreateWithoutOrganizationInput, AssessmentTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type AssessmentTemplateCreateManyOrganizationInputEnvelope = {
    data: AssessmentTemplateCreateManyOrganizationInput | AssessmentTemplateCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutOrganizationInput, DepartmentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DepartmentCreateWithoutOrganizationInput, DepartmentUncheckedCreateWithoutOrganizationInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutOrganizationInput, DepartmentUncheckedUpdateWithoutOrganizationInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutOrganizationInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    organizationId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    organizationId?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    status?: StringFilter<"User"> | string
    position?: StringNullableFilter<"User"> | string | null
    companyName?: StringNullableFilter<"User"> | string | null
    companySize?: StringNullableFilter<"User"> | string | null
    industrySector?: StringNullableFilter<"User"> | string | null
    targetStandard?: StringNullableFilter<"User"> | string | null
    subscriptionStatus?: StringFilter<"User"> | string
    subscriptionStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"User"> | string | null
    onboardingCompletedSteps?: StringNullableListFilter<"User">
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    invitedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    invitedBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutOrganizationInput, ModuleUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ModuleCreateWithoutOrganizationInput, ModuleUncheckedCreateWithoutOrganizationInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutOrganizationInput, ModuleUncheckedUpdateWithoutOrganizationInput>
  }

  export type ModuleUpdateManyWithWhereWithoutOrganizationInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    organizationId?: StringNullableFilter<"Module"> | string | null
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    coverImage?: StringNullableFilter<"Module"> | string | null
    category?: StringFilter<"Module"> | string
    tags?: StringNullableListFilter<"Module">
    difficulty?: StringFilter<"Module"> | string
    estimatedDuration?: IntFilter<"Module"> | number
    sections?: JsonNullableFilter<"Module">
    xpReward?: IntFilter<"Module"> | number
    badge?: StringNullableFilter<"Module"> | string | null
    status?: StringFilter<"Module"> | string
    publishedAt?: DateTimeNullableFilter<"Module"> | Date | string | null
    completionCount?: IntFilter<"Module"> | number
    avgScore?: FloatFilter<"Module"> | number
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type AssessmentTemplateUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AssessmentTemplateWhereUniqueInput
    update: XOR<AssessmentTemplateUpdateWithoutOrganizationInput, AssessmentTemplateUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AssessmentTemplateCreateWithoutOrganizationInput, AssessmentTemplateUncheckedCreateWithoutOrganizationInput>
  }

  export type AssessmentTemplateUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AssessmentTemplateWhereUniqueInput
    data: XOR<AssessmentTemplateUpdateWithoutOrganizationInput, AssessmentTemplateUncheckedUpdateWithoutOrganizationInput>
  }

  export type AssessmentTemplateUpdateManyWithWhereWithoutOrganizationInput = {
    where: AssessmentTemplateScalarWhereInput
    data: XOR<AssessmentTemplateUpdateManyMutationInput, AssessmentTemplateUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AssessmentTemplateScalarWhereInput = {
    AND?: AssessmentTemplateScalarWhereInput | AssessmentTemplateScalarWhereInput[]
    OR?: AssessmentTemplateScalarWhereInput[]
    NOT?: AssessmentTemplateScalarWhereInput | AssessmentTemplateScalarWhereInput[]
    id?: StringFilter<"AssessmentTemplate"> | string
    organizationId?: StringNullableFilter<"AssessmentTemplate"> | string | null
    name?: StringFilter<"AssessmentTemplate"> | string
    description?: StringNullableFilter<"AssessmentTemplate"> | string | null
    certification?: StringFilter<"AssessmentTemplate"> | string
    version?: StringFilter<"AssessmentTemplate"> | string
    estimatedDuration?: IntFilter<"AssessmentTemplate"> | number
    sections?: JsonFilter<"AssessmentTemplate">
    scoringMethod?: StringFilter<"AssessmentTemplate"> | string
    maturityLevels?: JsonFilter<"AssessmentTemplate">
    status?: StringFilter<"AssessmentTemplate"> | string
    isDemo?: BoolFilter<"AssessmentTemplate"> | boolean
    createdAt?: DateTimeFilter<"AssessmentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AssessmentTemplate"> | Date | string
  }

  export type OrganizationCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    modules?: ModuleCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    modules?: ModuleUncheckedCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutDepartmentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
  }

  export type UserCreateWithoutManagedDepartmentsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagedDepartmentsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagedDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
  }

  export type UserCreateWithoutDepartmentInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutDepartmentsInput = {
    update: XOR<OrganizationUpdateWithoutDepartmentsInput, OrganizationUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDepartmentsInput, OrganizationUncheckedUpdateWithoutDepartmentsInput>
  }

  export type OrganizationUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutManagedDepartmentsInput = {
    update: XOR<UserUpdateWithoutManagedDepartmentsInput, UserUncheckedUpdateWithoutManagedDepartmentsInput>
    create: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedDepartmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedDepartmentsInput, UserUncheckedUpdateWithoutManagedDepartmentsInput>
  }

  export type UserUpdateWithoutManagedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    modules?: ModuleCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    modules?: ModuleUncheckedCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type DepartmentCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutMembersInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutMembersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
  }

  export type ManagerNoteCreateWithoutAboutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    byUser: UserCreateNestedOneWithoutNotesWrittenInput
  }

  export type ManagerNoteUncheckedCreateWithoutAboutUserInput = {
    id?: string
    byUserId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerNoteCreateOrConnectWithoutAboutUserInput = {
    where: ManagerNoteWhereUniqueInput
    create: XOR<ManagerNoteCreateWithoutAboutUserInput, ManagerNoteUncheckedCreateWithoutAboutUserInput>
  }

  export type ManagerNoteCreateManyAboutUserInputEnvelope = {
    data: ManagerNoteCreateManyAboutUserInput | ManagerNoteCreateManyAboutUserInput[]
    skipDuplicates?: boolean
  }

  export type ManagerNoteCreateWithoutByUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    aboutUser: UserCreateNestedOneWithoutManagerNotesInput
  }

  export type ManagerNoteUncheckedCreateWithoutByUserInput = {
    id?: string
    aboutUserId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerNoteCreateOrConnectWithoutByUserInput = {
    where: ManagerNoteWhereUniqueInput
    create: XOR<ManagerNoteCreateWithoutByUserInput, ManagerNoteUncheckedCreateWithoutByUserInput>
  }

  export type ManagerNoteCreateManyByUserInputEnvelope = {
    data: ManagerNoteCreateManyByUserInput | ManagerNoteCreateManyByUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutManagerInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutDepartmentsInput
    members?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutManagerInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput>
  }

  export type DepartmentCreateManyManagerInputEnvelope = {
    data: DepartmentCreateManyManagerInput | DepartmentCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type ModuleAssignmentCreateWithoutAssignedToInput = {
    id?: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    module: ModuleCreateNestedOneWithoutAssignmentsInput
    assignedBy: UserCreateNestedOneWithoutAssignmentsMadeInput
  }

  export type ModuleAssignmentUncheckedCreateWithoutAssignedToInput = {
    id?: string
    moduleId: string
    assignedById: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleAssignmentCreateOrConnectWithoutAssignedToInput = {
    where: ModuleAssignmentWhereUniqueInput
    create: XOR<ModuleAssignmentCreateWithoutAssignedToInput, ModuleAssignmentUncheckedCreateWithoutAssignedToInput>
  }

  export type ModuleAssignmentCreateManyAssignedToInputEnvelope = {
    data: ModuleAssignmentCreateManyAssignedToInput | ModuleAssignmentCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type ModuleAssignmentCreateWithoutAssignedByInput = {
    id?: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    module: ModuleCreateNestedOneWithoutAssignmentsInput
    assignedTo: UserCreateNestedOneWithoutAssignmentsReceivedInput
  }

  export type ModuleAssignmentUncheckedCreateWithoutAssignedByInput = {
    id?: string
    moduleId: string
    assignedToId: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleAssignmentCreateOrConnectWithoutAssignedByInput = {
    where: ModuleAssignmentWhereUniqueInput
    create: XOR<ModuleAssignmentCreateWithoutAssignedByInput, ModuleAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type ModuleAssignmentCreateManyAssignedByInputEnvelope = {
    data: ModuleAssignmentCreateManyAssignedByInput | ModuleAssignmentCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type ModuleProgressCreateWithoutUserInput = {
    id?: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutProgressInput
  }

  export type ModuleProgressUncheckedCreateWithoutUserInput = {
    id?: string
    moduleId: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleProgressCreateOrConnectWithoutUserInput = {
    where: ModuleProgressWhereUniqueInput
    create: XOR<ModuleProgressCreateWithoutUserInput, ModuleProgressUncheckedCreateWithoutUserInput>
  }

  export type ModuleProgressCreateManyUserInputEnvelope = {
    data: ModuleProgressCreateManyUserInput | ModuleProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AssessmentSessionCreateWithoutUserInput = {
    id?: string
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
    template: AssessmentTemplateCreateNestedOneWithoutSessionsInput
  }

  export type AssessmentSessionUncheckedCreateWithoutUserInput = {
    id?: string
    templateId: string
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
  }

  export type AssessmentSessionCreateOrConnectWithoutUserInput = {
    where: AssessmentSessionWhereUniqueInput
    create: XOR<AssessmentSessionCreateWithoutUserInput, AssessmentSessionUncheckedCreateWithoutUserInput>
  }

  export type AssessmentSessionCreateManyUserInputEnvelope = {
    data: AssessmentSessionCreateManyUserInput | AssessmentSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCertificationCreateWithoutUserInput = {
    id?: string
    name: string
    certification: string
    level?: string | null
    issuedAt: Date | string
    expiresAt?: Date | string | null
    status?: string
    certificateUrl?: string | null
    verificationCode?: string | null
    createdAt?: Date | string
  }

  export type UserCertificationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    certification: string
    level?: string | null
    issuedAt: Date | string
    expiresAt?: Date | string | null
    status?: string
    certificateUrl?: string | null
    verificationCode?: string | null
    createdAt?: Date | string
  }

  export type UserCertificationCreateOrConnectWithoutUserInput = {
    where: UserCertificationWhereUniqueInput
    create: XOR<UserCertificationCreateWithoutUserInput, UserCertificationUncheckedCreateWithoutUserInput>
  }

  export type UserCertificationCreateManyUserInputEnvelope = {
    data: UserCertificationCreateManyUserInput | UserCertificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapCreateWithoutUserInput = {
    id?: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userActions?: UserActionCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutUserInput = {
    id?: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userActions?: UserActionUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutUserInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutUserInput, RoadmapUncheckedCreateWithoutUserInput>
  }

  export type RoadmapCreateManyUserInputEnvelope = {
    data: RoadmapCreateManyUserInput | RoadmapCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserActionCreateWithoutUserInput = {
    id?: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutUserActionsInput
    action: ActionCreateNestedOneWithoutUserActionsInput
  }

  export type UserActionUncheckedCreateWithoutUserInput = {
    id?: string
    roadmapId: string
    actionId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionCreateOrConnectWithoutUserInput = {
    where: UserActionWhereUniqueInput
    create: XOR<UserActionCreateWithoutUserInput, UserActionUncheckedCreateWithoutUserInput>
  }

  export type UserActionCreateManyUserInputEnvelope = {
    data: UserActionCreateManyUserInput | UserActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DepartmentUpsertWithoutMembersInput = {
    update: XOR<DepartmentUpdateWithoutMembersInput, DepartmentUncheckedUpdateWithoutMembersInput>
    create: XOR<DepartmentCreateWithoutMembersInput, DepartmentUncheckedCreateWithoutMembersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutMembersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutMembersInput, DepartmentUncheckedUpdateWithoutMembersInput>
  }

  export type DepartmentUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteUpsertWithWhereUniqueWithoutAboutUserInput = {
    where: ManagerNoteWhereUniqueInput
    update: XOR<ManagerNoteUpdateWithoutAboutUserInput, ManagerNoteUncheckedUpdateWithoutAboutUserInput>
    create: XOR<ManagerNoteCreateWithoutAboutUserInput, ManagerNoteUncheckedCreateWithoutAboutUserInput>
  }

  export type ManagerNoteUpdateWithWhereUniqueWithoutAboutUserInput = {
    where: ManagerNoteWhereUniqueInput
    data: XOR<ManagerNoteUpdateWithoutAboutUserInput, ManagerNoteUncheckedUpdateWithoutAboutUserInput>
  }

  export type ManagerNoteUpdateManyWithWhereWithoutAboutUserInput = {
    where: ManagerNoteScalarWhereInput
    data: XOR<ManagerNoteUpdateManyMutationInput, ManagerNoteUncheckedUpdateManyWithoutAboutUserInput>
  }

  export type ManagerNoteScalarWhereInput = {
    AND?: ManagerNoteScalarWhereInput | ManagerNoteScalarWhereInput[]
    OR?: ManagerNoteScalarWhereInput[]
    NOT?: ManagerNoteScalarWhereInput | ManagerNoteScalarWhereInput[]
    id?: StringFilter<"ManagerNote"> | string
    aboutUserId?: StringFilter<"ManagerNote"> | string
    byUserId?: StringFilter<"ManagerNote"> | string
    content?: StringFilter<"ManagerNote"> | string
    createdAt?: DateTimeFilter<"ManagerNote"> | Date | string
    updatedAt?: DateTimeFilter<"ManagerNote"> | Date | string
  }

  export type ManagerNoteUpsertWithWhereUniqueWithoutByUserInput = {
    where: ManagerNoteWhereUniqueInput
    update: XOR<ManagerNoteUpdateWithoutByUserInput, ManagerNoteUncheckedUpdateWithoutByUserInput>
    create: XOR<ManagerNoteCreateWithoutByUserInput, ManagerNoteUncheckedCreateWithoutByUserInput>
  }

  export type ManagerNoteUpdateWithWhereUniqueWithoutByUserInput = {
    where: ManagerNoteWhereUniqueInput
    data: XOR<ManagerNoteUpdateWithoutByUserInput, ManagerNoteUncheckedUpdateWithoutByUserInput>
  }

  export type ManagerNoteUpdateManyWithWhereWithoutByUserInput = {
    where: ManagerNoteScalarWhereInput
    data: XOR<ManagerNoteUpdateManyMutationInput, ManagerNoteUncheckedUpdateManyWithoutByUserInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutManagerInput, DepartmentUncheckedUpdateWithoutManagerInput>
    create: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutManagerInput, DepartmentUncheckedUpdateWithoutManagerInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutManagerInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutManagerInput>
  }

  export type ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ModuleAssignmentWhereUniqueInput
    update: XOR<ModuleAssignmentUpdateWithoutAssignedToInput, ModuleAssignmentUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ModuleAssignmentCreateWithoutAssignedToInput, ModuleAssignmentUncheckedCreateWithoutAssignedToInput>
  }

  export type ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ModuleAssignmentWhereUniqueInput
    data: XOR<ModuleAssignmentUpdateWithoutAssignedToInput, ModuleAssignmentUncheckedUpdateWithoutAssignedToInput>
  }

  export type ModuleAssignmentUpdateManyWithWhereWithoutAssignedToInput = {
    where: ModuleAssignmentScalarWhereInput
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type ModuleAssignmentScalarWhereInput = {
    AND?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
    OR?: ModuleAssignmentScalarWhereInput[]
    NOT?: ModuleAssignmentScalarWhereInput | ModuleAssignmentScalarWhereInput[]
    id?: StringFilter<"ModuleAssignment"> | string
    moduleId?: StringFilter<"ModuleAssignment"> | string
    assignedToId?: StringFilter<"ModuleAssignment"> | string
    assignedById?: StringFilter<"ModuleAssignment"> | string
    priority?: StringFilter<"ModuleAssignment"> | string
    deadline?: DateTimeNullableFilter<"ModuleAssignment"> | Date | string | null
    message?: StringNullableFilter<"ModuleAssignment"> | string | null
    status?: StringFilter<"ModuleAssignment"> | string
    completedAt?: DateTimeNullableFilter<"ModuleAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"ModuleAssignment"> | Date | string
  }

  export type ModuleAssignmentUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: ModuleAssignmentWhereUniqueInput
    update: XOR<ModuleAssignmentUpdateWithoutAssignedByInput, ModuleAssignmentUncheckedUpdateWithoutAssignedByInput>
    create: XOR<ModuleAssignmentCreateWithoutAssignedByInput, ModuleAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type ModuleAssignmentUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: ModuleAssignmentWhereUniqueInput
    data: XOR<ModuleAssignmentUpdateWithoutAssignedByInput, ModuleAssignmentUncheckedUpdateWithoutAssignedByInput>
  }

  export type ModuleAssignmentUpdateManyWithWhereWithoutAssignedByInput = {
    where: ModuleAssignmentScalarWhereInput
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type ModuleProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: ModuleProgressWhereUniqueInput
    update: XOR<ModuleProgressUpdateWithoutUserInput, ModuleProgressUncheckedUpdateWithoutUserInput>
    create: XOR<ModuleProgressCreateWithoutUserInput, ModuleProgressUncheckedCreateWithoutUserInput>
  }

  export type ModuleProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: ModuleProgressWhereUniqueInput
    data: XOR<ModuleProgressUpdateWithoutUserInput, ModuleProgressUncheckedUpdateWithoutUserInput>
  }

  export type ModuleProgressUpdateManyWithWhereWithoutUserInput = {
    where: ModuleProgressScalarWhereInput
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type ModuleProgressScalarWhereInput = {
    AND?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
    OR?: ModuleProgressScalarWhereInput[]
    NOT?: ModuleProgressScalarWhereInput | ModuleProgressScalarWhereInput[]
    id?: StringFilter<"ModuleProgress"> | string
    userId?: StringFilter<"ModuleProgress"> | string
    moduleId?: StringFilter<"ModuleProgress"> | string
    status?: StringFilter<"ModuleProgress"> | string
    progressPercent?: IntFilter<"ModuleProgress"> | number
    completedSections?: StringNullableListFilter<"ModuleProgress">
    timeSpentSeconds?: IntFilter<"ModuleProgress"> | number
    quizScore?: FloatNullableFilter<"ModuleProgress"> | number | null
    quizAttempts?: IntFilter<"ModuleProgress"> | number
    startedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ModuleProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"ModuleProgress"> | Date | string
    updatedAt?: DateTimeFilter<"ModuleProgress"> | Date | string
  }

  export type AssessmentSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AssessmentSessionWhereUniqueInput
    update: XOR<AssessmentSessionUpdateWithoutUserInput, AssessmentSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AssessmentSessionCreateWithoutUserInput, AssessmentSessionUncheckedCreateWithoutUserInput>
  }

  export type AssessmentSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AssessmentSessionWhereUniqueInput
    data: XOR<AssessmentSessionUpdateWithoutUserInput, AssessmentSessionUncheckedUpdateWithoutUserInput>
  }

  export type AssessmentSessionUpdateManyWithWhereWithoutUserInput = {
    where: AssessmentSessionScalarWhereInput
    data: XOR<AssessmentSessionUpdateManyMutationInput, AssessmentSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AssessmentSessionScalarWhereInput = {
    AND?: AssessmentSessionScalarWhereInput | AssessmentSessionScalarWhereInput[]
    OR?: AssessmentSessionScalarWhereInput[]
    NOT?: AssessmentSessionScalarWhereInput | AssessmentSessionScalarWhereInput[]
    id?: StringFilter<"AssessmentSession"> | string
    templateId?: StringFilter<"AssessmentSession"> | string
    userId?: StringNullableFilter<"AssessmentSession"> | string | null
    email?: StringNullableFilter<"AssessmentSession"> | string | null
    companyName?: StringNullableFilter<"AssessmentSession"> | string | null
    industry?: StringNullableFilter<"AssessmentSession"> | string | null
    employeeCount?: StringNullableFilter<"AssessmentSession"> | string | null
    answers?: JsonNullableFilter<"AssessmentSession">
    sectionScores?: JsonNullableFilter<"AssessmentSession">
    overallScore?: FloatNullableFilter<"AssessmentSession"> | number | null
    maturityLevel?: StringNullableFilter<"AssessmentSession"> | string | null
    gapAnalysis?: JsonNullableFilter<"AssessmentSession">
    recommendations?: JsonNullableFilter<"AssessmentSession">
    status?: StringFilter<"AssessmentSession"> | string
    startedAt?: DateTimeFilter<"AssessmentSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"AssessmentSession"> | Date | string | null
    convertedToSignup?: BoolFilter<"AssessmentSession"> | boolean
    pdfDownloaded?: BoolFilter<"AssessmentSession"> | boolean
    createdAt?: DateTimeFilter<"AssessmentSession"> | Date | string
  }

  export type UserCertificationUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCertificationWhereUniqueInput
    update: XOR<UserCertificationUpdateWithoutUserInput, UserCertificationUncheckedUpdateWithoutUserInput>
    create: XOR<UserCertificationCreateWithoutUserInput, UserCertificationUncheckedCreateWithoutUserInput>
  }

  export type UserCertificationUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCertificationWhereUniqueInput
    data: XOR<UserCertificationUpdateWithoutUserInput, UserCertificationUncheckedUpdateWithoutUserInput>
  }

  export type UserCertificationUpdateManyWithWhereWithoutUserInput = {
    where: UserCertificationScalarWhereInput
    data: XOR<UserCertificationUpdateManyMutationInput, UserCertificationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCertificationScalarWhereInput = {
    AND?: UserCertificationScalarWhereInput | UserCertificationScalarWhereInput[]
    OR?: UserCertificationScalarWhereInput[]
    NOT?: UserCertificationScalarWhereInput | UserCertificationScalarWhereInput[]
    id?: StringFilter<"UserCertification"> | string
    userId?: StringFilter<"UserCertification"> | string
    name?: StringFilter<"UserCertification"> | string
    certification?: StringFilter<"UserCertification"> | string
    level?: StringNullableFilter<"UserCertification"> | string | null
    issuedAt?: DateTimeFilter<"UserCertification"> | Date | string
    expiresAt?: DateTimeNullableFilter<"UserCertification"> | Date | string | null
    status?: StringFilter<"UserCertification"> | string
    certificateUrl?: StringNullableFilter<"UserCertification"> | string | null
    verificationCode?: StringNullableFilter<"UserCertification"> | string | null
    createdAt?: DateTimeFilter<"UserCertification"> | Date | string
  }

  export type RoadmapUpsertWithWhereUniqueWithoutUserInput = {
    where: RoadmapWhereUniqueInput
    update: XOR<RoadmapUpdateWithoutUserInput, RoadmapUncheckedUpdateWithoutUserInput>
    create: XOR<RoadmapCreateWithoutUserInput, RoadmapUncheckedCreateWithoutUserInput>
  }

  export type RoadmapUpdateWithWhereUniqueWithoutUserInput = {
    where: RoadmapWhereUniqueInput
    data: XOR<RoadmapUpdateWithoutUserInput, RoadmapUncheckedUpdateWithoutUserInput>
  }

  export type RoadmapUpdateManyWithWhereWithoutUserInput = {
    where: RoadmapScalarWhereInput
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyWithoutUserInput>
  }

  export type RoadmapScalarWhereInput = {
    AND?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
    OR?: RoadmapScalarWhereInput[]
    NOT?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    userId?: StringFilter<"Roadmap"> | string
    assessmentSessionId?: StringNullableFilter<"Roadmap"> | string | null
    standardType?: StringFilter<"Roadmap"> | string
    totalSprints?: IntFilter<"Roadmap"> | number
    currentSprint?: IntFilter<"Roadmap"> | number
    sprintDurationWeeks?: IntFilter<"Roadmap"> | number
    completionPercentage?: FloatFilter<"Roadmap"> | number
    estimatedCompletionDate?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    status?: StringFilter<"Roadmap"> | string
    sprintDetails?: JsonNullableFilter<"Roadmap">
    startedAt?: DateTimeFilter<"Roadmap"> | Date | string
    completedAt?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
  }

  export type UserActionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserActionWhereUniqueInput
    update: XOR<UserActionUpdateWithoutUserInput, UserActionUncheckedUpdateWithoutUserInput>
    create: XOR<UserActionCreateWithoutUserInput, UserActionUncheckedCreateWithoutUserInput>
  }

  export type UserActionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserActionWhereUniqueInput
    data: XOR<UserActionUpdateWithoutUserInput, UserActionUncheckedUpdateWithoutUserInput>
  }

  export type UserActionUpdateManyWithWhereWithoutUserInput = {
    where: UserActionScalarWhereInput
    data: XOR<UserActionUpdateManyMutationInput, UserActionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserActionScalarWhereInput = {
    AND?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
    OR?: UserActionScalarWhereInput[]
    NOT?: UserActionScalarWhereInput | UserActionScalarWhereInput[]
    id?: StringFilter<"UserAction"> | string
    userId?: StringFilter<"UserAction"> | string
    roadmapId?: StringFilter<"UserAction"> | string
    actionId?: StringFilter<"UserAction"> | string
    sprintNumber?: IntFilter<"UserAction"> | number
    status?: StringFilter<"UserAction"> | string
    startedAt?: DateTimeNullableFilter<"UserAction"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"UserAction"> | Date | string | null
    notes?: StringNullableFilter<"UserAction"> | string | null
    blockedReason?: StringNullableFilter<"UserAction"> | string | null
    uploadedFiles?: JsonNullableFilter<"UserAction">
    createdAt?: DateTimeFilter<"UserAction"> | Date | string
    updatedAt?: DateTimeFilter<"UserAction"> | Date | string
  }

  export type UserCreateWithoutManagerNotesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagerNotesInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagerNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerNotesInput, UserUncheckedCreateWithoutManagerNotesInput>
  }

  export type UserCreateWithoutNotesWrittenInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesWrittenInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesWrittenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesWrittenInput, UserUncheckedCreateWithoutNotesWrittenInput>
  }

  export type UserUpsertWithoutManagerNotesInput = {
    update: XOR<UserUpdateWithoutManagerNotesInput, UserUncheckedUpdateWithoutManagerNotesInput>
    create: XOR<UserCreateWithoutManagerNotesInput, UserUncheckedCreateWithoutManagerNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagerNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagerNotesInput, UserUncheckedUpdateWithoutManagerNotesInput>
  }

  export type UserUpdateWithoutManagerNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutNotesWrittenInput = {
    update: XOR<UserUpdateWithoutNotesWrittenInput, UserUncheckedUpdateWithoutNotesWrittenInput>
    create: XOR<UserCreateWithoutNotesWrittenInput, UserUncheckedCreateWithoutNotesWrittenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesWrittenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesWrittenInput, UserUncheckedUpdateWithoutNotesWrittenInput>
  }

  export type UserUpdateWithoutNotesWrittenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesWrittenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutModulesInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutModulesInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    assessmentTemplates?: AssessmentTemplateUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutModulesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutModulesInput, OrganizationUncheckedCreateWithoutModulesInput>
  }

  export type ModulePrerequisiteCreateWithoutModuleInput = {
    id?: string
    prerequisite: ModuleCreateNestedOneWithoutUnlocksModulesInput
  }

  export type ModulePrerequisiteUncheckedCreateWithoutModuleInput = {
    id?: string
    prerequisiteId: string
  }

  export type ModulePrerequisiteCreateOrConnectWithoutModuleInput = {
    where: ModulePrerequisiteWhereUniqueInput
    create: XOR<ModulePrerequisiteCreateWithoutModuleInput, ModulePrerequisiteUncheckedCreateWithoutModuleInput>
  }

  export type ModulePrerequisiteCreateManyModuleInputEnvelope = {
    data: ModulePrerequisiteCreateManyModuleInput | ModulePrerequisiteCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModulePrerequisiteCreateWithoutPrerequisiteInput = {
    id?: string
    module: ModuleCreateNestedOneWithoutPrerequisitesInput
  }

  export type ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput = {
    id?: string
    moduleId: string
  }

  export type ModulePrerequisiteCreateOrConnectWithoutPrerequisiteInput = {
    where: ModulePrerequisiteWhereUniqueInput
    create: XOR<ModulePrerequisiteCreateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type ModulePrerequisiteCreateManyPrerequisiteInputEnvelope = {
    data: ModulePrerequisiteCreateManyPrerequisiteInput | ModulePrerequisiteCreateManyPrerequisiteInput[]
    skipDuplicates?: boolean
  }

  export type ModuleAssignmentCreateWithoutModuleInput = {
    id?: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
    assignedTo: UserCreateNestedOneWithoutAssignmentsReceivedInput
    assignedBy: UserCreateNestedOneWithoutAssignmentsMadeInput
  }

  export type ModuleAssignmentUncheckedCreateWithoutModuleInput = {
    id?: string
    assignedToId: string
    assignedById: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleAssignmentCreateOrConnectWithoutModuleInput = {
    where: ModuleAssignmentWhereUniqueInput
    create: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput>
  }

  export type ModuleAssignmentCreateManyModuleInputEnvelope = {
    data: ModuleAssignmentCreateManyModuleInput | ModuleAssignmentCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleProgressCreateWithoutModuleInput = {
    id?: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutModuleProgressInput
  }

  export type ModuleProgressUncheckedCreateWithoutModuleInput = {
    id?: string
    userId: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleProgressCreateOrConnectWithoutModuleInput = {
    where: ModuleProgressWhereUniqueInput
    create: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput>
  }

  export type ModuleProgressCreateManyModuleInputEnvelope = {
    data: ModuleProgressCreateManyModuleInput | ModuleProgressCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutModulesInput = {
    update: XOR<OrganizationUpdateWithoutModulesInput, OrganizationUncheckedUpdateWithoutModulesInput>
    create: XOR<OrganizationCreateWithoutModulesInput, OrganizationUncheckedCreateWithoutModulesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutModulesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutModulesInput, OrganizationUncheckedUpdateWithoutModulesInput>
  }

  export type OrganizationUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    assessmentTemplates?: AssessmentTemplateUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ModulePrerequisiteUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModulePrerequisiteWhereUniqueInput
    update: XOR<ModulePrerequisiteUpdateWithoutModuleInput, ModulePrerequisiteUncheckedUpdateWithoutModuleInput>
    create: XOR<ModulePrerequisiteCreateWithoutModuleInput, ModulePrerequisiteUncheckedCreateWithoutModuleInput>
  }

  export type ModulePrerequisiteUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModulePrerequisiteWhereUniqueInput
    data: XOR<ModulePrerequisiteUpdateWithoutModuleInput, ModulePrerequisiteUncheckedUpdateWithoutModuleInput>
  }

  export type ModulePrerequisiteUpdateManyWithWhereWithoutModuleInput = {
    where: ModulePrerequisiteScalarWhereInput
    data: XOR<ModulePrerequisiteUpdateManyMutationInput, ModulePrerequisiteUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModulePrerequisiteScalarWhereInput = {
    AND?: ModulePrerequisiteScalarWhereInput | ModulePrerequisiteScalarWhereInput[]
    OR?: ModulePrerequisiteScalarWhereInput[]
    NOT?: ModulePrerequisiteScalarWhereInput | ModulePrerequisiteScalarWhereInput[]
    id?: StringFilter<"ModulePrerequisite"> | string
    moduleId?: StringFilter<"ModulePrerequisite"> | string
    prerequisiteId?: StringFilter<"ModulePrerequisite"> | string
  }

  export type ModulePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput = {
    where: ModulePrerequisiteWhereUniqueInput
    update: XOR<ModulePrerequisiteUpdateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
    create: XOR<ModulePrerequisiteCreateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type ModulePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput = {
    where: ModulePrerequisiteWhereUniqueInput
    data: XOR<ModulePrerequisiteUpdateWithoutPrerequisiteInput, ModulePrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
  }

  export type ModulePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput = {
    where: ModulePrerequisiteScalarWhereInput
    data: XOR<ModulePrerequisiteUpdateManyMutationInput, ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput>
  }

  export type ModuleAssignmentUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleAssignmentWhereUniqueInput
    update: XOR<ModuleAssignmentUpdateWithoutModuleInput, ModuleAssignmentUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleAssignmentCreateWithoutModuleInput, ModuleAssignmentUncheckedCreateWithoutModuleInput>
  }

  export type ModuleAssignmentUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleAssignmentWhereUniqueInput
    data: XOR<ModuleAssignmentUpdateWithoutModuleInput, ModuleAssignmentUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleAssignmentUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleAssignmentScalarWhereInput
    data: XOR<ModuleAssignmentUpdateManyMutationInput, ModuleAssignmentUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleProgressUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleProgressWhereUniqueInput
    update: XOR<ModuleProgressUpdateWithoutModuleInput, ModuleProgressUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleProgressCreateWithoutModuleInput, ModuleProgressUncheckedCreateWithoutModuleInput>
  }

  export type ModuleProgressUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleProgressWhereUniqueInput
    data: XOR<ModuleProgressUpdateWithoutModuleInput, ModuleProgressUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleProgressUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleProgressScalarWhereInput
    data: XOR<ModuleProgressUpdateManyMutationInput, ModuleProgressUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleCreateWithoutPrerequisitesInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutModulesInput
    unlocksModules?: ModulePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    organizationId?: string | null
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    unlocksModules?: ModulePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutPrerequisitesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPrerequisitesInput, ModuleUncheckedCreateWithoutPrerequisitesInput>
  }

  export type ModuleCreateWithoutUnlocksModulesInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutModulesInput
    prerequisites?: ModulePrerequisiteCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutUnlocksModulesInput = {
    id?: string
    organizationId?: string | null
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisites?: ModulePrerequisiteUncheckedCreateNestedManyWithoutModuleInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
    progress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutUnlocksModulesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutUnlocksModulesInput, ModuleUncheckedCreateWithoutUnlocksModulesInput>
  }

  export type ModuleUpsertWithoutPrerequisitesInput = {
    update: XOR<ModuleUpdateWithoutPrerequisitesInput, ModuleUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<ModuleCreateWithoutPrerequisitesInput, ModuleUncheckedCreateWithoutPrerequisitesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutPrerequisitesInput, ModuleUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type ModuleUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutModulesNestedInput
    unlocksModules?: ModulePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlocksModules?: ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUpsertWithoutUnlocksModulesInput = {
    update: XOR<ModuleUpdateWithoutUnlocksModulesInput, ModuleUncheckedUpdateWithoutUnlocksModulesInput>
    create: XOR<ModuleCreateWithoutUnlocksModulesInput, ModuleUncheckedCreateWithoutUnlocksModulesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutUnlocksModulesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutUnlocksModulesInput, ModuleUncheckedUpdateWithoutUnlocksModulesInput>
  }

  export type ModuleUpdateWithoutUnlocksModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutModulesNestedInput
    prerequisites?: ModulePrerequisiteUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutUnlocksModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisites?: ModulePrerequisiteUncheckedUpdateManyWithoutModuleNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateWithoutAssignmentsInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutModulesInput
    prerequisites?: ModulePrerequisiteCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    progress?: ModuleProgressCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    organizationId?: string | null
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisites?: ModulePrerequisiteUncheckedCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    progress?: ModuleProgressUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutAssignmentsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutAssignmentsReceivedInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignmentsReceivedInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignmentsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentsReceivedInput, UserUncheckedCreateWithoutAssignmentsReceivedInput>
  }

  export type UserCreateWithoutAssignmentsMadeInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignmentsMadeInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignmentsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignmentsMadeInput, UserUncheckedCreateWithoutAssignmentsMadeInput>
  }

  export type ModuleUpsertWithoutAssignmentsInput = {
    update: XOR<ModuleUpdateWithoutAssignmentsInput, ModuleUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ModuleCreateWithoutAssignmentsInput, ModuleUncheckedCreateWithoutAssignmentsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutAssignmentsInput, ModuleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ModuleUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutModulesNestedInput
    prerequisites?: ModulePrerequisiteUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    progress?: ModuleProgressUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisites?: ModulePrerequisiteUncheckedUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    progress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type UserUpsertWithoutAssignmentsReceivedInput = {
    update: XOR<UserUpdateWithoutAssignmentsReceivedInput, UserUncheckedUpdateWithoutAssignmentsReceivedInput>
    create: XOR<UserCreateWithoutAssignmentsReceivedInput, UserUncheckedCreateWithoutAssignmentsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentsReceivedInput, UserUncheckedUpdateWithoutAssignmentsReceivedInput>
  }

  export type UserUpdateWithoutAssignmentsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAssignmentsMadeInput = {
    update: XOR<UserUpdateWithoutAssignmentsMadeInput, UserUncheckedUpdateWithoutAssignmentsMadeInput>
    create: XOR<UserCreateWithoutAssignmentsMadeInput, UserUncheckedCreateWithoutAssignmentsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignmentsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignmentsMadeInput, UserUncheckedUpdateWithoutAssignmentsMadeInput>
  }

  export type UserUpdateWithoutAssignmentsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignmentsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutModuleProgressInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutModuleProgressInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutModuleProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModuleProgressInput, UserUncheckedCreateWithoutModuleProgressInput>
  }

  export type ModuleCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutModulesInput
    prerequisites?: ModulePrerequisiteCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutProgressInput = {
    id?: string
    organizationId?: string | null
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisites?: ModulePrerequisiteUncheckedCreateNestedManyWithoutModuleInput
    unlocksModules?: ModulePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    assignments?: ModuleAssignmentUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutProgressInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutProgressInput, ModuleUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutModuleProgressInput = {
    update: XOR<UserUpdateWithoutModuleProgressInput, UserUncheckedUpdateWithoutModuleProgressInput>
    create: XOR<UserCreateWithoutModuleProgressInput, UserUncheckedCreateWithoutModuleProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModuleProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModuleProgressInput, UserUncheckedUpdateWithoutModuleProgressInput>
  }

  export type UserUpdateWithoutModuleProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutModuleProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ModuleUpsertWithoutProgressInput = {
    update: XOR<ModuleUpdateWithoutProgressInput, ModuleUncheckedUpdateWithoutProgressInput>
    create: XOR<ModuleCreateWithoutProgressInput, ModuleUncheckedCreateWithoutProgressInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutProgressInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutProgressInput, ModuleUncheckedUpdateWithoutProgressInput>
  }

  export type ModuleUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutModulesNestedInput
    prerequisites?: ModulePrerequisiteUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisites?: ModulePrerequisiteUncheckedUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type OrganizationCreateWithoutAssessmentTemplatesInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutOrganizationInput
    users?: UserCreateNestedManyWithoutOrganizationInput
    modules?: ModuleCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAssessmentTemplatesInput = {
    id?: string
    name: string
    slug: string
    industry?: string | null
    employeeCount?: number | null
    logo?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    timezone?: string
    language?: string
    plan?: string
    planSeats?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrganizationInput
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    modules?: ModuleUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAssessmentTemplatesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAssessmentTemplatesInput, OrganizationUncheckedCreateWithoutAssessmentTemplatesInput>
  }

  export type AssessmentSessionCreateWithoutTemplateInput = {
    id?: string
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAssessmentSessionsInput
  }

  export type AssessmentSessionUncheckedCreateWithoutTemplateInput = {
    id?: string
    userId?: string | null
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
  }

  export type AssessmentSessionCreateOrConnectWithoutTemplateInput = {
    where: AssessmentSessionWhereUniqueInput
    create: XOR<AssessmentSessionCreateWithoutTemplateInput, AssessmentSessionUncheckedCreateWithoutTemplateInput>
  }

  export type AssessmentSessionCreateManyTemplateInputEnvelope = {
    data: AssessmentSessionCreateManyTemplateInput | AssessmentSessionCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutAssessmentTemplatesInput = {
    update: XOR<OrganizationUpdateWithoutAssessmentTemplatesInput, OrganizationUncheckedUpdateWithoutAssessmentTemplatesInput>
    create: XOR<OrganizationCreateWithoutAssessmentTemplatesInput, OrganizationUncheckedCreateWithoutAssessmentTemplatesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAssessmentTemplatesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAssessmentTemplatesInput, OrganizationUncheckedUpdateWithoutAssessmentTemplatesInput>
  }

  export type OrganizationUpdateWithoutAssessmentTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutOrganizationNestedInput
    users?: UserUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAssessmentTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableIntFieldUpdateOperationsInput | number | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planSeats?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutOrganizationNestedInput
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type AssessmentSessionUpsertWithWhereUniqueWithoutTemplateInput = {
    where: AssessmentSessionWhereUniqueInput
    update: XOR<AssessmentSessionUpdateWithoutTemplateInput, AssessmentSessionUncheckedUpdateWithoutTemplateInput>
    create: XOR<AssessmentSessionCreateWithoutTemplateInput, AssessmentSessionUncheckedCreateWithoutTemplateInput>
  }

  export type AssessmentSessionUpdateWithWhereUniqueWithoutTemplateInput = {
    where: AssessmentSessionWhereUniqueInput
    data: XOR<AssessmentSessionUpdateWithoutTemplateInput, AssessmentSessionUncheckedUpdateWithoutTemplateInput>
  }

  export type AssessmentSessionUpdateManyWithWhereWithoutTemplateInput = {
    where: AssessmentSessionScalarWhereInput
    data: XOR<AssessmentSessionUpdateManyMutationInput, AssessmentSessionUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AssessmentTemplateCreateWithoutSessionsInput = {
    id?: string
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutAssessmentTemplatesInput
  }

  export type AssessmentTemplateUncheckedCreateWithoutSessionsInput = {
    id?: string
    organizationId?: string | null
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTemplateCreateOrConnectWithoutSessionsInput = {
    where: AssessmentTemplateWhereUniqueInput
    create: XOR<AssessmentTemplateCreateWithoutSessionsInput, AssessmentTemplateUncheckedCreateWithoutSessionsInput>
  }

  export type UserCreateWithoutAssessmentSessionsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssessmentSessionsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssessmentSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssessmentSessionsInput, UserUncheckedCreateWithoutAssessmentSessionsInput>
  }

  export type AssessmentTemplateUpsertWithoutSessionsInput = {
    update: XOR<AssessmentTemplateUpdateWithoutSessionsInput, AssessmentTemplateUncheckedUpdateWithoutSessionsInput>
    create: XOR<AssessmentTemplateCreateWithoutSessionsInput, AssessmentTemplateUncheckedCreateWithoutSessionsInput>
    where?: AssessmentTemplateWhereInput
  }

  export type AssessmentTemplateUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AssessmentTemplateWhereInput
    data: XOR<AssessmentTemplateUpdateWithoutSessionsInput, AssessmentTemplateUncheckedUpdateWithoutSessionsInput>
  }

  export type AssessmentTemplateUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutAssessmentTemplatesNestedInput
  }

  export type AssessmentTemplateUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAssessmentSessionsInput = {
    update: XOR<UserUpdateWithoutAssessmentSessionsInput, UserUncheckedUpdateWithoutAssessmentSessionsInput>
    create: XOR<UserCreateWithoutAssessmentSessionsInput, UserUncheckedCreateWithoutAssessmentSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssessmentSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssessmentSessionsInput, UserUncheckedUpdateWithoutAssessmentSessionsInput>
  }

  export type UserUpdateWithoutAssessmentSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssessmentSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCertificationsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCertificationsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCertificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
  }

  export type UserUpsertWithoutCertificationsInput = {
    update: XOR<UserUpdateWithoutCertificationsInput, UserUncheckedUpdateWithoutCertificationsInput>
    create: XOR<UserCreateWithoutCertificationsInput, UserUncheckedCreateWithoutCertificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificationsInput, UserUncheckedUpdateWithoutCertificationsInput>
  }

  export type UserUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRoadmapsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    userActions?: UserActionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoadmapsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    userActions?: UserActionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoadmapsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
  }

  export type UserActionCreateWithoutRoadmapInput = {
    id?: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserActionsInput
    action: ActionCreateNestedOneWithoutUserActionsInput
  }

  export type UserActionUncheckedCreateWithoutRoadmapInput = {
    id?: string
    userId: string
    actionId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionCreateOrConnectWithoutRoadmapInput = {
    where: UserActionWhereUniqueInput
    create: XOR<UserActionCreateWithoutRoadmapInput, UserActionUncheckedCreateWithoutRoadmapInput>
  }

  export type UserActionCreateManyRoadmapInputEnvelope = {
    data: UserActionCreateManyRoadmapInput | UserActionCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRoadmapsInput = {
    update: XOR<UserUpdateWithoutRoadmapsInput, UserUncheckedUpdateWithoutRoadmapsInput>
    create: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoadmapsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoadmapsInput, UserUncheckedUpdateWithoutRoadmapsInput>
  }

  export type UserUpdateWithoutRoadmapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoadmapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserActionUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: UserActionWhereUniqueInput
    update: XOR<UserActionUpdateWithoutRoadmapInput, UserActionUncheckedUpdateWithoutRoadmapInput>
    create: XOR<UserActionCreateWithoutRoadmapInput, UserActionUncheckedCreateWithoutRoadmapInput>
  }

  export type UserActionUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: UserActionWhereUniqueInput
    data: XOR<UserActionUpdateWithoutRoadmapInput, UserActionUncheckedUpdateWithoutRoadmapInput>
  }

  export type UserActionUpdateManyWithWhereWithoutRoadmapInput = {
    where: UserActionScalarWhereInput
    data: XOR<UserActionUpdateManyMutationInput, UserActionUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type UserActionCreateWithoutActionInput = {
    id?: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserActionsInput
    roadmap: RoadmapCreateNestedOneWithoutUserActionsInput
  }

  export type UserActionUncheckedCreateWithoutActionInput = {
    id?: string
    userId: string
    roadmapId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionCreateOrConnectWithoutActionInput = {
    where: UserActionWhereUniqueInput
    create: XOR<UserActionCreateWithoutActionInput, UserActionUncheckedCreateWithoutActionInput>
  }

  export type UserActionCreateManyActionInputEnvelope = {
    data: UserActionCreateManyActionInput | UserActionCreateManyActionInput[]
    skipDuplicates?: boolean
  }

  export type UserActionUpsertWithWhereUniqueWithoutActionInput = {
    where: UserActionWhereUniqueInput
    update: XOR<UserActionUpdateWithoutActionInput, UserActionUncheckedUpdateWithoutActionInput>
    create: XOR<UserActionCreateWithoutActionInput, UserActionUncheckedCreateWithoutActionInput>
  }

  export type UserActionUpdateWithWhereUniqueWithoutActionInput = {
    where: UserActionWhereUniqueInput
    data: XOR<UserActionUpdateWithoutActionInput, UserActionUncheckedUpdateWithoutActionInput>
  }

  export type UserActionUpdateManyWithWhereWithoutActionInput = {
    where: UserActionScalarWhereInput
    data: XOR<UserActionUpdateManyMutationInput, UserActionUncheckedUpdateManyWithoutActionInput>
  }

  export type UserCreateWithoutUserActionsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutUsersInput
    department?: DepartmentCreateNestedOneWithoutMembersInput
    managerNotes?: ManagerNoteCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionCreateNestedManyWithoutUserInput
    certifications?: UserCertificationCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserActionsInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    managerNotes?: ManagerNoteUncheckedCreateNestedManyWithoutAboutUserInput
    notesWritten?: ManagerNoteUncheckedCreateNestedManyWithoutByUserInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    assignmentsReceived?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedToInput
    assignmentsMade?: ModuleAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    moduleProgress?: ModuleProgressUncheckedCreateNestedManyWithoutUserInput
    assessmentSessions?: AssessmentSessionUncheckedCreateNestedManyWithoutUserInput
    certifications?: UserCertificationUncheckedCreateNestedManyWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserActionsInput, UserUncheckedCreateWithoutUserActionsInput>
  }

  export type RoadmapCreateWithoutUserActionsInput = {
    id?: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoadmapsInput
  }

  export type RoadmapUncheckedCreateWithoutUserActionsInput = {
    id?: string
    userId: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapCreateOrConnectWithoutUserActionsInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutUserActionsInput, RoadmapUncheckedCreateWithoutUserActionsInput>
  }

  export type ActionCreateWithoutUserActionsInput = {
    id?: string
    standardType: string
    actionCode: string
    title: string
    description: string
    requirementRef: string
    chapterNumber?: string | null
    estimatedHours?: number
    priorityWeight?: number
    category?: string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionCreatetemplateIdsInput | string[]
    videoUrl?: string | null
    dependsOnActions?: ActionCreatedependsOnActionsInput | string[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionUncheckedCreateWithoutUserActionsInput = {
    id?: string
    standardType: string
    actionCode: string
    title: string
    description: string
    requirementRef: string
    chapterNumber?: string | null
    estimatedHours?: number
    priorityWeight?: number
    category?: string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionCreatetemplateIdsInput | string[]
    videoUrl?: string | null
    dependsOnActions?: ActionCreatedependsOnActionsInput | string[]
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionCreateOrConnectWithoutUserActionsInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutUserActionsInput, ActionUncheckedCreateWithoutUserActionsInput>
  }

  export type UserUpsertWithoutUserActionsInput = {
    update: XOR<UserUpdateWithoutUserActionsInput, UserUncheckedUpdateWithoutUserActionsInput>
    create: XOR<UserCreateWithoutUserActionsInput, UserUncheckedCreateWithoutUserActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserActionsInput, UserUncheckedUpdateWithoutUserActionsInput>
  }

  export type UserUpdateWithoutUserActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoadmapUpsertWithoutUserActionsInput = {
    update: XOR<RoadmapUpdateWithoutUserActionsInput, RoadmapUncheckedUpdateWithoutUserActionsInput>
    create: XOR<RoadmapCreateWithoutUserActionsInput, RoadmapUncheckedCreateWithoutUserActionsInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutUserActionsInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutUserActionsInput, RoadmapUncheckedUpdateWithoutUserActionsInput>
  }

  export type RoadmapUpdateWithoutUserActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoadmapsNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutUserActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUpsertWithoutUserActionsInput = {
    update: XOR<ActionUpdateWithoutUserActionsInput, ActionUncheckedUpdateWithoutUserActionsInput>
    create: XOR<ActionCreateWithoutUserActionsInput, ActionUncheckedCreateWithoutUserActionsInput>
    where?: ActionWhereInput
  }

  export type ActionUpdateToOneWithWhereWithoutUserActionsInput = {
    where?: ActionWhereInput
    data: XOR<ActionUpdateWithoutUserActionsInput, ActionUncheckedUpdateWithoutUserActionsInput>
  }

  export type ActionUpdateWithoutUserActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    actionCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirementRef?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedHours?: IntFieldUpdateOperationsInput | number
    priorityWeight?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionUpdatetemplateIdsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnActions?: ActionUpdatedependsOnActionsInput | string[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUncheckedUpdateWithoutUserActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    standardType?: StringFieldUpdateOperationsInput | string
    actionCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requirementRef?: StringFieldUpdateOperationsInput | string
    chapterNumber?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedHours?: IntFieldUpdateOperationsInput | number
    priorityWeight?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sectorVariations?: NullableJsonNullValueInput | InputJsonValue
    templateIds?: ActionUpdatetemplateIdsInput | string[]
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dependsOnActions?: ActionUpdatedependsOnActionsInput | string[]
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyRuleInput = {
    id?: string
    severity: string
    title: string
    description?: string | null
    affectedUserId?: string | null
    affectedEntityType?: string | null
    affectedEntityId?: string | null
    triggerMetric: string
    triggerValue: number
    triggerThreshold: number
    recommendedActions?: AlertCreaterecommendedActionsInput | string[]
    status?: string
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutAlertNestedInput
  }

  export type AlertUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    affectedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityType?: NullableStringFieldUpdateOperationsInput | string | null
    affectedEntityId?: NullableStringFieldUpdateOperationsInput | string | null
    triggerMetric?: StringFieldUpdateOperationsInput | string
    triggerValue?: FloatFieldUpdateOperationsInput | number
    triggerThreshold?: FloatFieldUpdateOperationsInput | number
    recommendedActions?: AlertUpdaterecommendedActionsInput | string[]
    status?: StringFieldUpdateOperationsInput | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyAlertInput = {
    id?: string
    userId: string
    type: string
    title: string
    message: string
    link?: string | null
    icon?: string | null
    read?: boolean
    readAt?: Date | string | null
    emailSent?: boolean
    emailSentAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAlertInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailSent?: BoolFieldUpdateOperationsInput | boolean
    emailSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportCreateManyTemplateInput = {
    id?: string
    name: string
    type: string
    format: string
    periodStart: Date | string
    periodEnd: Date | string
    requestedBy?: string | null
    generatedAt?: Date | string
    filePath?: string | null
    fileSize?: number | null
    mimeType?: string | null
    status?: string
    errorMessage?: string | null
    emailed?: boolean
    emailedAt?: Date | string | null
    downloadCount?: number
    createdAt?: Date | string
  }

  export type GeneratedReportUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedReportUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    emailed?: BoolFieldUpdateOperationsInput | boolean
    emailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    downloadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    departmentId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateManyOrganizationInput = {
    id?: string
    title: string
    description?: string | null
    coverImage?: string | null
    category: string
    tags?: ModuleCreatetagsInput | string[]
    difficulty?: string
    estimatedDuration?: number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: number
    badge?: string | null
    status?: string
    publishedAt?: Date | string | null
    completionCount?: number
    avgScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentTemplateCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    certification: string
    version?: string
    estimatedDuration?: number
    sections: JsonNullValueInput | InputJsonValue
    scoringMethod?: string
    maturityLevels: JsonNullValueInput | InputJsonValue
    status?: string
    isDemo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
    members?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutMembersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisites?: ModulePrerequisiteUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisites?: ModulePrerequisiteUncheckedUpdateManyWithoutModuleNestedInput
    unlocksModules?: ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    assignments?: ModuleAssignmentUncheckedUpdateManyWithoutModuleNestedInput
    progress?: ModuleProgressUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: ModuleUpdatetagsInput | string[]
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: NullableJsonNullValueInput | InputJsonValue
    xpReward?: IntFieldUpdateOperationsInput | number
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completionCount?: IntFieldUpdateOperationsInput | number
    avgScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentTemplateUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AssessmentSessionUpdateManyWithoutTemplateNestedInput
  }

  export type AssessmentTemplateUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: AssessmentSessionUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type AssessmentTemplateUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    certification?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    estimatedDuration?: IntFieldUpdateOperationsInput | number
    sections?: JsonNullValueInput | InputJsonValue
    scoringMethod?: StringFieldUpdateOperationsInput | string
    maturityLevels?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isDemo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyDepartmentInput = {
    id?: string
    email: string
    name: string
    avatar?: string | null
    organizationId?: string | null
    role?: string
    status?: string
    position?: string | null
    companyName?: string | null
    companySize?: string | null
    industrySector?: string | null
    targetStandard?: string | null
    subscriptionStatus?: string
    subscriptionStartDate?: Date | string | null
    subscriptionEndDate?: Date | string | null
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    onboardingCompletedSteps?: UserCreateonboardingCompletedStepsInput | string[]
    lastLoginAt?: Date | string | null
    invitedAt?: Date | string | null
    invitedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutUsersNestedInput
    managerNotes?: ManagerNoteUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutUserNestedInput
    userActions?: UserActionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    managerNotes?: ManagerNoteUncheckedUpdateManyWithoutAboutUserNestedInput
    notesWritten?: ManagerNoteUncheckedUpdateManyWithoutByUserNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    assignmentsReceived?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedToNestedInput
    assignmentsMade?: ModuleAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    moduleProgress?: ModuleProgressUncheckedUpdateManyWithoutUserNestedInput
    assessmentSessions?: AssessmentSessionUncheckedUpdateManyWithoutUserNestedInput
    certifications?: UserCertificationUncheckedUpdateManyWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutUserNestedInput
    userActions?: UserActionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySize?: NullableStringFieldUpdateOperationsInput | string | null
    industrySector?: NullableStringFieldUpdateOperationsInput | string | null
    targetStandard?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    onboardingCompletedSteps?: UserUpdateonboardingCompletedStepsInput | string[]
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteCreateManyAboutUserInput = {
    id?: string
    byUserId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerNoteCreateManyByUserInput = {
    id?: string
    aboutUserId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyManagerInput = {
    id?: string
    organizationId: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleAssignmentCreateManyAssignedToInput = {
    id?: string
    moduleId: string
    assignedById: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleAssignmentCreateManyAssignedByInput = {
    id?: string
    moduleId: string
    assignedToId: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleProgressCreateManyUserInput = {
    id?: string
    moduleId: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssessmentSessionCreateManyUserInput = {
    id?: string
    templateId: string
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
  }

  export type UserCertificationCreateManyUserInput = {
    id?: string
    name: string
    certification: string
    level?: string | null
    issuedAt: Date | string
    expiresAt?: Date | string | null
    status?: string
    certificateUrl?: string | null
    verificationCode?: string | null
    createdAt?: Date | string
  }

  export type RoadmapCreateManyUserInput = {
    id?: string
    assessmentSessionId?: string | null
    standardType: string
    totalSprints?: number
    currentSprint?: number
    sprintDurationWeeks?: number
    completionPercentage?: number
    estimatedCompletionDate?: Date | string | null
    status?: string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: Date | string
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionCreateManyUserInput = {
    id?: string
    roadmapId: string
    actionId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerNoteUpdateWithoutAboutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    byUser?: UserUpdateOneRequiredWithoutNotesWrittenNestedInput
  }

  export type ManagerNoteUncheckedUpdateWithoutAboutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    byUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteUncheckedUpdateManyWithoutAboutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    byUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aboutUser?: UserUpdateOneRequiredWithoutManagerNotesNestedInput
  }

  export type ManagerNoteUncheckedUpdateWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aboutUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerNoteUncheckedUpdateManyWithoutByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    aboutUserId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    members?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutAssignmentsNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignmentsMadeNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutAssignmentsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutAssignmentsReceivedNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutProgressNestedInput
  }

  export type ModuleProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: AssessmentTemplateUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type AssessmentSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCertificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCertificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCertificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    certification?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userActions?: UserActionUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userActions?: UserActionUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    standardType?: StringFieldUpdateOperationsInput | string
    totalSprints?: IntFieldUpdateOperationsInput | number
    currentSprint?: IntFieldUpdateOperationsInput | number
    sprintDurationWeeks?: IntFieldUpdateOperationsInput | number
    completionPercentage?: FloatFieldUpdateOperationsInput | number
    estimatedCompletionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    sprintDetails?: NullableJsonNullValueInput | InputJsonValue
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutUserActionsNestedInput
    action?: ActionUpdateOneRequiredWithoutUserActionsNestedInput
  }

  export type UserActionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    actionId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    actionId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModulePrerequisiteCreateManyModuleInput = {
    id?: string
    prerequisiteId: string
  }

  export type ModulePrerequisiteCreateManyPrerequisiteInput = {
    id?: string
    moduleId: string
  }

  export type ModuleAssignmentCreateManyModuleInput = {
    id?: string
    assignedToId: string
    assignedById: string
    priority?: string
    deadline?: Date | string | null
    message?: string | null
    status?: string
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ModuleProgressCreateManyModuleInput = {
    id?: string
    userId: string
    status?: string
    progressPercent?: number
    completedSections?: ModuleProgressCreatecompletedSectionsInput | string[]
    timeSpentSeconds?: number
    quizScore?: number | null
    quizAttempts?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModulePrerequisiteUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisite?: ModuleUpdateOneRequiredWithoutUnlocksModulesNestedInput
  }

  export type ModulePrerequisiteUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePrerequisiteUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePrerequisiteUpdateWithoutPrerequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    module?: ModuleUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type ModulePrerequisiteUncheckedUpdateWithoutPrerequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type ModulePrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleAssignmentUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneRequiredWithoutAssignmentsReceivedNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutAssignmentsMadeNestedInput
  }

  export type ModuleAssignmentUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleAssignmentUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutModuleProgressNestedInput
  }

  export type ModuleProgressUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleProgressUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedSections?: ModuleProgressUpdatecompletedSectionsInput | string[]
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    quizScore?: NullableFloatFieldUpdateOperationsInput | number | null
    quizAttempts?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionCreateManyTemplateInput = {
    id?: string
    userId?: string | null
    email?: string | null
    companyName?: string | null
    industry?: string | null
    employeeCount?: string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: number | null
    maturityLevel?: string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    convertedToSignup?: boolean
    pdfDownloaded?: boolean
    createdAt?: Date | string
  }

  export type AssessmentSessionUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAssessmentSessionsNestedInput
  }

  export type AssessmentSessionUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssessmentSessionUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCount?: NullableStringFieldUpdateOperationsInput | string | null
    answers?: NullableJsonNullValueInput | InputJsonValue
    sectionScores?: NullableJsonNullValueInput | InputJsonValue
    overallScore?: NullableFloatFieldUpdateOperationsInput | number | null
    maturityLevel?: NullableStringFieldUpdateOperationsInput | string | null
    gapAnalysis?: NullableJsonNullValueInput | InputJsonValue
    recommendations?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    convertedToSignup?: BoolFieldUpdateOperationsInput | boolean
    pdfDownloaded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionCreateManyRoadmapInput = {
    id?: string
    userId: string
    actionId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserActionsNestedInput
    action?: ActionUpdateOneRequiredWithoutUserActionsNestedInput
  }

  export type UserActionUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionCreateManyActionInput = {
    id?: string
    userId: string
    roadmapId: string
    sprintNumber: number
    status?: string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    notes?: string | null
    blockedReason?: string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserActionUpdateWithoutActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserActionsNestedInput
    roadmap?: RoadmapUpdateOneRequiredWithoutUserActionsNestedInput
  }

  export type UserActionUncheckedUpdateWithoutActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserActionUncheckedUpdateManyWithoutActionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    sprintNumber?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    blockedReason?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedFiles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AlertRuleCountOutputTypeDefaultArgs instead
     */
    export type AlertRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertCountOutputTypeDefaultArgs instead
     */
    export type AlertCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportTemplateCountOutputTypeDefaultArgs instead
     */
    export type ReportTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleCountOutputTypeDefaultArgs instead
     */
    export type ModuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentTemplateCountOutputTypeDefaultArgs instead
     */
    export type AssessmentTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentTemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapCountOutputTypeDefaultArgs instead
     */
    export type RoadmapCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionCountOutputTypeDefaultArgs instead
     */
    export type ActionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyStatDefaultArgs instead
     */
    export type DailyStatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyStatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProgressDefaultArgs instead
     */
    export type UserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertRuleDefaultArgs instead
     */
    export type AlertRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportTemplateDefaultArgs instead
     */
    export type ReportTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GeneratedReportDefaultArgs instead
     */
    export type GeneratedReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GeneratedReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerNoteDefaultArgs instead
     */
    export type ManagerNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManagerNoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleDefaultArgs instead
     */
    export type ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModulePrerequisiteDefaultArgs instead
     */
    export type ModulePrerequisiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModulePrerequisiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleAssignmentDefaultArgs instead
     */
    export type ModuleAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleProgressDefaultArgs instead
     */
    export type ModuleProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentTemplateDefaultArgs instead
     */
    export type AssessmentTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssessmentSessionDefaultArgs instead
     */
    export type AssessmentSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssessmentSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCertificationDefaultArgs instead
     */
    export type UserCertificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCertificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapDefaultArgs instead
     */
    export type RoadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionDefaultArgs instead
     */
    export type ActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserActionDefaultArgs instead
     */
    export type UserActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TemplateDefaultArgs instead
     */
    export type TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StandardConfigDefaultArgs instead
     */
    export type StandardConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StandardConfigDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}